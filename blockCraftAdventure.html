<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Block Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            font-family: Arial, sans-serif;
            touch-action: none;
            color: white;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            background-color: #111;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 90vh;
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            padding: 10px;
            justify-content: space-around;
        }

        .control-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
        }

        .control-button:active {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-bar {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background-color: #222;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
<div id="game-container"></div>

<div id="mobile-controls">
    <div class="control-button" id="btn-left">←</div>
    <div class="control-button" id="btn-rotate">↻</div>
    <div class="control-button" id="btn-right">→</div>
    <div class="control-button" id="btn-down">↓</div>
    <div class="control-button" id="btn-drop">⬇</div>
    <div class="control-button" id="btn-hold">H</div>
</div>

<div class="loading-screen" id="loading-screen">
    <h1>Tetris Block Adventure</h1>
    <p>Loading... Please wait</p>
    <div class="loading-bar">
        <div class="loading-progress" id="loading-progress"></div>
    </div>
</div>

<script>
	/**
	 * Tetris Block Adventure
	 * A game that combines Tetris and platformer gameplay.
	 */

	// Wait for DOM to be ready
	document.addEventListener('DOMContentLoaded', function() {
		// Hide loading screen after a delay for simplicity
		setTimeout(() => {
			document.getElementById('loading-screen').style.display = 'none';
			initGame();
		}, 1000);
	});

	// Game configuration
	const config = {
		tetris: {
			gridWidth: 10,        // Standard Tetris width
			gridHeight: 20,       // Standard Tetris height
			blockSize: 30,        // Size of each block in pixels
			buildTime: 60,        // Time to build in seconds
			colors: [
				'#00FFFF',  // I - Cyan
				'#0000FF',  // J - Blue
				'#FFA500',  // L - Orange
				'#FFFF00',  // O - Yellow
				'#00FF00',  // S - Green
				'#800080',  // T - Purple
				'#FF0000'   // Z - Red
			],
			shapes: [
				// I shape
				[
					[0, 0, 0, 0],
					[1, 1, 1, 1],
					[0, 0, 0, 0],
					[0, 0, 0, 0]
				],
				// J shape
				[
					[1, 0, 0],
					[1, 1, 1],
					[0, 0, 0]
				],
				// L shape
				[
					[0, 0, 1],
					[1, 1, 1],
					[0, 0, 0]
				],
				// O shape
				[
					[1, 1],
					[1, 1]
				],
				// S shape
				[
					[0, 1, 1],
					[1, 1, 0],
					[0, 0, 0]
				],
				// T shape
				[
					[0, 1, 0],
					[1, 1, 1],
					[0, 0, 0]
				],
				// Z shape
				[
					[1, 1, 0],
					[0, 1, 1],
					[0, 0, 0]
				]
			]
		},
		platformer: {
			gravity: 0.5,
			playerSpeed: 5,
			jumpVelocity: -12,
			playerSize: 30,
			lives: 3,
			coinValue: 100,
			enemyTypes: [
				{ name: 'walker', color: '#FF0000', speed: 2, damage: 1 },
				{ name: 'jumper', color: '#FF6600', speed: 3, damage: 1, jumpHeight: 8 },
				{ name: 'flyer', color: '#AA00FF', speed: 3, damage: 1, flyHeight: 100 }
			],
			hazardTypes: [
				{ name: 'spikes', color: '#777777', damage: 1 },
				{ name: 'lava', color: '#FF3300', damage: 2 }
			],
			waterColor: '#4444FF',
			elevatorColor: '#888888',
			playerColor: '#FF5722',
			coinColor: '#FFD700',
			flagColor: '#FF0000'
		},
		parallax: {
			layers: [
				{ speed: 0.05, color: '#80A0C0' }, // Far mountains
				{ speed: 0.1, color: '#608090' },  // Mid mountains
				{ speed: 0.2, color: '#405060' }   // Near mountains
			]
		},
		game: {
			width: 800,
			height: 600,
			backgroundColor: '#111111'
		}
	};

	// Game states
	const GAME_STATE = {
		MENU: 0,
		TETRIS: 1,
		PLATFORMER: 2,
		GAME_OVER: 3
	};

	// Game variables
	let gameState = GAME_STATE.MENU;
	let canvas, ctx;
	let gameStats = {
		score: 0,
		level: 1,
		lives: config.platformer.lives,
		coins: 0
	};

	// Tetris variables
	let tetrisGrid = [];
	let currentPiece = null;
	let nextPiece = null;
	let heldPiece = null;
	let canHold = true;
	let timeLeft = config.tetris.buildTime;

	// Controls state
	let keysPressed = {
		left: false,
		right: false,
		up: false,
		down: false,
		space: false,
		c: false
	};

	// Platformer variables
	let platforms = [];
	let coins = [];
	let waters = [];
	let elevators = [];
	let enemies = [];
	let hazards = [];
	let backgroundLayers = [];
	let level = { width: 0, height: 0 };
	let particles = [];
	let particleEmitters = [];
	let decorations = [];
	let treasures = [];
	let menuButton = null;
	let gameOverButton = null;

	let player = {
		x: 0,
		y: 0,
		width: config.platformer.playerSize,
		height: config.platformer.playerSize,
		velocityX: 0,
		velocityY: 0,
		isJumping: false,
		onGround: false,
		facing: 1, // 1 = right, -1 = left
		invulnerable: 0, // Invulnerability timer after taking damage
		animation: 0, // For player animation frame
		jumpStrength: 0, // For variable height jumps
		doubleJump: false // Can player double jump
	};

	let goal = { x: 0, y: 0 };
	let camera = { x: 0, y: 0 };

	/**
	 * Initialize the game
	 */
	function initGame() {
		// Create canvas
		canvas = document.createElement('canvas');
		canvas.width = config.game.width;
		canvas.height = config.game.height;
		ctx = canvas.getContext('2d');

		// Add canvas to container
		const container = document.getElementById('game-container');
		container.appendChild(canvas);

		// Set up event listeners
		window.addEventListener('keydown', handleKeyDown);
		window.addEventListener('keyup', handleKeyUp);

		// Mouse and touch event listeners
		canvas.addEventListener('mousedown', handleMouseDown);
		canvas.addEventListener('touchstart', handleTouchStart);

		// Set up touch controls
		setupTouchControls();

		// Responsive resizing
		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		// Start the game loop
		requestAnimationFrame(gameLoop);

		// Start with menu
		gameState = GAME_STATE.MENU;
	}

	/**
	 * Handle mouse down events
	 */
	function handleMouseDown(e) {
		const rect = canvas.getBoundingClientRect();
		const clickX = (e.clientX - rect.left) * (canvas.width / rect.width);
		const clickY = (e.clientY - rect.top) * (canvas.height / rect.height);

		checkButtonClick(clickX, clickY);
	}

	/**
	 * Handle touch start events
	 */
	function handleTouchStart(e) {
		e.preventDefault();

		if (e.touches.length > 0) {
			const rect = canvas.getBoundingClientRect();
			const touchX = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
			const touchY = (e.touches[0].clientY - rect.top) * (canvas.height / rect.height);

			checkButtonClick(touchX, touchY);
		}
	}

	/**
	 * Check if a button was clicked
	 */
	function checkButtonClick(x, y) {
		// Check main menu button
		if (gameState === GAME_STATE.MENU && menuButton) {
			if (x >= menuButton.x && x <= menuButton.x + menuButton.width &&
				y >= menuButton.y && y <= menuButton.y + menuButton.height) {
				startGame();
			}
		}

		// Check game over button
		if (gameState === GAME_STATE.GAME_OVER && gameOverButton) {
			if (x >= gameOverButton.x && x <= gameOverButton.x + gameOverButton.width &&
				y >= gameOverButton.y && y <= gameOverButton.y + gameOverButton.height) {
				startGame();
			}
		}
	}

	/**
	 * Resize canvas to fit window
	 */
	function resizeCanvas() {
		const container = document.getElementById('game-container');
		const windowWidth = window.innerWidth;
		const windowHeight = window.innerHeight;
		const windowRatio = windowWidth / windowHeight;
		const gameRatio = config.game.width / config.game.height;

		let newWidth, newHeight;

		if (windowRatio < gameRatio) {
			newWidth = windowWidth;
			newHeight = windowWidth / gameRatio;
		} else {
			newWidth = windowHeight * gameRatio;
			newHeight = windowHeight;
		}

		canvas.style.width = newWidth + 'px';
		canvas.style.height = newHeight + 'px';
	}

	/**
	 * Set up touch controls
	 */
	function setupTouchControls() {
		if ('ontouchstart' in window) {
			const mobileControls = document.getElementById('mobile-controls');
			mobileControls.style.display = 'flex';

			// Control button events
			const btnLeft = document.getElementById('btn-left');
			const btnRight = document.getElementById('btn-right');
			const btnRotate = document.getElementById('btn-rotate');
			const btnDown = document.getElementById('btn-down');
			const btnDrop = document.getElementById('btn-drop');
			const btnHold = document.getElementById('btn-hold');

			// Touch events for controls
			btnLeft.addEventListener('touchstart', () => { keysPressed.left = true; });
			btnLeft.addEventListener('touchend', () => { keysPressed.left = false; });

			btnRight.addEventListener('touchstart', () => { keysPressed.right = true; });
			btnRight.addEventListener('touchend', () => { keysPressed.right = false; });

			btnRotate.addEventListener('touchstart', () => { keysPressed.up = true; });
			btnRotate.addEventListener('touchend', () => { keysPressed.up = false; });

			btnDown.addEventListener('touchstart', () => { keysPressed.down = true; });
			btnDown.addEventListener('touchend', () => { keysPressed.down = false; });

			btnDrop.addEventListener('touchstart', () => { keysPressed.space = true; });
			btnDrop.addEventListener('touchend', () => { keysPressed.space = false; });

			btnHold.addEventListener('touchstart', () => { keysPressed.c = true; });
			btnHold.addEventListener('touchend', () => { keysPressed.c = false; });
		}
	}

	/**
	 * Handle key down events
	 */
	function handleKeyDown(e) {
		switch(e.key) {
			case 'ArrowLeft':
				keysPressed.left = true;
				break;
			case 'ArrowRight':
				keysPressed.right = true;
				break;
			case 'ArrowUp':
				keysPressed.up = true;
				break;
			case 'ArrowDown':
				keysPressed.down = true;
				break;
			case ' ':
				keysPressed.space = true;
				break;
			case 'c':
			case 'C':
				keysPressed.c = true;
				break;
			case 'Enter':
				if (gameState === GAME_STATE.MENU || gameState === GAME_STATE.GAME_OVER) {
					startGame();
				}
				break;
		}
	}

	/**
	 * Handle key up events
	 */
	function handleKeyUp(e) {
		switch(e.key) {
			case 'ArrowLeft':
				keysPressed.left = false;
				break;
			case 'ArrowRight':
				keysPressed.right = false;
				break;
			case 'ArrowUp':
				keysPressed.up = false;
				break;
			case 'ArrowDown':
				keysPressed.down = false;
				break;
			case ' ':
				keysPressed.space = false;
				break;
			case 'c':
			case 'C':
				keysPressed.c = false;
				break;
		}
	}

	/**
	 * Creates a particle effect at the specified position
	 */
	function createParticleEffect(x, y, count, color, speed) {
		for (let i = 0; i < count; i++) {
			particles.push({
				x: x,
				y: y,
				vx: (Math.random() - 0.5) * speed * 2,
				vy: (Math.random() - 0.5) * speed * 2,
				size: 2 + Math.random() * 3,
				color: color,
				life: 30 + Math.random() * 30
			});
		}
	}

	/**
	 * Start a new game
	 */
	function startGame() {
		// Reset game stats
		gameStats = {
			score: 0,
			level: 1,
			lives: config.platformer.lives,
			coins: 0
		};

		// Initialize Tetris grid
		initTetrisMode();
	}

	// Tetris timer ID
	let tetrisTimerId = null;
	// Tetris last drop time
	let lastDropTime = 0;
	// Drop interval
	const dropInterval = 1000; // 1 second

	/**
	 * Initialize Tetris mode with a clear explanation of level design
	 */
	function initTetrisMode() {
		gameState = GAME_STATE.TETRIS;

		// Create empty grid
		tetrisGrid = Array(config.tetris.gridHeight).fill().map(() => Array(config.tetris.gridWidth).fill(0));

		// Reset time
		timeLeft = config.tetris.buildTime;

		// Generate pieces
		nextPiece = generateRandomPiece();
		getNewPiece();

		// Start timer
		if (tetrisTimerId) clearInterval(tetrisTimerId);
		tetrisTimerId = setInterval(updateTetrisTimer, 1000);

		// Show level design instructions
		showLevelDesignInstructions();
	}

	/**
	 * Show level design instructions
	 */
	function showLevelDesignInstructions() {
		const instructionTime = 5000; // Show for 5 seconds

		// Create an overlay
		const overlay = document.createElement('div');
		overlay.style.position = 'absolute';
		overlay.style.top = '20%';
		overlay.style.left = '10%';
		overlay.style.width = '80%';
		overlay.style.padding = '20px';
		overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
		overlay.style.color = 'white';
		overlay.style.borderRadius = '10px';
		overlay.style.zIndex = '100';

		overlay.innerHTML = `
        <h2>Gestalte dein Level!</h2>
        <p>Platziere Tetris-Blöcke, um das Terrain für dein Plattform-Level zu erschaffen.</p>
        <ul>
            <li>Blöcke bilden die Plattformen und das Terrain</li>
            <li>Verschiedene Farben erzeugen unterschiedliche Terraintypen</li>
            <li>Baue interessante Strukturen für ein herausforderndes Level</li>
            <li>Keine Reihen werden gelöscht - dein Design bleibt erhalten!</li>
        </ul>
        <p>Du hast ${config.tetris.buildTime} Sekunden zum Bauen!</p>
    `;

		document.body.appendChild(overlay);

		// Remove after a delay
		setTimeout(() => {
			overlay.style.transition = 'opacity 1s';
			overlay.style.opacity = '0';
			setTimeout(() => {
				document.body.removeChild(overlay);
			}, 1000);
		}, instructionTime);
	}

	/**
	 * Update timer for Tetris mode
	 */
	function updateTetrisTimer() {
		timeLeft--;

		if (timeLeft <= 0) {
			clearInterval(tetrisTimerId);
			initPlatformerMode();
		}
	}

	/**
	 * Generate a random Tetris piece
	 */
	function generateRandomPiece() {
		const pieceType = Math.floor(Math.random() * config.tetris.shapes.length);
		const color = config.tetris.colors[pieceType];
		const shape = JSON.parse(JSON.stringify(config.tetris.shapes[pieceType]));

		return {
			shape: shape,
			color: color,
			type: pieceType,
			x: Math.floor(config.tetris.gridWidth / 2) - Math.floor(shape[0].length / 2),
			y: 0
		};
	}

	/**
	 * Get a new piece from the queue
	 */
	function getNewPiece() {
		currentPiece = nextPiece;
		nextPiece = generateRandomPiece();

		// Check Game Over
		if (checkCollision(currentPiece)) {
			clearInterval(tetrisTimerId);
			initPlatformerMode();
		}
	}

	/**
	 * Check if the piece collides with walls or other blocks
	 */
	function checkCollision(piece) {
		for (let y = 0; y < piece.shape.length; y++) {
			for (let x = 0; x < piece.shape[y].length; x++) {
				if (piece.shape[y][x]) {
					const posX = piece.x + x;
					const posY = piece.y + y;

					// Check boundaries
					if (posX < 0 || posX >= config.tetris.gridWidth || posY >= config.tetris.gridHeight) {
						return true;
					}

					// Check collision with placed blocks
					if (posY >= 0 && tetrisGrid[posY][posX]) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Move the current piece left
	 */
	function moveLeft() {
		if (!currentPiece) return;

		currentPiece.x--;
		if (checkCollision(currentPiece)) {
			currentPiece.x++;
		}
	}

	/**
	 * Move the current piece right
	 */
	function moveRight() {
		if (!currentPiece) return;

		currentPiece.x++;
		if (checkCollision(currentPiece)) {
			currentPiece.x--;
		}
	}

	/**
	 * Move the current piece down
	 */
	function moveDown() {
		if (!currentPiece) return false;

		currentPiece.y++;
		if (checkCollision(currentPiece)) {
			currentPiece.y--;
			lockPiece();
			return true;
		}

		return false;
	}

	/**
	 * Rotate the current piece
	 */
	function rotatePiece() {
		if (!currentPiece) return;

		// Create a copy of the current piece
		const rotatedPiece = {
			shape: [],
			color: currentPiece.color,
			type: currentPiece.type,
			x: currentPiece.x,
			y: currentPiece.y
		};

		// Get dimensions
		const n = currentPiece.shape.length;

		// Create a new empty shape matrix
		for (let i = 0; i < n; i++) {
			rotatedPiece.shape[i] = Array(n).fill(0);
		}

		// Perform rotation (90 degrees clockwise)
		for (let y = 0; y < n; y++) {
			for (let x = 0; x < n; x++) {
				rotatedPiece.shape[x][n - 1 - y] = currentPiece.shape[y][x];
			}
		}

		// Check if the rotation is valid
		if (!checkCollision(rotatedPiece)) {
			currentPiece = rotatedPiece;
		} else {
			// Try wall kicks
			const kicks = [
				{x: 1, y: 0},  // right
				{x: -1, y: 0}, // left
				{x: 0, y: -1}, // up
				{x: 2, y: 0},  // 2 right
				{x: -2, y: 0}, // 2 left
			];

			for (const kick of kicks) {
				const kickedPiece = {...rotatedPiece, x: rotatedPiece.x + kick.x, y: rotatedPiece.y + kick.y};
				if (!checkCollision(kickedPiece)) {
					currentPiece = kickedPiece;
					return;
				}
			}
		}
	}

	/**
	 * Drop the piece all the way down
	 */
	function hardDrop() {
		if (!currentPiece) return;

		while (!moveDown()) {
			// Keep moving down until collision
		}
	}

	/**
	 * Hold the current piece
	 */
	function holdPiece() {
		if (!canHold || !currentPiece) return;

		if (heldPiece === null) {
			// No piece was held before
			heldPiece = {
				shape: JSON.parse(JSON.stringify(currentPiece.shape)),
				color: currentPiece.color,
				type: currentPiece.type,
				x: 0,
				y: 0
			};
			getNewPiece();
		} else {
			// Swap with held piece
			const temp = currentPiece;
			currentPiece = {
				shape: heldPiece.shape,
				color: heldPiece.color,
				type: heldPiece.type,
				x: Math.floor(config.tetris.gridWidth / 2) - Math.floor(heldPiece.shape[0].length / 2),
				y: 0
			};
			heldPiece = {
				shape: temp.shape,
				color: temp.color,
				type: temp.type,
				x: 0,
				y: 0
			};
		}

		canHold = false;
	}

	/**
	 * Lock the current piece in place
	 */
	function lockPiece() {
		// Update grid with locked piece
		for (let y = 0; y < currentPiece.shape.length; y++) {
			for (let x = 0; x < currentPiece.shape[y].length; x++) {
				if (currentPiece.shape[y][x]) {
					const posY = currentPiece.y + y;
					const posX = currentPiece.x + x;

					if (posY >= 0 && posY < config.tetris.gridHeight && posX >= 0 && posX < config.tetris.gridWidth) {
						tetrisGrid[posY][posX] = {
							color: currentPiece.color,
							type: currentPiece.type + 1
						};
					}
				}
			}
		}

		// Check for completed rows
		checkRows();

		// Reset held piece availability
		canHold = true;

		// Get next piece
		getNewPiece();
	}

    /*/!**
	 * Check for completed rows and clear them
	 *!/
	function checkRows() {
		const completedRows = [];

		// Find all completed rows
		for (let y = 0; y < config.tetris.gridHeight; y++) {
			let complete = true;
			for (let x = 0; x < config.tetris.gridWidth; x++) {
				if (!tetrisGrid[y][x]) {
					complete = false;
					break;
				}
			}

			if (complete) {
				completedRows.push(y);
			}
		}

		if (completedRows.length > 0) {
			// Add points based on number of rows cleared
			const points = [100, 300, 500, 800]; // 1, 2, 3, 4 rows
			gameStats.score += points[Math.min(completedRows.length - 1, 3)];

			// Clear rows and shift down
			for (const row of completedRows) {
				// Shift rows down
				for (let y = row; y > 0; y--) {
					for (let x = 0; x < config.tetris.gridWidth; x++) {
						tetrisGrid[y][x] = tetrisGrid[y-1][x];
					}
				}

				// Clear top row
				for (let x = 0; x < config.tetris.gridWidth; x++) {
					tetrisGrid[0][x] = 0;
				}
			}
		}
	}*/

	/**
	 * Check for completed rows but don't clear them
	 */
	function checkRows() {
		const completedRows = [];

		// Find all completed rows
		for (let y = 0; y < config.tetris.gridHeight; y++) {
			let complete = true;
			for (let x = 0; x < config.tetris.gridWidth; x++) {
				if (!tetrisGrid[y][x]) {
					complete = false;
					break;
				}
			}

			if (complete) {
				completedRows.push(y);
			}
		}

		if (completedRows.length > 0) {
			// Add points based on number of rows completed, but don't clear rows
			const points = [100, 300, 500, 800]; // 1, 2, 3, 4 rows
			gameStats.score += points[Math.min(completedRows.length - 1, 3)];

			// Wir löschen keine Reihen mehr, um die Level-Struktur zu erhalten
		}
	}

	/**
	 * Update Tetris game state
	 */
	function updateTetris(currentTime) {
		// Process controls
		const now = Date.now();

		// Move left
		if (keysPressed.left) {
			moveLeft();
			// Small delay to prevent too rapid movement
			keysPressed.left = false;
			setTimeout(() => { if (keysPressed.left) moveLeft(); }, 100);
		}

		// Move right
		if (keysPressed.right) {
			moveRight();
			// Small delay to prevent too rapid movement
			keysPressed.right = false;
			setTimeout(() => { if (keysPressed.right) moveRight(); }, 100);
		}

		// Rotate
		if (keysPressed.up) {
			rotatePiece();
			keysPressed.up = false; // Only rotate once per press
		}

		// Move down quickly
		if (keysPressed.down) {
			moveDown();
		}

		// Hard drop
		if (keysPressed.space) {
			hardDrop();
			keysPressed.space = false; // Only drop once per press
		}

		// Hold piece
		if (keysPressed.c) {
			holdPiece();
			keysPressed.c = false; // Only hold once per press
		}

		// Auto drop based on time
		if (currentTime - lastDropTime > dropInterval) {
			moveDown();
			lastDropTime = currentTime;
		}
	}

	/**
	 * Draw the Tetris game state
	 */
	function drawTetris() {
		// Clear canvas
		ctx.fillStyle = config.game.backgroundColor;
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// Calculate board position
		const boardX = (canvas.width - (config.tetris.gridWidth * config.tetris.blockSize)) / 2;
		const boardY = (canvas.height - (config.tetris.gridHeight * config.tetris.blockSize)) / 2;

		// Draw board background
		ctx.fillStyle = '#000000';
		ctx.fillRect(boardX, boardY,
			config.tetris.gridWidth * config.tetris.blockSize,
			config.tetris.gridHeight * config.tetris.blockSize);

		// Draw grid lines
		ctx.strokeStyle = '#333333';
		ctx.lineWidth = 1;

		// Draw vertical lines
		for (let x = 0; x <= config.tetris.gridWidth; x++) {
			ctx.beginPath();
			ctx.moveTo(boardX + x * config.tetris.blockSize, boardY);
			ctx.lineTo(boardX + x * config.tetris.blockSize, boardY + config.tetris.gridHeight * config.tetris.blockSize);
			ctx.stroke();
		}

		// Draw horizontal lines
		for (let y = 0; y <= config.tetris.gridHeight; y++) {
			ctx.beginPath();
			ctx.moveTo(boardX, boardY + y * config.tetris.blockSize);
			ctx.lineTo(boardX + config.tetris.gridWidth * config.tetris.blockSize, boardY + y * config.tetris.blockSize);
			ctx.stroke();
		}

		// Draw placed blocks
		for (let y = 0; y < config.tetris.gridHeight; y++) {
			for (let x = 0; x < config.tetris.gridWidth; x++) {
				if (tetrisGrid[y][x]) {
					drawBlock(
						boardX + x * config.tetris.blockSize,
						boardY + y * config.tetris.blockSize,
						config.tetris.blockSize,
						tetrisGrid[y][x].color
					);
				}
			}
		}

		// Draw current piece
		if (currentPiece) {
			for (let y = 0; y < currentPiece.shape.length; y++) {
				for (let x = 0; x < currentPiece.shape[y].length; x++) {
					if (currentPiece.shape[y][x]) {
						drawBlock(
							boardX + (currentPiece.x + x) * config.tetris.blockSize,
							boardY + (currentPiece.y + y) * config.tetris.blockSize,
							config.tetris.blockSize,
							currentPiece.color
						);
					}
				}
			}
		}

		// Draw next piece preview
		if (nextPiece) {
			const nextX = canvas.width - 150;
			const nextY = 150;

			// Next piece label
			ctx.fillStyle = '#ffffff';
			ctx.font = '18px Arial';
			ctx.fillText('NEXT', nextX - 20, nextY - 30);

			// Next piece box
			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 2;
			ctx.strokeRect(nextX - 40, nextY - 20, 80, 80);

			// Draw the next piece
			const blockSize = 15;
			for (let y = 0; y < nextPiece.shape.length; y++) {
				for (let x = 0; x < nextPiece.shape[y].length; x++) {
					if (nextPiece.shape[y][x]) {
						drawBlock(
							nextX - 30 + x * blockSize,
							nextY - 10 + y * blockSize,
							blockSize,
							nextPiece.color
						);
					}
				}
			}
		}

		// Draw held piece
		if (heldPiece) {
			const heldX = 150;
			const heldY = 150;

			// Held piece label
			ctx.fillStyle = '#ffffff';
			ctx.font = '18px Arial';
			ctx.fillText('HOLD', heldX - 20, heldY - 30);

			// Held piece box
			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 2;
			ctx.strokeRect(heldX - 40, heldY - 20, 80, 80);

			// Draw the held piece
			const blockSize = 15;
			for (let y = 0; y < heldPiece.shape.length; y++) {
				for (let x = 0; x < heldPiece.shape[y].length; x++) {
					if (heldPiece.shape[y][x]) {
						drawBlock(
							heldX - 30 + x * blockSize,
							heldY - 10 + y * blockSize,
							blockSize,
							heldPiece.color
						);
					}
				}
			}
		}

		// Draw UI
		drawTetrisUI();
	}

	/**
	 * Draw the Tetris UI with clearer level design explanation
	 */
	function drawTetrisUI() {
		// Draw header
		ctx.fillStyle = '#ffffff';
		ctx.font = '20px Arial';
		ctx.textAlign = 'center';
		ctx.fillText('PHASE 1: BAUE DEIN LEVEL', canvas.width / 2, 30);

		// Draw timer
		ctx.font = '18px Arial';
		ctx.fillText(`Zeit: ${timeLeft}s`, canvas.width / 2, 60);

		// Draw level and score
		ctx.textAlign = 'center';
		ctx.fillText(`Level: ${gameStats.level}   Punkte: ${gameStats.score}   Leben: ${gameStats.lives}`,
			canvas.width / 2, canvas.height - 30);

		// Draw design explanation
		ctx.textAlign = 'center';
		ctx.font = '16px Arial';
		ctx.fillStyle = '#FFFF00';
		ctx.fillText('Dein Tetris-Design wird zu deinem Plattform-Level!', canvas.width / 2, 90);
		ctx.fillText('Baue interessante Terrain-Strukturen.', canvas.width / 2, 110);

		// Draw controls info
		ctx.textAlign = 'left';
		ctx.font = '14px Arial';
		ctx.fillStyle = '#cccccc';
		ctx.fillText('Pfeile: Bewegen', 20, canvas.height - 60);
		ctx.fillText('Hoch: Rotieren', 20, canvas.height - 40);
		ctx.fillText('Leertaste: Fallen lassen', 20, canvas.height - 20);

		ctx.textAlign = 'right';
		ctx.fillText('C: Block halten', canvas.width - 20, canvas.height - 40);
		ctx.fillText('Runter: Schneller fallen', canvas.width - 20, canvas.height - 20);
	}

	/**
	 * Draw a Tetris block at the specified position
	 */
	function drawBlock(x, y, size, color) {
		// Draw block background
		ctx.fillStyle = color;
		ctx.fillRect(x, y, size, size);

		// Draw highlight
		ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + size, y);
		ctx.lineTo(x, y + size);
		ctx.fill();

		// Draw shadow
		ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
		ctx.beginPath();
		ctx.moveTo(x + size, y);
		ctx.lineTo(x + size, y + size);
		ctx.lineTo(x, y + size);
		ctx.fill();

		// Draw outline
		ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
		ctx.lineWidth = 1;
		ctx.strokeRect(x, y, size, size);
	}

	/**
	 * Draw water without random elements
	 */
	function drawWater(water, offsetX, offsetY) {
		// Use the water's offset property for consistent waves
		const time = Date.now() * 0.002;
		const gradient = ctx.createLinearGradient(
			water.x + offsetX, water.y + offsetY,
			water.x + offsetX, water.y + offsetY + water.height
		);

		gradient.addColorStop(0, 'rgba(68, 68, 255, 0.7)');
		gradient.addColorStop(1, 'rgba(0, 0, 128, 0.7)');
		ctx.fillStyle = gradient;

		// Draw water with wavy top based on position and time
		ctx.beginPath();
		ctx.moveTo(water.x + offsetX, water.y + offsetY + Math.sin(time + water.offset) * 3);

		for (let i = 0; i <= water.width; i += 5) {
			ctx.lineTo(
				water.x + offsetX + i,
				water.y + offsetY + Math.sin(time + water.offset + i * 0.05) * 3
			);
		}

		ctx.lineTo(water.x + offsetX + water.width, water.y + offsetY + water.height);
		ctx.lineTo(water.x + offsetX, water.y + offsetY + water.height);
		ctx.closePath();
		ctx.fill();

		// Add reflection highlights based on position
		ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
		for (let i = 0; i < 3; i++) {
			const xOffset = ((water.x + i * 50) % water.width);
			const size = 2 + ((water.x + i * 7) % 6);
			const x = water.x + offsetX + xOffset;
			const y = water.y + offsetY + (water.height * ((water.x + i * 13) % 10) / 20);
			ctx.beginPath();
			ctx.arc(x, y, size, 0, Math.PI * 2);
			ctx.fill();
		}
	}

	/**
	 * Initialize platformer mode
	 */
	function initPlatformerMode() {
		gameState = GAME_STATE.PLATFORMER;

		// Generate level from Tetris grid
		generateLevel();

		// Place player at starting position
		player.x = 100;
		player.y = 100;
		player.velocityX = 0;
		player.velocityY = 0;
		player.isJumping = false;
		player.onGround = false;
		player.invulnerable = 120; // 2 seconds of invulnerability on start

		// Reset camera
		camera.x = 0;
		camera.y = 0;
	}

	/**
	 * Create level map by transforming the Tetris grid into a playable level
	 * Die Tetris-Blöcke werden um 90 Grad gedreht und als Basis für das Level verwendet
	 */
	function createLevelMap() {
		const tetrisHeight = tetrisGrid.length;
		const tetrisWidth = tetrisGrid[0].length;

		// Rotate and concatenate the Tetris grid to create a longer level
		const repetitions = 3; // Number of times to repeat the grid
		const levelWidth = tetrisHeight * repetitions;
		const levelHeight = tetrisWidth + 5; // Add some space above and below

		// Initialize level map with empty cells
		const levelMap = Array(levelHeight).fill().map(() => Array(levelWidth).fill(0));

		// Add a solid ground layer at the bottom for safety
		for (let x = 0; x < levelWidth; x++) {
			levelMap[levelHeight - 1][x] = {
				color: '#8B4513', // Brown earth color
				type: 1,
				isGround: true
			};
		}

		// Transform Tetris grid into level map - rotated 90 degrees
		for (let rep = 0; rep < repetitions; rep++) {
			for (let tx = 0; tx < tetrisWidth; tx++) {
				for (let ty = 0; ty < tetrisHeight; ty++) {
					// Calculate world coordinates - here we rotate the grid
					// tetris (tx, ty) -> level (levelY, levelX)
					const levelX = rep * tetrisHeight + ty;
					const levelY = levelHeight - 2 - tx; // Place blocks above ground

					// Make sure we stay in bounds
					if (levelX < 0 || levelX >= levelWidth || levelY < 0 || levelY >= levelHeight) {
						continue;
					}

					// If there's a block in the Tetris grid, place a platform
					if (tetrisGrid[ty][tx]) {
						let blockType = typeof tetrisGrid[ty][tx] === 'object' ? tetrisGrid[ty][tx].type : 1;
						let blockColor = typeof tetrisGrid[ty][tx] === 'object' ? tetrisGrid[ty][tx].color : '#777777';

						// Create platform based on block type
						levelMap[levelY][levelX] = {
							color: blockColor,
							type: blockType,
							isPlatform: true
						};

						// Add support blocks beneath platforms when needed
						for (let sy = levelY + 1; sy < levelHeight - 1; sy++) {
							if (!levelMap[sy][levelX]) {
								levelMap[sy][levelX] = {
									color: blockColor,
									type: blockType,
									isSupport: true
								};
							} else {
								break; // Stop when we hit another block
							}
						}
					}
				}
			}
		}

		// Add features to the level based on position, not randomly
		addDeterministicFeatures(levelMap, levelWidth, levelHeight);

		return levelMap;
	}

	/**
	 * Add deterministic features to the level based on position
	 */
	function addDeterministicFeatures(levelMap, levelWidth, levelHeight) {
		// Add coins along platforms in a deterministic pattern
		for (let x = 0; x < levelWidth; x += 3) {
			for (let y = 1; y < levelHeight - 2; y++) {
				// Place coins above platforms
				if (levelMap[y+1] && levelMap[y+1][x] && !levelMap[y][x]) {
					levelMap[y][x] = {
						color: '#FFD700',  // Gold
						type: 9,
						isCoin: true
					};
					break;
				}
			}
		}

		// Add decorative elements based on block position
		for (let x = 0; x < levelWidth; x++) {
			for (let y = 0; y < levelHeight - 1; y++) {
				if (levelMap[y+1] && levelMap[y+1][x] && !levelMap[y][x]) {
					// We have a platform with empty space above
					// Use a hash function of the coordinates for deterministic variation
					const variation = ((x * 13) + (y * 7)) % 5;

					if (variation === 0) {
						// Add decoration on top of some platforms
						levelMap[y][x] = {
							color: getDecorColor(x, y),
							type: getDecorType(x, y),
							isDecoration: true
						};
					}
				}
			}
		}

		// Add water only at the bottom of gaps, not floating in air
		addWaterFeatures(levelMap, levelWidth, levelHeight);

		// Place hazards and special items deterministically
		for (let x = 5; x < levelWidth - 5; x += 7) {
			for (let y = 1; y < levelHeight - 2; y++) {
				// Check if there's a platform with empty space above
				if (levelMap[y+1] && levelMap[y+1][x] && !levelMap[y][x]) {
					const variation = ((x * 17) + (y * 11)) % 10;

					if (variation < 2) {
						// Add a hazard
						levelMap[y][x] = {
							color: '#777777',
							type: 11,
							isHazard: true,
							hazardType: variation === 0 ? 'spikes' : 'lava'
						};
					} else if (variation === 9) {
						// Add a treasure
						levelMap[y][x] = {
							color: '#FFD700',
							type: 10,
							isTreasure: true,
							special: x > levelWidth / 2
						};
					}
					break;
				}
			}
		}
	}

	/**
	 * Get a decoration color based on position
	 */
	function getDecorColor(x, y) {
		// Deterministic color based on position
		const colors = [
			'#5D9C59',  // Green
			'#A39171',  // Tan
			'#8294C4',  // Blue
			'#E88A1A'   // Orange
		];
		return colors[(x + y * 3) % colors.length];
	}

	/**
	 * Get a decoration type based on position
	 */
	function getDecorType(x, y) {
		// Return 0, 1, or 2 based on position
		return ((x * 7) + (y * 13)) % 3;
	}

	/**
	 * Add water features to the level - only at the bottom, never floating
	 */
	function addWaterFeatures(levelMap, levelWidth, levelHeight) {
		// Only add water at the bottom of levels in appropriate gaps
		for (let x = 0; x < levelWidth; x++) {
			let foundGround = false;
			let waterHeight = 0;

			// Look from bottom up to find gaps for water
			for (let y = levelHeight - 2; y > levelHeight / 2 && !foundGround; y--) {
				if (levelMap[y][x]) {
					foundGround = true;
				} else if (y === levelHeight - 2) {
					// This is a gap that goes all the way to the bottom
					// We'll fill it with water up to a certain height
					waterHeight = Math.min(3, (x * 7 + 11) % 4); // Deterministic height

					for (let wy = levelHeight - 2; wy > levelHeight - 2 - waterHeight; wy--) {
						if (!levelMap[wy][x]) {
							levelMap[wy][x] = {
								color: '#4444FF',
								type: 12,
								isWater: true,
								// Use position for deterministic wave offset
								offset: (x / 10) % (Math.PI * 2)
							};
						}
					}
				}
			}
		}
	}

	/**
	 * Get a color for a level section
	 */
	function getColorForSection(section, isVariation = false) {
		// Different color schemes for different sections
		const colorSchemes = [
			['#5D9C59', '#5D9C59', '#538353'], // Green forest
			['#A39171', '#A39171', '#8B7E63'], // Desert sand
			['#8294C4', '#8294C4', '#7786B9'], // Blue mountains
			['#E88A1A', '#E88A1A', '#D57F18']  // Volcanic area
		];

		const scheme = colorSchemes[section % colorSchemes.length];
		return isVariation ? scheme[Math.floor(Math.random() * scheme.length)] : scheme[0];
	}

	/**
	 * Get a transition color between sections
	 */
	function getTransitionColor(fromSection, toSection, isVariation = false) {
		const fromColor = getColorForSection(fromSection);
		const toColor = getColorForSection(toSection % 4);

		// Simple blend of colors
		return isVariation ? (Math.random() < 0.5 ? fromColor : toColor) : blendColors(fromColor, toColor, 0.5);
	}

	/**
	 * Blend two hex colors
	 */
	function blendColors(color1, color2, ratio) {
		// Convert hex to RGB
		const r1 = parseInt(color1.substring(1, 3), 16);
		const g1 = parseInt(color1.substring(3, 5), 16);
		const b1 = parseInt(color1.substring(5, 7), 16);

		const r2 = parseInt(color2.substring(1, 3), 16);
		const g2 = parseInt(color2.substring(3, 5), 16);
		const b2 = parseInt(color2.substring(5, 7), 16);

		// Blend colors
		const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
		const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
		const b = Math.round(b1 * (1 - ratio) + b2 * ratio);

		// Convert back to hex
		return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	}

	/**
	 * Add decorative elements based on tetris patterns
	 */
	function addDecorativeElements(levelMap, x, y, section, levelWidth, levelHeight) {
		// Add platforms below to create interesting structures
		for (let i = 1; i <= 3; i++) {
			if (y + i < levelHeight - 1 && Math.random() < 0.3 / i) {
				levelMap[y + i][x] = {
					color: getColorForSection(section, true),
					type: 1 + (section % 7),
					isSupport: true
				};
			}
		}

		// Sometimes add decorative elements
		if (Math.random() < 0.2 && y > 1) {
			// Add a decoration above platform (like a bush, tree, or crystal)
			levelMap[y - 1][x] = {
				color: getDecorationColor(section),
				type: 10 + Math.floor(Math.random() * 3),
				isDecoration: true
			};
		}
	}

	/**
	 * Get a decoration color based on section
	 */
	function getDecorationColor(section) {
		const decorationColors = [
			'#FF5733', // Red flower/mushroom
			'#DAF7A6', // Light green bush
			'#FFC300', // Yellow crystal/flower
			'#C70039'  // Dark red mushroom/crystal
		];

		return decorationColors[Math.floor(Math.random() * decorationColors.length)];
	}

	/**
	 * Add floating islands with treasures
	 */
	function addFloatingIslands(levelMap, width, height, count) {
		for (let i = 0; i < count; i++) {
			// Create a floating island at a random position
			const islandX = 15 + Math.floor(Math.random() * (width - 30));
			const islandY = 2 + Math.floor(Math.random() * (height / 2));
			const islandSize = 2 + Math.floor(Math.random() * 3);

			// Only create if within bounds
			if (islandY >= 0 && islandY < height && islandX >= 0 && islandX + islandSize < width) {
				// Create the island platform
				for (let x = 0; x < islandSize; x++) {
					levelMap[islandY][islandX + x] = {
						color: '#DDDDDD', // Light gray floating island
						type: 8,
						isFloatingIsland: true
					};
				}

				// Add a treasure or special item on the island
				if (Math.random() < 0.7 && islandY - 1 >= 0) {
					levelMap[islandY - 1][islandX + Math.floor(islandSize / 2)] = {
						color: '#FFD700', // Gold
						type: 9,
						isTreasure: true
					};
				}
			}
		}
	}

	/**
	 * Add secret underground areas with bonus items
	 */
	function addSecretAreas(levelMap, width, height) {
		const secretCount = 3 + Math.floor(Math.random() * 3);

		for (let i = 0; i < secretCount; i++) {
			// Choose a section of the map for a secret
			const secretX = 15 + Math.floor(Math.random() * (width - 30));
			const secretBaseY = height - 2;

			// Validate bounds before creating the secret
			if (secretX < 1 || secretX >= width - 2 || secretBaseY < 2 || secretBaseY >= height) {
				continue;
			}

			// Create a vertical shaft downward
			const shaftDepth = 3 + Math.floor(Math.random() * 3);
			// Make sure the shaft doesn't go out of bounds
			const actualShaftDepth = Math.min(shaftDepth, secretBaseY);

			for (let y = 0; y < actualShaftDepth; y++) {
				// Keep the sides solid
				levelMap[secretBaseY - y][secretX - 1] = {
					color: '#8B4513', // Dark brown
					type: 1,
					isWall: true
				};

				// Create a hollow shaft
				levelMap[secretBaseY - y][secretX] = 0;

				// Keep the sides solid
				levelMap[secretBaseY - y][secretX + 1] = {
					color: '#8B4513', // Dark brown
					type: 1,
					isWall: true
				};
			}

			// Create a small secret room at the bottom
			const roomWidth = 3 + Math.floor(Math.random() * 3);

			// Check that the room fits within bounds
			if (secretX + roomWidth >= width) {
				continue;
			}

			for (let x = 0; x < roomWidth; x++) {
				if (secretBaseY + 1 < height) {
					levelMap[secretBaseY + 1][secretX + x] = {
						color: '#8B4513', // Dark brown floor
						type: 1,
						isSecretFloor: true
					};
				}

				// Add ceiling to the secret room
				if (secretBaseY - actualShaftDepth >= 0) {
					levelMap[secretBaseY - actualShaftDepth][secretX + x] = {
						color: '#8B4513', // Dark brown ceiling
						type: 1,
						isSecretCeiling: true
					};
				}
			}

			// Add a special treasure in the secret room
			if (secretBaseY >= 0 && secretBaseY < height &&
				secretX + Math.floor(roomWidth / 2) >= 0 &&
				secretX + Math.floor(roomWidth / 2) < width) {

				levelMap[secretBaseY][secretX + Math.floor(roomWidth / 2)] = {
					color: '#FFD700', // Gold
					type: 9,
					isSpecialTreasure: true
				};
			}
		}
	}

	/**
	 * Generate platformer level from Tetris grid
	 */
	function generateLevel() {
		const blockSize = config.platformer.playerSize * 1.5;

		// Create level map by rotating and expanding the Tetris grid
		const levelMap = createLevelMap();

		// Clear game objects
		platforms = [];
		coins = [];
		waters = [];
		elevators = [];
		enemies = [];
		hazards = [];
		decorations = [];
		treasures = [];

		// Calculate level dimensions
		const levelWidth = levelMap[0].length * blockSize;
		const levelHeight = levelMap.length * blockSize;

		// Create parallax background layers
		createBackgroundLayers(levelWidth, levelHeight);

		// Process level map to create game objects
		for (let y = 0; y < levelMap.length; y++) {
			for (let x = 0; x < levelMap[0].length; x++) {
				const cell = levelMap[y][x];
				const worldX = x * blockSize;
				const worldY = y * blockSize;

				if (cell) {
					// Determine theme based on x position (section of the level)
					const themes = [
						{ name: 'forest', mainColor: '#5D9C59', decorColor: '#3F6C58', blockType: 1 },
						{ name: 'desert', mainColor: '#A39171', decorColor: '#8A7B5E', blockType: 2 },
						{ name: 'mountain', mainColor: '#8294C4', decorColor: '#6B7CA8', blockType: 3 },
						{ name: 'volcano', mainColor: '#E88A1A', decorColor: '#C97516', blockType: 4 }
					];
					const themeIndex = Math.min(Math.floor(x / (levelMap[0].length / themes.length)), themes.length - 1);
					const theme = themes[themeIndex];

					if (cell.isWater) {
						waters.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize,
							offset: cell.offset || 0,
							depth: 0.7
						});
					}
					else if (cell.isCoin) {
						coins.push({
							x: worldX + blockSize/2,
							y: worldY + blockSize/2,
							width: blockSize/2,
							height: blockSize/2,
							collected: false,
							wobble: (x * 13 + y * 7) % 628 / 100 // Deterministic wobble phase
						});
					}
					else if (cell.isTreasure) {
						treasures.push({
							x: worldX + blockSize/4,
							y: worldY + blockSize/4,
							width: blockSize/2,
							height: blockSize/2,
							color: '#FFD700',
							value: cell.special ? 500 : 200,
							rotation: 0,
							collected: false,
							special: cell.special
						});
					}
					else if (cell.isDecoration) {
						decorations.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize,
							color: cell.color,
							type: cell.type
						});
					}
					else if (cell.isHazard) {
						hazards.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize/2,
							type: cell.hazardType || 'spikes',
							damage: 1,
							color: cell.hazardType === 'lava' ? '#FF3300' : '#777777'
						});
					}
					else if (cell.isGround) {
						platforms.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize,
							color: '#8B4513',
							isGround: true
						});
					}
					else if (cell.isSupport) {
						platforms.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize,
							color: cell.color,
							isSupport: true
						});
					}
					else {
						platforms.push({
							x: worldX,
							y: worldY,
							width: blockSize,
							height: blockSize,
							color: cell.color || theme.mainColor,
							theme: theme.name,
							type: cell.type || theme.blockType
						});
					}
				}
			}
		}

		// Add elevators to help with vertical traversal using a deterministic approach
		addDeterministicElevators(levelMap, blockSize);

		// Add enemies with a deterministic approach
		addDeterministicEnemies(levelMap, blockSize);

		// Place goal at a logical endpoint with a clear visual indicator
		placeGoalFlag(levelMap, blockSize);

		// Set initial player position at a safe starting area
		setPlayerStartPosition(levelMap, blockSize);

		// Set initial camera position
		camera.x = 0;
		camera.y = 0;

		// Level dimensions
		level = {
			width: levelWidth,
			height: levelHeight
		};
	}

	/**
	 * Create background layers without random elements
	 */
	function createBackgroundLayers(levelWidth, levelHeight) {
		backgroundLayers = [];

		// Far background - sky gradients
		backgroundLayers.push({
			speed: 0.0,
			type: 'sky',
			colorTop: '#87CEEB',    // Light blue
			colorBottom: '#E0F7FF'  // Very light blue
		});

		// Distant mountains - deterministic positions
		const mountainCounts = [8, 10, 15]; // Number of mountains in each layer
		const mountainSizes = [
			{ width: 600, height: 200 },
			{ width: 400, height: 150 },
			{ width: 300, height: 100 }
		];
		const mountainColors = ['#8794A1', '#6D7A8C', '#5A6877'];
		const mountainSpeeds = [0.05, 0.1, 0.2];

		// Create three mountain layers
		for (let layer = 0; layer < 3; layer++) {
			let mountains = [];

			for (let m = 0; m < mountainCounts[layer]; m++) {
				const xPosition = (levelWidth / mountainCounts[layer]) * m;
				const widthVariation = ((xPosition * 17) % 100) - 50;
				const heightVariation = ((xPosition * 13) % 50) - 25;

				mountains.push({
					x: xPosition,
					width: mountainSizes[layer].width + widthVariation,
					height: mountainSizes[layer].height + heightVariation,
					color: mountainColors[layer]
				});
			}

			backgroundLayers.push({
				speed: mountainSpeeds[layer],
				type: 'mountains',
				mountains: mountains
			});
		}

		// Add a forest silhouette layer
		const trees = [];
		for (let t = 0; t < 50; t++) {
			const xPosition = (levelWidth / 50) * t;
			trees.push({
				x: xPosition,
				height: 30 + ((xPosition * 7) % 50),
				width: 20 + ((xPosition * 11) % 30),
				type: Math.floor((xPosition * 13) % 3)  // Different tree shapes
			});
		}

		backgroundLayers.push({
			speed: 0.3,
			type: 'trees',
			trees: trees
		});

		// Add a cloud layer
		const clouds = [];
		for (let c = 0; c < 20; c++) {
			const xPosition = (levelWidth / 20) * c;
			clouds.push({
				x: xPosition,
				y: 50 + ((xPosition * 11) % 150),
				speed: 0.1 + ((xPosition * 7) % 20) / 100,
				width: 100 + ((xPosition * 13) % 150),
				height: 40 + ((xPosition * 17) % 30)
			});
		}

		backgroundLayers.push({
			speed: 0.15,
			type: 'clouds',
			clouds: clouds
		});
	}

	/**
	 * Add elevators to help with vertical traversal - deterministic approach
	 */
	function addDeterministicElevators(levelMap, blockSize) {
		const width = levelMap[0].length;
		const height = levelMap.length;

		// Add elevators at regular intervals where there are vertical gaps
		for (let x = 10; x < width - 10; x += 15) {
			let topPlatformY = -1;
			let bottomPlatformY = -1;

			// Find gap from top down
			for (let y = 2; y < height - 2; y++) {
				if (levelMap[y][x]) {
					topPlatformY = y;
					break;
				}
			}

			// Find platform below the gap
			if (topPlatformY > 0) {
				for (let y = topPlatformY + 4; y < height - 2; y++) {
					if (levelMap[y][x]) {
						bottomPlatformY = y;
						break;
					}
				}
			}

			// If we found a suitable gap
			if (topPlatformY > 0 && bottomPlatformY > 0 && bottomPlatformY - topPlatformY > 4) {
				elevators.push({
					x: x * blockSize,
					y: (topPlatformY + 1) * blockSize,
					width: blockSize,
					height: blockSize / 3,
					startY: (topPlatformY + 1) * blockSize,
					endY: (bottomPlatformY - 1) * blockSize,
					direction: 1,
					speed: 1 + (x % 5) / 10, // Deterministic speed
					color: '#BBBBBB'
				});

				// Add visual guides for elevator path
				for (let guideY = topPlatformY + 2; guideY < bottomPlatformY; guideY += 2) {
					decorations.push({
						x: x * blockSize,
						y: guideY * blockSize,
						width: blockSize / 4,
						height: blockSize / 4,
						color: '#AAAAAA',
						type: 'elevatorGuide'
					});
				}
			}
		}
	}

	/**
	 * Add enemies with deterministic placement
	 */
	function addDeterministicEnemies(levelMap, blockSize) {
		const width = levelMap[0].length;
		const height = levelMap.length;

		// Enemy themes by section
		const enemyThemes = [
			[
				{ name: 'walker', color: '#336633', speed: 1.5, damage: 1 },
				{ name: 'jumper', color: '#669966', speed: 2, damage: 1, jumpHeight: 8 }
			],
			[
				{ name: 'walker', color: '#CC9966', speed: 1.8, damage: 1 },
				{ name: 'flyer', color: '#FFCC99', speed: 2.2, damage: 1, flyHeight: 80 }
			],
			[
				{ name: 'jumper', color: '#6699CC', speed: 1.5, damage: 1, jumpHeight: 10 },
				{ name: 'walker', color: '#336699', speed: 1.2, damage: 1 }
			],
			[
				{ name: 'walker', color: '#CC3300', speed: 2, damage: 1 },
				{ name: 'flyer', color: '#FF6633', speed: 2.5, damage: 2, flyHeight: 100 }
			]
		];

		// Place enemies at regular intervals
		for (let x = 15; x < width - 10; x += 12) {
			// Determine the section we're in
			const section = Math.min(Math.floor(x / (width / 4)), 3);

			// Find suitable platform
			for (let y = 2; y < height - 3; y++) {
				if (levelMap[y+1] && levelMap[y+1][x] && !levelMap[y][x]) {
					// Found a platform with space above

					// Find platform bounds for patrol area
					let leftBound = x;
					let rightBound = x;

					// Find left bound
					for (let tx = x - 1; tx >= Math.max(0, x - 10); tx--) {
						if (y+1 < height && levelMap[y+1][tx] && !levelMap[y][tx]) {
							leftBound = tx;
						} else {
							break;
						}
					}

					// Find right bound
					for (let tx = x + 1; tx < Math.min(width, x + 10); tx++) {
						if (y+1 < height && levelMap[y+1][tx] && !levelMap[y][tx]) {
							rightBound = tx;
						} else {
							break;
						}
					}

					// Only add if platform is wide enough
					if (rightBound - leftBound >= 3) {
						// Deterministically choose enemy type
						const enemyTypes = enemyThemes[section];
						const typeIdx = Math.floor((x * 7 + y * 13) % enemyTypes.length);
						const enemyType = enemyTypes[typeIdx];

						// Create enemy
						const enemy = {
							x: x * blockSize + blockSize / 2,
							y: y * blockSize,
							width: blockSize * 0.8,
							height: blockSize * 0.8,
							type: enemyType.name,
							color: enemyType.color,
							speed: enemyType.speed * (0.8 + (x % 5) / 10),
							damage: enemyType.damage,
							direction: ((x + y) % 2) === 0 ? -1 : 1, // Deterministic direction
							patrolStart: leftBound * blockSize,
							patrolEnd: rightBound * blockSize,
							platform: {
								x: leftBound * blockSize,
								y: y * blockSize,
								width: (rightBound - leftBound + 1) * blockSize,
								height: blockSize
							},
							state: 'patrol',
							theme: enemyThemes[section][0].name,
							animationFrame: 0
						};

						// Add special properties based on enemy type
						if (enemyType.name === 'jumper') {
							enemy.jumpHeight = enemyType.jumpHeight;
							enemy.jumpTimer = (x * 7) % 100;
						}

						if (enemyType.name === 'flyer') {
							enemy.flyHeight = enemyType.flyHeight;
							enemy.flyOffset = (x * 13) % 628 / 100; // Deterministic offset
							enemy.y -= blockSize; // Start higher
						}

						enemies.push(enemy);
						break; // Only place one enemy per x position
					}
				}
			}
		}
	}

	/**
	 * Place the goal flag at a logical endpoint
	 */
	function placeGoalFlag(levelMap, blockSize) {
		const width = levelMap[0].length;
		const height = levelMap.length;

		// Place near the end of the level
		const endRegionStart = Math.floor(width * 0.9);
		let goalX = width - 5; // Default position
		let goalY = height - 3;

		// Find a suitable platform near the end
		for (let x = width - 5; x >= endRegionStart; x--) {
			for (let y = 2; y < height - 2; y++) {
				if (y+1 < height && levelMap[y+1][x] && !levelMap[y][x]) {
					goalX = x;
					goalY = y;
					break;
				}
			}
			if (goalX !== width - 5) break; // We found a position
		}

		// Create the goal
		goal = {
			x: goalX * blockSize,
			y: goalY * blockSize - blockSize,
			width: blockSize * 1.2,
			height: blockSize * 2,
			animate: true
		};

		// Add a victory platform
		platforms.push({
			x: goalX * blockSize - blockSize,
			y: (goalY + 1) * blockSize,
			width: blockSize * 3,
			height: blockSize,
			color: '#DDDDDD',
			isVictoryPlatform: true
		});

		// Add deterministic visual effects around the goal
		const emitterOffset = (goalX * 7) % 100 / 100;
		particleEmitters.push({
			x: goalX * blockSize + blockSize/2,
			y: goalY * blockSize,
			color: '#FFFF00',
			rate: 0.1 + emitterOffset,
			size: 3,
			lifetime: 60,
			speedX: 0,
			speedY: -0.5,
			type: 'goalGlow'
		});
	}

	/**
	 * Set the player's starting position
	 */
	function setPlayerStartPosition(levelMap, blockSize) {
		const width = levelMap[0].length;
		const height = levelMap.length;

		// Use a fixed position near the start
		let startX = 3;
		let startY = 10; // Default fallback

		// Find a suitable platform in the first section of the level
		for (let x = 2; x < 10; x++) {
			for (let y = 1; y < height - 2; y++) {
				if (y+1 < height && levelMap[y+1][x] && !levelMap[y][x]) {
					startX = x;
					startY = y;

					// Found a good position, stop searching
					x = 10; // Break outer loop
					break;
				}
			}
		}

		// Set player position
		player.x = startX * blockSize;
		player.y = startY * blockSize;
		player.velocityX = 0;
		player.velocityY = 0;
		player.facing = 1;

		// Add a welcome sign near the start
		decorations.push({
			x: (startX - 1) * blockSize,
			y: startY * blockSize,
			width: blockSize,
			height: blockSize * 1.5,
			color: '#8B4513',
			type: 'sign',
			message: 'Willkommen zu Level ' + gameStats.level
		});

		// Add some starter coins to show the way
		for (let i = 0; i < 3; i++) {
			coins.push({
				x: (startX + 2 + i) * blockSize + blockSize/2,
				y: startY * blockSize - blockSize/2,
				width: blockSize/2,
				height: blockSize/2,
				collected: false,
				wobble: i * Math.PI / 2
			});
		}
	}

	/**
	 * Add coins to the level in interesting patterns
	 */
	function addCoinsToLevel(levelMap, blockSize) {
		// Create coins along the main path
		for (let x = 5; x < levelMap[0].length - 5; x += 3) {
			// Find a good position for coins above platforms
			for (let y = 1; y < levelMap.length - 1; y++) {
				if (y + 1 < levelMap.length && levelMap[y+1] && levelMap[y+1][x] &&
					(!levelMap[y] || !levelMap[y][x])) {

					// Add a coin above this platform
					coins.push({
						x: x * blockSize + blockSize/2,
						y: y * blockSize + blockSize/2,
						width: blockSize/2,
						height: blockSize/2,
						collected: false,
						wobble: Math.random() * Math.PI * 2
					});
					break;
				}
			}
		}

		// Create coin patterns - circles, arcs, lines
		const patternCount = 10 + Math.floor(Math.random() * 10);
		for (let i = 0; i < patternCount; i++) {
			const patternX = 20 + Math.floor(Math.random() * (levelMap[0].length - 40));
			let patternY = 0;

			// Find a good platform to place pattern above
			for (let y = 2; y < levelMap.length - 5; y++) {
				if (levelMap[y] && levelMap[y][patternX] &&
					(y < 1 || !levelMap[y-1] || !levelMap[y-1][patternX]) &&
					(y < 2 || !levelMap[y-2] || !levelMap[y-2][patternX])) {

					patternY = y - 3;
					break;
				}
			}

			if (patternY > 0) {
				const patternType = Math.floor(Math.random() * 4);

				switch (patternType) {
					case 0: // Circle
						createCoinCircle(patternX, patternY, 2 + Math.floor(Math.random() * 3), blockSize);
						break;
					case 1: // Arc
						createCoinArc(patternX, patternY, 3 + Math.floor(Math.random() * 3), blockSize);
						break;
					case 2: // Vertical line
						createCoinLine(patternX, patternY, 3 + Math.floor(Math.random() * 3), 'vertical', blockSize);
						break;
					case 3: // Horizontal line
						createCoinLine(patternX, patternY, 3 + Math.floor(Math.random() * 3), 'horizontal', blockSize);
						break;
				}
			}
		}
	}

	/**
	 * Create a circle of coins
	 */
	function createCoinCircle(centerX, centerY, radius, blockSize) {
		const segments = radius * 8;
		for (let i = 0; i < segments; i++) {
			const angle = (i / segments) * Math.PI * 2;
			const x = centerX + Math.cos(angle) * radius;
			const y = centerY + Math.sin(angle) * radius;

			coins.push({
				x: x * blockSize + blockSize/2,
				y: y * blockSize + blockSize/2,
				width: blockSize/2,
				height: blockSize/2,
				collected: false,
				wobble: Math.random() * Math.PI * 2
			});
		}
	}

	/**
	 * Create an arc of coins
	 */
	function createCoinArc(centerX, centerY, radius, blockSize) {
		const segments = radius * 5;
		for (let i = 0; i < segments; i++) {
			const angle = (i / segments) * Math.PI;
			const x = centerX + Math.cos(angle) * radius;
			const y = centerY + Math.sin(angle) * radius;

			coins.push({
				x: x * blockSize + blockSize/2,
				y: y * blockSize + blockSize/2,
				width: blockSize/2,
				height: blockSize/2,
				collected: false,
				wobble: Math.random() * Math.PI * 2
			});
		}
	}

	/**
	 * Create a line of coins
	 */
	function createCoinLine(startX, startY, length, direction, blockSize) {
		for (let i = 0; i < length; i++) {
			const x = direction === 'horizontal' ? startX + i : startX;
			const y = direction === 'vertical' ? startY + i : startY;

			coins.push({
				x: x * blockSize + blockSize/2,
				y: y * blockSize + blockSize/2,
				width: blockSize/2,
				height: blockSize/2,
				collected: false,
				wobble: Math.random() * Math.PI * 2
			});
		}
	}

	/**
	 * Add elevators to help with vertical traversal
	 */
	function addElevatorsToLevel(levelMap, blockSize) {
		// Analyze the level to find vertical gaps that need elevators
		for (let x = 5; x < levelMap[0].length - 5; x += Math.floor(3 + Math.random() * 7)) {
			// Look for tall vertical gaps
			for (let y = 3; y < levelMap.length - 5; y++) {
				if (!levelMap[y][x] &&
					y + 1 < levelMap.length && !levelMap[y+1][x] &&
					y + 2 < levelMap.length && !levelMap[y+2][x]) {

					// Found a potential elevator location, now check if there are platforms above and below
					let topPlatformY = -1;
					let bottomPlatformY = -1;

					// Look up for a platform
					for (let checkY = y - 1; checkY >= 0; checkY--) {
						if ((levelMap[checkY][x]) ||
							(x > 0 && levelMap[checkY][x-1]) ||
							(x < levelMap[0].length - 1 && levelMap[checkY][x+1])) {
							topPlatformY = checkY;
							break;
						}
					}

					// Look down for a platform
					for (let checkY = y + 3; checkY < levelMap.length; checkY++) {
						if ((levelMap[checkY][x]) ||
							(x > 0 && levelMap[checkY][x-1]) ||
							(x < levelMap[0].length - 1 && levelMap[checkY][x+1])) {
							bottomPlatformY = checkY;
							break;
						}
					}

					// If we found platforms on both ends and the gap is significant
					if (topPlatformY >= 0 && bottomPlatformY >= 0 && bottomPlatformY - topPlatformY > 4) {
						// Create an elevator
						elevators.push({
							x: x * blockSize,
							y: (topPlatformY + 1) * blockSize,
							width: blockSize,
							height: blockSize / 3,
							startY: (topPlatformY + 1) * blockSize,
							endY: (bottomPlatformY - 1) * blockSize,
							direction: 1,
							speed: 1 + Math.random() * 0.5,
							color: '#BBBBBB'  // Light gray elevator platform
						});

						// Add some visual guides to show the elevator path
						for (let guideY = topPlatformY + 2; guideY < bottomPlatformY; guideY += 2) {
							decorations.push({
								x: x * blockSize,
								y: guideY * blockSize,
								width: blockSize / 4,
								height: blockSize / 4,
								color: '#AAAAAA',
								type: 'elevatorGuide'
							});
						}

						// Skip ahead to avoid placing too many elevators close together
						x += 5;
						break;
					}
				}
			}
		}
	}

	/**
	 * Add enemies with varied behaviors based on level themes
	 */
	function addEnemiesToLevel(levelMap, blockSize, themes) {
		// Add a balanced number of enemies based on level size
		const enemyCount = 15 + Math.floor(Math.random() * 10) + (gameStats.level * 2);

		for (let i = 0; i < enemyCount; i++) {
			// Choose a section of the level for enemy placement
			const sectionIndex = Math.floor(Math.random() * themes.length);
			const sectionWidth = levelMap[0].length / themes.length;
			const sectionStartX = Math.floor(sectionIndex * sectionWidth);
			const sectionEndX = Math.floor((sectionIndex + 1) * sectionWidth);

			// Choose a random position within this section, avoiding the start area
			let enemyX = Math.max(15, sectionStartX + Math.floor(Math.random() * (sectionEndX - sectionStartX)));
			let enemyY = 0;

			// Skip if out of bounds
			if (enemyX >= levelMap[0].length) continue;

			// Find a suitable platform for this enemy
			let foundPlatform = false;
			for (let y = 1; y < levelMap.length - 3; y++) {
				if (y + 1 < levelMap.length && levelMap[y+1] && levelMap[y+1][enemyX] &&
					(!levelMap[y] || !levelMap[y][enemyX])) {

					enemyY = y;
					foundPlatform = true;
					break;
				}
			}

			if (foundPlatform) {
				// Determine platform extent for patrol boundaries
				let leftBound = enemyX;
				let rightBound = enemyX;

				// Find left boundary of platform
				for (let x = enemyX - 1; x >= Math.max(0, enemyX - 10); x--) {
					if (enemyY + 1 < levelMap.length && levelMap[enemyY+1] &&
						levelMap[enemyY+1][x] &&
						(!levelMap[enemyY] || !levelMap[enemyY][x])) {
						leftBound = x;
					} else {
						break;
					}
				}

				// Find right boundary of platform
				for (let x = enemyX + 1; x < Math.min(levelMap[0].length, enemyX + 10); x++) {
					if (enemyY + 1 < levelMap.length && levelMap[enemyY+1] &&
						levelMap[enemyY+1][x] &&
						(!levelMap[enemyY] || !levelMap[enemyY][x])) {
						rightBound = x;
					} else {
						break;
					}
				}

				// Only create enemy if platform is wide enough
				if (rightBound - leftBound >= 2) {
					// Choose enemy type based on theme and random chance
					const themeBasedEnemyTypes = getThemeEnemyTypes(themes[sectionIndex].name);
					const enemyType = themeBasedEnemyTypes[Math.floor(Math.random() * themeBasedEnemyTypes.length)];

					// Find a platform for the enemy to use - needed for flying enemies
					const enemyPlatform = {
						x: leftBound * blockSize,
						y: enemyY * blockSize,
						width: (rightBound - leftBound + 1) * blockSize,
						height: blockSize
					};

					// Create the enemy
					const enemy = {
						x: enemyX * blockSize + blockSize / 2,
						y: enemyY * blockSize,
						width: blockSize * 0.8,
						height: blockSize * 0.8,
						type: enemyType.name,
						color: enemyType.color,
						speed: enemyType.speed * (0.8 + Math.random() * 0.4),
						damage: enemyType.damage,
						direction: Math.random() < 0.5 ? -1 : 1,
						patrolStart: leftBound * blockSize,
						patrolEnd: rightBound * blockSize,
						platform: enemyPlatform, // Add reference to platform
						state: 'patrol',
						theme: themes[sectionIndex].name,
						animationFrame: 0
					};

					// Add special properties based on enemy type
					if (enemyType.name === 'jumper') {
						enemy.jumpHeight = enemyType.jumpHeight;
						enemy.jumpTimer = Math.floor(Math.random() * 100);
					}

					if (enemyType.name === 'flyer') {
						enemy.flyHeight = enemyType.flyHeight;
						enemy.flyOffset = Math.random() * Math.PI * 2;
						enemy.y -= blockSize; // Start higher
					}

					enemies.push(enemy);
				}
			}
		}
	}

	/**
	 * Get enemy types appropriate for a theme
	 */
	function getThemeEnemyTypes(theme) {
		const baseEnemyTypes = config.platformer.enemyTypes;

		// Return theme-appropriate enemy types
		switch (theme) {
			case 'forest':
				return [
					{ name: 'walker', color: '#336633', speed: 1.5, damage: 1 },
					{ name: 'jumper', color: '#669966', speed: 2, damage: 1, jumpHeight: 8 }
				];
			case 'desert':
				return [
					{ name: 'walker', color: '#CC9966', speed: 1.8, damage: 1 },
					{ name: 'flyer', color: '#FFCC99', speed: 2.2, damage: 1, flyHeight: 80 }
				];
			case 'mountain':
				return [
					{ name: 'jumper', color: '#6699CC', speed: 1.5, damage: 1, jumpHeight: 10 },
					{ name: 'walker', color: '#336699', speed: 1.2, damage: 1 }
				];
			case 'volcano':
				return [
					{ name: 'walker', color: '#CC3300', speed: 2, damage: 1 },
					{ name: 'flyer', color: '#FF6633', speed: 2.5, damage: 2, flyHeight: 100 }
				];
			default:
				return baseEnemyTypes;
		}
	}

	/**
	 * Add atmospheric effects to enhance the environment
	 */
	function addAtmosphericEffects(levelWidth, levelHeight, blockSize) {
		// Create particle emitters for ambiance
		particleEmitters = [];

		// Add some ambient particle effects based on level areas
		for (let i = 0; i < 20; i++) {
			const x = Math.random() * levelWidth;
			const y = Math.random() * levelHeight * 0.7;

			// Determine which section we're in
			const sectionIndex = Math.floor((x / levelWidth) * 4);

			// Create different effects based on section theme
			switch (sectionIndex) {
				case 0: // Forest
					if (Math.random() < 0.7) {
						// Floating leaves/pollen
						particleEmitters.push({
							x: x,
							y: y,
							color: '#CCFF99',
							rate: 0.02,
							size: 2,
							lifetime: 200,
							speedX: 0.3,
							speedY: 0.1,
							type: 'leaf'
						});
					}
					break;
				case 1: // Desert
					if (Math.random() < 0.6) {
						// Dust clouds
						particleEmitters.push({
							x: x,
							y: levelHeight - 100 - Math.random() * 200,
							color: '#DDCCAA',
							rate: 0.05,
							size: 1.5,
							lifetime: 150,
							speedX: 0.5,
							speedY: -0.1,
							type: 'dust'
						});
					}
					break;
				case 2: // Mountain
					if (Math.random() < 0.5) {
						// Mist/clouds
						particleEmitters.push({
							x: x,
							y: y,
							color: '#FFFFFF',
							rate: 0.01,
							size: 4,
							lifetime: 250,
							speedX: 0.2,
							speedY: 0,
							type: 'mist'
						});
					}
					break;
				case 3: // Volcano
					if (Math.random() < 0.8) {
						// Smoke and embers
						particleEmitters.push({
							x: x,
							y: levelHeight - 50 - Math.random() * 150,
							color: Math.random() < 0.3 ? '#FF6600' : '#777777',
							rate: 0.1,
							size: 2,
							lifetime: 100,
							speedX: 0.1,
							speedY: -0.7,
							type: 'ember'
						});
					}
					break;
			}
		}
	}

	/**
	 * Place the goal flag at a logical endpoint
	 */
	function placeGoalFlag(levelMap, blockSize) {
		// Place the goal near the end of the level, but on a safe platform
		const endRegionStart = Math.floor(levelMap[0].length * 0.9);
		let goalX = 0;
		let goalY = 0;
		let foundGoalPosition = false;

		// Search from right to left in the end region
		for (let x = levelMap[0].length - 5; x >= endRegionStart && !foundGoalPosition; x--) {
			for (let y = 1; y < levelMap.length - 2; y++) {
				// Look for a platform with space above it
				if (y + 1 < levelMap.length && levelMap[y+1] && levelMap[y+1][x] &&
					(!levelMap[y] || !levelMap[y][x]) &&
					(y < 1 || !levelMap[y-1] || !levelMap[y-1][x])) {

					// Check if there's a clear path to this position
					let hasPath = false;
					for (let checkX = x - 5; checkX <= x + 5; checkX++) {
						if (checkX >= 0 && checkX < levelMap[0].length &&
							y + 1 < levelMap.length && levelMap[y+1] &&
							levelMap[y+1][checkX] && checkX !== x) {
							hasPath = true;
							break;
						}
					}

					if (hasPath) {
						goalX = x;
						goalY = y;
						foundGoalPosition = true;
						break;
					}
				}
			}
		}

		// If we didn't find a position, use a fallback
		if (!foundGoalPosition) {
			goalX = levelMap[0].length - 5;
			goalY = levelMap.length - 3;
		}

		// Create the goal with a visible platform beneath it
		goal = {
			x: goalX * blockSize,
			y: goalY * blockSize - blockSize,
			width: blockSize * 1.2,
			height: blockSize * 2,
			animate: true
		};

		// Add a victory platform
		platforms.push({
			x: goalX * blockSize - blockSize,
			y: (goalY + 1) * blockSize,
			width: blockSize * 3,
			height: blockSize,
			color: '#DDDDDD',
			isVictoryPlatform: true
		});

		// Add special visual effects around the goal
		particleEmitters.push({
			x: goalX * blockSize + blockSize/2,
			y: goalY * blockSize,
			color: '#FFFF00',
			rate: 0.1,
			size: 3,
			lifetime: 60,
			speedX: 0,
			speedY: -0.5,
			type: 'goalGlow'
		});
	}

	/**
	 * Set the player's starting position
	 */
	function setPlayerStartPosition(levelMap, blockSize) {
		// Find a safe starting platform near the beginning of the level
		let startX = 3;
		let startY = 0;
		let foundStart = false;

		// Look for a suitable platform in the first section of the level
		for (let x = 2; x < 10 && !foundStart; x++) {
			for (let y = 1; y < levelMap.length - 2; y++) {
				if (y + 1 < levelMap.length && levelMap[y+1] && levelMap[y+1][x] &&
					(!levelMap[y] || !levelMap[y][x]) &&
					(y < 1 || !levelMap[y-1] || !levelMap[y-1][x])) {

					startX = x;
					startY = y;
					foundStart = true;
					break;
				}
			}
		}

		// Set player position
		player.x = startX * blockSize;
		player.y = startY * blockSize;
		player.velocityX = 0;
		player.velocityY = 0;
		player.facing = 1;

		// Add a welcome sign near the start
		decorations.push({
			x: (startX - 1) * blockSize,
			y: startY * blockSize,
			width: blockSize,
			height: blockSize * 1.5,
			color: '#8B4513',
			type: 'sign',
			message: 'Welcome to level ' + gameStats.level
		});

		// Add some starter coins to show the way
		for (let i = 0; i < 3; i++) {
			coins.push({
				x: (startX + 2 + i) * blockSize + blockSize/2,
				y: startY * blockSize - blockSize/2,
				width: blockSize/2,
				height: blockSize/2,
				collected: false,
				wobble: i * Math.PI / 2
			});
		}
	}

	/**
	 * Update platformer game state
	 */
	function updatePlatformer() {
		// Process player input
		player.velocityX = 0;
		player.animation += 0.1;

		if (keysPressed.left) {
			player.velocityX = -config.platformer.playerSpeed;
			player.facing = -1;
		}

		if (keysPressed.right) {
			player.velocityX = config.platformer.playerSpeed;
			player.facing = 1;
		}

		if ((keysPressed.up || keysPressed.space) && player.onGround) {
			player.velocityY = config.platformer.jumpVelocity;
			player.isJumping = true;
			player.onGround = false;
			createParticleEffect(player.x + player.width/2, player.y + player.height, 10, '#FFFFFF', 1);
		}

		// Update invulnerability timer
		if (player.invulnerable > 0) {
			player.invulnerable--;
		}

		// Apply gravity
		player.velocityY += config.platformer.gravity;

		// Move player
		player.x += player.velocityX;

		// Check horizontal collisions with platforms
		for (const platform of platforms) {
			if (checkRectCollision(
				{x: player.x, y: player.y + 2, width: player.width, height: player.height - 4},
				platform)) {

				if (player.velocityX > 0) {
					player.x = platform.x - player.width;
				} else if (player.velocityX < 0) {
					player.x = platform.x + platform.width;
				}
				player.velocityX = 0;
			}
		}

		// Apply vertical movement
		player.y += player.velocityY;

		// Check vertical collisions with platforms
		player.onGround = false;
		for (const platform of platforms) {
			if (checkPlatformCollision(player, platform)) {
				player.onGround = true;
				player.velocityY = 0;
				player.y = platform.y - player.height;
				player.isJumping = false;
			}
		}

		// Check elevator collisions
		for (const elevator of elevators) {
			if (player.velocityY >= 0 && // Only check when falling or standing
				player.y + player.height >= elevator.y &&
				player.y + player.height <= elevator.y + elevator.height/2 &&
				player.x + player.width > elevator.x &&
				player.x < elevator.x + elevator.width) {

				player.onGround = true;
				player.velocityY = 0;
				player.y = elevator.y - player.height;
				player.isJumping = false;

				// Player moves with the elevator
				player.y += elevator.direction * elevator.speed;
			}
		}

		// Update elevators
		for (const elevator of elevators) {
			elevator.y += elevator.direction * elevator.speed;

			// Reverse direction at endpoints
			if (elevator.y <= elevator.startY) {
				elevator.y = elevator.startY;
				elevator.direction = 1;
			} else if (elevator.y >= elevator.endY) {
				elevator.y = elevator.endY;
				elevator.direction = -1;
			}
		}

		// Update enemies
		for (const enemy of enemies) {
			switch(enemy.type) {
				case 'walker':
					// Simple left-right patrol
					enemy.x += enemy.direction * enemy.speed;

					// Check if reached patrol boundary
					if (enemy.x <= enemy.patrolStart) {
						enemy.x = enemy.patrolStart;
						enemy.direction = 1;
					} else if (enemy.x >= enemy.patrolEnd) {
						enemy.x = enemy.patrolEnd;
						enemy.direction = -1;
					}

					// Check platform ends to turn around
					let onEdge = true;
					for (const platform of platforms) {
						if (enemy.x + enemy.width/2 > platform.x &&
							enemy.x + enemy.width/2 < platform.x + platform.width &&
							enemy.y + enemy.height + 5 > platform.y &&
							enemy.y + enemy.height - 5 < platform.y) {
							onEdge = false;
							break;
						}
					}
					if (onEdge) {
						enemy.direction *= -1;
					}
					break;

				case 'jumper':
					// Move like a walker but can jump
					enemy.x += enemy.direction * enemy.speed;

					// Check if reached patrol boundary
					if (enemy.x <= enemy.patrolStart) {
						enemy.x = enemy.patrolStart;
						enemy.direction = 1;
					} else if (enemy.x >= enemy.patrolEnd) {
						enemy.x = enemy.patrolEnd;
						enemy.direction = -1;
					}

					// Jump periodically
					enemy.jumpTimer = (enemy.jumpTimer + 1) % 120;
					if (enemy.jumpTimer === 0 && Math.random() < 0.5) {
						enemy.velocityY = -enemy.jumpHeight;
					}

					// Apply gravity
					enemy.velocityY = enemy.velocityY || 0;
					enemy.velocityY += config.platformer.gravity * 0.7;
					enemy.y += enemy.velocityY;

					// Check ground collision
					for (const platform of platforms) {
						if (enemy.velocityY > 0 && // Only check when falling
							enemy.y + enemy.height >= platform.y &&
							enemy.y + enemy.height <= platform.y + platform.height/2 &&
							enemy.x + enemy.width > platform.x &&
							enemy.x < platform.x + platform.width) {

							enemy.velocityY = 0;
							enemy.y = platform.y - enemy.height;
							break;
						}
					}
					break;

				case 'flyer':
					// Flies in a sine wave pattern
					enemy.x += enemy.direction * enemy.speed;

					// Check if reached patrol boundary
					if (enemy.x <= enemy.patrolStart) {
						enemy.x = enemy.patrolStart;
						enemy.direction = 1;
					} else if (enemy.x >= enemy.patrolEnd) {
						enemy.x = enemy.patrolEnd;
						enemy.direction = -1;
					}

					// Sine wave movement vertically
					if (enemy.platform) {
						const baseY = enemy.platform.y - enemy.flyHeight;
						enemy.y = baseY + Math.sin(enemy.flyOffset + enemy.x * 0.02) * (enemy.flyHeight * 0.5);
					}
					break;
			}

			// Check player collision with enemy
			if (player.invulnerable === 0 && checkRectCollision(player, enemy)) {
				// Player takes damage
				gameStats.lives--;
				player.invulnerable = 60; // 1 second invulnerability
				player.velocityY = config.platformer.jumpVelocity * 0.7; // Bounce up slightly
				createParticleEffect(player.x + player.width/2, player.y + player.height/2, 20, '#FF0000', 1.5);

				// Check game over
				if (gameStats.lives <= 0) {
					gameState = GAME_STATE.GAME_OVER;
				}
			}
		}

		// Check hazard collisions
		for (const hazard of hazards) {
			if (player.invulnerable === 0 && checkRectCollision(player, hazard)) {
				// Player takes damage
				gameStats.lives -= hazard.damage;
				player.invulnerable = 60; // 1 second invulnerability
				player.velocityY = config.platformer.jumpVelocity * 0.7; // Bounce up
				createParticleEffect(player.x + player.width/2, player.y + player.height/2, 15, '#FF0000', 1.2);

				// Check game over
				if (gameStats.lives <= 0) {
					gameState = GAME_STATE.GAME_OVER;
				}
			}
		}

		// Check water collisions
		for (const water of waters) {
			if (player.invulnerable === 0 && checkRectCollision(player, water)) {
				// Player takes damage in water
				gameStats.lives--;
				player.invulnerable = 60; // 1 second invulnerability
				player.velocityY = config.platformer.jumpVelocity; // Bounce out of water
				createParticleEffect(player.x + player.width/2, player.y + player.height/2, 20, '#4444FF', 1.5);

				// Check game over
				if (gameStats.lives <= 0) {
					gameState = GAME_STATE.GAME_OVER;
				}
			}
		}

		// Check for coin collection
		for (const coin of coins) {
			if (!coin.collected && checkRectCollision(player, coin)) {
				coin.collected = true;
				gameStats.score += config.platformer.coinValue;
				createParticleEffect(coin.x, coin.y, 10, config.platformer.coinColor, 1);
			}
		}

		// Check if player reached goal
		if (checkRectCollision(player, goal)) {
			// Level complete
			gameStats.level++;
			createParticleEffect(goal.x + goal.width/2, goal.y + goal.height/2, 30, '#FFFF00', 2);

			// Short delay before next level
			setTimeout(() => {
				initTetrisMode();
			}, 1000);
		}

		// Check if player fell off the map
		if (player.y > level.height + 200) {
			playerDeath();
		}

		// Update camera to follow player
		const targetCameraX = player.x - canvas.width / 2;
		const targetCameraY = player.y - canvas.height / 2;

		// Smooth camera movement
		camera.x += (targetCameraX - camera.x) * 0.1;
		camera.y += (targetCameraY - camera.y) * 0.1;

		// Clamp camera to level bounds
		camera.x = Math.max(0, Math.min(level.width - canvas.width, camera.x));
		camera.y = Math.max(0, Math.min(level.height - canvas.height, camera.y));
	}

	/**
	 * Handle player death
	 */
	function playerDeath() {
		gameStats.lives--;

		if (gameStats.lives <= 0) {
			// Game over
			gameState = GAME_STATE.GAME_OVER;
		} else {
			// Respawn player
			player.x = 100;
			player.y = 100;
			player.velocityX = 0;
			player.velocityY = 0;
		}
	}

	/**
	 * Check collision between player and platform
	 */
	function checkPlatformCollision(player, platform) {
		// Only check collision from above
		if (player.velocityY <= 0) return false;

		const wasAbove = player.y + player.height - player.velocityY <= platform.y;

		return wasAbove &&
			player.x + player.width > platform.x &&
			player.x < platform.x + platform.width &&
			player.y + player.height >= platform.y &&
			player.y < platform.y + platform.height;
	}

	/**
	 * Check collision between two rectangles
	 */
	function checkRectCollision(rect1, rect2) {
		return rect1.x + rect1.width > rect2.x &&
			rect1.x < rect2.x + rect2.width &&
			rect1.y + rect1.height > rect2.y &&
			rect1.y < rect2.y + rect2.height;
	}

	/**
	 * Draw the platformer game state
	 */
	function drawPlatformer() {
		// Clear canvas with sky color
		const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
		skyGradient.addColorStop(0, '#87CEEB');   // Sky blue at top
		skyGradient.addColorStop(1, '#E0F7FF');   // Lighter blue at bottom

		ctx.fillStyle = skyGradient;
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// Draw elements adjusted for camera position
		const offsetX = -camera.x;
		const offsetY = -camera.y;

		// Draw parallax background layers
		for (const layer of backgroundLayers) {
			if (layer.type === 'sky') {
				// Already drawn the sky gradient
			}
			else if (layer.type === 'mountains') {
				ctx.fillStyle = layer.color;

				for (const mountain of layer.mountains) {
					// Apply parallax effect - mountains move slower than foreground
					const parallaxX = offsetX * layer.speed;
					const mountainX = (mountain.x + parallaxX) % (level.width * 1.5) - mountain.width/2;

					if (mountainX < canvas.width && mountainX + mountain.width > 0) {
						// Draw mountain as a smooth triangle with gradient
						const mountainGradient = ctx.createLinearGradient(
							mountainX, canvas.height - mountain.height,
							mountainX + mountain.width, canvas.height - mountain.height
						);

						// Create depth effect with lighting
						mountainGradient.addColorStop(0, adjustColorBrightness(mountain.color, -10));
						mountainGradient.addColorStop(0.5, adjustColorBrightness(mountain.color, 10));
						mountainGradient.addColorStop(1, adjustColorBrightness(mountain.color, -15));

						ctx.fillStyle = mountainGradient;

						ctx.beginPath();
						ctx.moveTo(mountainX, canvas.height);

						// Draw the mountain with a smoother peak
						const peakX = mountainX + mountain.width / 2;
						const peakY = canvas.height - mountain.height;

						// Create a curved mountain profile
						ctx.lineTo(peakX - mountain.width * 0.35, canvas.height - mountain.height * 0.3);
						ctx.quadraticCurveTo(
							peakX - mountain.width * 0.2, peakY - 10,
							peakX, peakY
						);
						ctx.quadraticCurveTo(
							peakX + mountain.width * 0.2, peakY - 10,
							peakX + mountain.width * 0.35, canvas.height - mountain.height * 0.3
						);

						ctx.lineTo(mountainX + mountain.width, canvas.height);
						ctx.closePath();
						ctx.fill();

						// Add some snow caps to taller mountains
						if (mountain.height > 150) {
							ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
							ctx.beginPath();
							ctx.moveTo(peakX, peakY);
							ctx.lineTo(peakX - 20, peakY + 15);
							ctx.lineTo(peakX + 20, peakY + 15);
							ctx.closePath();
							ctx.fill();
						}
					}
				}
			}
			else if (layer.type === 'trees') {
				for (const tree of layer.trees) {
					const parallaxX = offsetX * layer.speed;
					const treeX = (tree.x + parallaxX) % level.width;

					if (treeX < canvas.width && treeX + tree.width > 0) {
						// Draw a silhouette tree
						ctx.fillStyle = '#25523B';  // Dark green for distant trees

						// Draw trunk
						ctx.fillRect(
							treeX - tree.width/6,
							canvas.height - tree.height,
							tree.width/3,
							tree.height * 0.4
						);

						// Draw foliage based on tree type
						if (tree.type === 0) {
							// Pine tree
							ctx.beginPath();
							ctx.moveTo(treeX - tree.width/2, canvas.height - tree.height * 0.4);
							ctx.lineTo(treeX, canvas.height - tree.height);
							ctx.lineTo(treeX + tree.width/2, canvas.height - tree.height * 0.4);
							ctx.closePath();
							ctx.fill();

							ctx.beginPath();
							ctx.moveTo(treeX - tree.width/2, canvas.height - tree.height * 0.55);
							ctx.lineTo(treeX, canvas.height - tree.height * 0.9);
							ctx.lineTo(treeX + tree.width/2, canvas.height - tree.height * 0.55);
							ctx.closePath();
							ctx.fill();
						}
						else if (tree.type === 1) {
							// Oak tree
							ctx.beginPath();
							ctx.arc(treeX, canvas.height - tree.height * 0.7, tree.width/2, 0, Math.PI * 2);
							ctx.fill();
						}
						else {
							// Bush/shrub
							ctx.beginPath();
							ctx.arc(treeX - tree.width/4, canvas.height - tree.height * 0.25, tree.width/4, 0, Math.PI * 2);
							ctx.fill();
							ctx.beginPath();
							ctx.arc(treeX, canvas.height - tree.height * 0.4, tree.width/3, 0, Math.PI * 2);
							ctx.fill();
							ctx.beginPath();
							ctx.arc(treeX + tree.width/4, canvas.height - tree.height * 0.25, tree.width/4, 0, Math.PI * 2);
							ctx.fill();
						}
					}
				}
			}
			else if (layer.type === 'clouds') {
				ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';

				for (const cloud of layer.clouds) {
					const parallaxX = offsetX * layer.speed;
					let cloudX = (cloud.x + parallaxX + (Date.now() * cloud.speed * 0.02)) % (level.width * 1.2);

					if (cloudX < canvas.width && cloudX + cloud.width > 0) {
						// Draw a fluffy cloud
						const cloudY = cloud.y;
						const segments = 5;
						const segmentWidth = cloud.width / segments;

						for (let i = 0; i < segments; i++) {
							const segX = cloudX + i * segmentWidth;
							const segY = cloudY + (i % 2 === 0 ? 0 : cloud.height * 0.3);

							ctx.beginPath();
							ctx.arc(
								segX,
								segY,
								cloud.height / 1.2,
								0, Math.PI * 2
							);
							ctx.fill();
						}
					}
				}
			}
		}

		// Draw water
		for (const water of waters) {
			if (isOnScreen(water)) {
				// Animate water surface with sine wave
				const time = Date.now() * 0.002;
				const gradient = ctx.createLinearGradient(
					water.x + offsetX, water.y + offsetY,
					water.x + offsetX, water.y + offsetY + water.height
				);

				gradient.addColorStop(0, 'rgba(68, 68, 255, ' + water.depth + ')');
				gradient.addColorStop(1, 'rgba(0, 0, 128, ' + water.depth + ')');
				ctx.fillStyle = gradient;

				// Draw water with wavy top
				ctx.beginPath();
				ctx.moveTo(water.x + offsetX, water.y + offsetY + Math.sin(time + water.offset) * 3);

				for (let i = 0; i <= water.width; i += 5) {
					ctx.lineTo(
						water.x + offsetX + i,
						water.y + offsetY + Math.sin(time + water.offset + i * 0.05) * 3
					);
				}

				ctx.lineTo(water.x + offsetX + water.width, water.y + offsetY + water.height);
				ctx.lineTo(water.x + offsetX, water.y + offsetY + water.height);
				ctx.closePath();
				ctx.fill();

				// Add reflection highlights
				ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
				for (let i = 0; i < 3; i++) {
					const size = 2 + Math.random() * 6;
					const x = water.x + offsetX + Math.random() * water.width;
					const y = water.y + offsetY + Math.random() * (water.height * 0.5);
					ctx.beginPath();
					ctx.arc(x, y, size, 0, Math.PI * 2);
					ctx.fill();
				}
			}
		}

		// Draw platforms
		for (const platform of platforms) {
			if (isOnScreen(platform)) {
				if (platform.isGround) {
					// Draw ground with texture
					const gradient = ctx.createLinearGradient(
						platform.x + offsetX, platform.y + offsetY,
						platform.x + offsetX, platform.y + offsetY + platform.height
					);
					gradient.addColorStop(0, '#8B4513');  // Brown earth
					gradient.addColorStop(0.7, '#654321'); // Darker brown

					ctx.fillStyle = gradient;
					ctx.fillRect(
						platform.x + offsetX,
						platform.y + offsetY,
						platform.width,
						platform.height
					);

					// Add some texture to the ground
					ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
					for (let i = 0; i < 5; i++) {
						const dotX = platform.x + offsetX + Math.random() * platform.width;
						const dotY = platform.y + offsetY + Math.random() * platform.height;
						const dotSize = 1 + Math.random() * 2;

						ctx.beginPath();
						ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
						ctx.fill();
					}
				}
				else if (platform.isVictoryPlatform) {
					// Draw a special platform for the goal
					const gradient = ctx.createLinearGradient(
						platform.x + offsetX, platform.y + offsetY,
						platform.x + offsetX, platform.y + offsetY + platform.height
					);
					gradient.addColorStop(0, '#FFFFFF');
					gradient.addColorStop(1, '#AAAAAA');

					ctx.fillStyle = gradient;
					ctx.fillRect(
						platform.x + offsetX,
						platform.y + offsetY,
						platform.width,
						platform.height
					);

					// Add decorative effect
					ctx.strokeStyle = '#FFFF00';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.rect(
						platform.x + offsetX + 2,
						platform.y + offsetY + 2,
						platform.width - 4,
						platform.height - 4
					);
					ctx.stroke();
				}
				else if (platform.isFloating) {
					// Draw a floating island with a special effect
					const timeOffset = Date.now() * 0.001;
					const floatY = Math.sin(timeOffset) * 3;

					// Draw the main platform
					const gradient = ctx.createLinearGradient(
						platform.x + offsetX, platform.y + offsetY + floatY,
						platform.x + offsetX, platform.y + offsetY + floatY + platform.height
					);
					gradient.addColorStop(0, '#DDDDDD');
					gradient.addColorStop(1, '#AAAAAA');

					ctx.fillStyle = gradient;
					ctx.fillRect(
						platform.x + offsetX,
						platform.y + offsetY + floatY,
						platform.width,
						platform.height
					);

					// Add a magical glow effect
					ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
					ctx.beginPath();
					ctx.ellipse(
						platform.x + offsetX + platform.width/2,
						platform.y + offsetY + floatY + platform.height + 5,
						platform.width/2,
						3,
						0, 0, Math.PI * 2
					);
					ctx.fill();
				}
				else if (platform.isSecret) {
					// Draw secret/underground areas
					ctx.fillStyle = '#654321';  // Dark brown
					ctx.fillRect(
						platform.x + offsetX,
						platform.y + offsetY,
						platform.width,
						platform.height
					);

					// Add some mystical markings
					ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';  // Gold
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.moveTo(platform.x + offsetX + 5, platform.y + offsetY + platform.height/2);
					ctx.lineTo(platform.x + offsetX + platform.width - 5, platform.y + offsetY + platform.height/2);
					ctx.stroke();
				}
				else {
					// Draw regular platforms based on their theme/type
					drawThemedPlatform(platform, offsetX, offsetY);
				}
			}
		}

		// Draw elevators
		for (const elevator of elevators) {
			if (isOnScreen(elevator)) {
				// Draw elevator platform with a metallic look
				const gradient = ctx.createLinearGradient(
					elevator.x + offsetX, elevator.y + offsetY,
					elevator.x + offsetX, elevator.y + offsetY + elevator.height
				);
				gradient.addColorStop(0, '#CCCCCC');
				gradient.addColorStop(0.5, '#EEEEEE');
				gradient.addColorStop(1, '#AAAAAA');

				ctx.fillStyle = gradient;
				ctx.fillRect(
					elevator.x + offsetX,
					elevator.y + offsetY,
					elevator.width,
					elevator.height
				);

				// Draw elevator detail and mechanisms
				ctx.fillStyle = '#666666';
				ctx.fillRect(
					elevator.x + offsetX + elevator.width * 0.25,
					elevator.y + offsetY,
					elevator.width * 0.5,
					elevator.height
				);

				// Draw elevator cable/chain
				ctx.strokeStyle = '#444444';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(elevator.x + offsetX + elevator.width * 0.5, elevator.y + offsetY);
				ctx.lineTo(elevator.x + offsetX + elevator.width * 0.5, elevator.startY + offsetY);
				ctx.stroke();

				// Draw motion blur effect
				ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
				for (let i = 1; i <= 3; i++) {
					const blurY = elevator.direction > 0 ? -i * 2 : i * 2;
					ctx.fillRect(
						elevator.x + offsetX,
						elevator.y + offsetY + blurY,
						elevator.width,
						1
					);
				}
			}
		}

		// Draw decorations
		for (const decoration of decorations) {
			if (isOnScreen(decoration)) {
				if (decoration.type === 'sign') {
					// Draw a sign
					ctx.fillStyle = decoration.color;

					// Draw sign post
					ctx.fillRect(
						decoration.x + offsetX + decoration.width * 0.4,
						decoration.y + offsetY + decoration.height * 0.5,
						decoration.width * 0.2,
						decoration.height * 0.5
					);

					// Draw sign board
					ctx.fillRect(
						decoration.x + offsetX + decoration.width * 0.2,
						decoration.y + offsetY + decoration.height * 0.2,
						decoration.width * 0.6,
						decoration.height * 0.3
					);

					// Draw sign text
					ctx.fillStyle = '#000000';
					ctx.font = '10px Arial';
					ctx.textAlign = 'center';
					ctx.fillText(
						decoration.message || 'Welcome!',
						decoration.x + offsetX + decoration.width * 0.5,
						decoration.y + offsetY + decoration.height * 0.36
					);
				}
				else if (decoration.type === 'elevatorGuide') {
					// Draw elevator guide/rail marker
					ctx.fillStyle = decoration.color;
					ctx.fillRect(
						decoration.x + offsetX,
						decoration.y + offsetY,
						decoration.width,
						decoration.height
					);
				}
				else if (decoration.small) {
					// Draw small decorative elements like grass, flowers, small rocks
					if (decoration.type === 0) {
						// Grass/plant
						ctx.fillStyle = decoration.color;

						// Draw simple grass blades
						for (let i = 0; i < 3; i++) {
							const bladeX = decoration.x + offsetX + i * (decoration.width / 3);
							const bladeHeight = decoration.height * (0.7 + Math.random() * 0.3);

							ctx.beginPath();
							ctx.moveTo(bladeX, decoration.y + offsetY + decoration.height);
							ctx.lineTo(bladeX + decoration.width / 6, decoration.y + offsetY + decoration.height - bladeHeight);
							ctx.lineTo(bladeX + decoration.width / 3, decoration.y + offsetY + decoration.height);
							ctx.closePath();
							ctx.fill();
						}
					}
					else if (decoration.type === 1) {
						// Small flower
						const flowerX = decoration.x + offsetX + decoration.width / 2;
						const flowerY = decoration.y + offsetY + decoration.height / 2;

						// Draw stem
						ctx.strokeStyle = '#3F6C58';
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo(flowerX, flowerY + decoration.height / 2);
						ctx.lineTo(flowerX, flowerY - decoration.height / 3);
						ctx.stroke();

						// Draw flower petals
						ctx.fillStyle = '#FF77FF'; // Pink
						const petalSize = decoration.width / 4;

						for (let i = 0; i < 5; i++) {
							const angle = (i / 5) * Math.PI * 2;
							ctx.beginPath();
							ctx.arc(
								flowerX + Math.cos(angle) * petalSize,
								flowerY - decoration.height / 3 + Math.sin(angle) * petalSize,
								petalSize,
								0, Math.PI * 2
							);
							ctx.fill();
						}

						// Draw flower center
						ctx.fillStyle = '#FFFF00';
						ctx.beginPath();
						ctx.arc(
							flowerX,
							flowerY - decoration.height / 3,
							petalSize / 2,
							0, Math.PI * 2
						);
						ctx.fill();
					}
					else {
						// Small rock
						ctx.fillStyle = '#777777';
						ctx.beginPath();
						ctx.ellipse(
							decoration.x + offsetX + decoration.width / 2,
							decoration.y + offsetY + decoration.height * 0.7,
							decoration.width / 2,
							decoration.height / 3,
							0, 0, Math.PI * 2
						);
						ctx.fill();
					}
				}
				else {
					// Larger decorations - bushes, crystals, etc.
					if (decoration.type === 0) {
						// Bush
						ctx.fillStyle = decoration.color;

						// Draw a cluster of circles to form a bush
						const centerX = decoration.x + offsetX + decoration.width / 2;
						const bottomY = decoration.y + offsetY + decoration.height;

						for (let i = 0; i < 5; i++) {
							const circleX = centerX + (i - 2) * (decoration.width / 5);
							const circleY = bottomY - (decoration.height / 2) - (i % 2 === 0 ? decoration.height / 4 : 0);
							const radius = decoration.width / 4;

							ctx.beginPath();
							ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
							ctx.fill();
						}
					}
					else if (decoration.type === 1) {
						// Crystal formation
						const centerX = decoration.x + offsetX + decoration.width / 2;
						const bottomY = decoration.y + offsetY + decoration.height;

						// Draw multiple crystal spikes
						for (let i = 0; i < 3; i++) {
							const crystalX = centerX + (i - 1) * (decoration.width / 3);
							const crystalHeight = decoration.height * (0.7 + Math.random() * 0.3);

							// Create a crystal color
							const hue = parseInt(decoration.color.substring(1, 3), 16);
							const crystalColor = adjustColorBrightness(decoration.color, i * 15 - 15);

							ctx.fillStyle = crystalColor;
							ctx.beginPath();
							ctx.moveTo(crystalX - decoration.width / 6, bottomY);
							ctx.lineTo(crystalX, bottomY - crystalHeight);
							ctx.lineTo(crystalX + decoration.width / 6, bottomY);
							ctx.closePath();
							ctx.fill();

							// Add crystal shine
							ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
							ctx.lineWidth = 1;
							ctx.beginPath();
							ctx.moveTo(crystalX - decoration.width / 12, bottomY - crystalHeight / 3);
							ctx.lineTo(crystalX, bottomY - crystalHeight * 2/3);
							ctx.stroke();
						}
					}
					else {
						// Mushroom
						const stemX = decoration.x + offsetX + decoration.width / 2;
						const capY = decoration.y + offsetY + decoration.height * 0.4;
						const bottomY = decoration.y + offsetY + decoration.height;

						// Draw stem
						ctx.fillStyle = '#DDDDDD';  // Light stem
						ctx.beginPath();
						ctx.moveTo(stemX - decoration.width / 6, bottomY);
						ctx.lineTo(stemX - decoration.width / 8, capY);
						ctx.lineTo(stemX + decoration.width / 8, capY);
						ctx.lineTo(stemX + decoration.width / 6, bottomY);
						ctx.closePath();
						ctx.fill();

						// Draw cap
						ctx.fillStyle = decoration.color;
						ctx.beginPath();
						ctx.arc(
							stemX,
							capY,
							decoration.width / 2,
							0, Math.PI, true
						);
						ctx.fill();

						// Draw spots on the mushroom cap
						ctx.fillStyle = '#FFFFFF';
						for (let i = 0; i < 3; i++) {
							const spotX = stemX + (i - 1) * decoration.width / 4;
							const spotY = capY - decoration.height / 5;

							ctx.beginPath();
							ctx.arc(spotX, spotY, decoration.width / 10, 0, Math.PI * 2);
							ctx.fill();
						}
					}
				}
			}
		}

		// Draw hazards
		for (const hazard of hazards) {
			if (isOnScreen(hazard)) {
				if (hazard.type === 'spikes') {
					// Draw spiked hazard
					ctx.fillStyle = hazard.color;

					// Draw a row of sharp spikes
					const spikeWidth = hazard.width / 5;
					for (let i = 0; i < 5; i++) {
						const spikeX = hazard.x + offsetX + i * spikeWidth;

						ctx.beginPath();
						ctx.moveTo(spikeX, hazard.y + offsetY + hazard.height);
						ctx.lineTo(spikeX + spikeWidth/2, hazard.y + offsetY);
						ctx.lineTo(spikeX + spikeWidth, hazard.y + offsetY + hazard.height);
						ctx.closePath();
						ctx.fill();

						// Add shine to spikes
						ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(spikeX + spikeWidth * 0.2, hazard.y + offsetY + hazard.height * 0.7);
						ctx.lineTo(spikeX + spikeWidth/2, hazard.y + offsetY + hazard.height * 0.2);
						ctx.stroke();
					}
				} else if (hazard.type === 'lava') {
					// Animate lava with bubbling effect
					const time = Date.now() * 0.003;

					// Create a lava gradient
					const gradient = ctx.createLinearGradient(
						hazard.x + offsetX, hazard.y + offsetY,
						hazard.x + offsetX, hazard.y + offsetY + hazard.height
					);
					gradient.addColorStop(0, '#FF4500');  // Orange-red
					gradient.addColorStop(1, '#8B0000');  // Dark red

					// Draw lava base
					ctx.fillStyle = gradient;
					ctx.fillRect(
						hazard.x + offsetX,
						hazard.y + offsetY,
						hazard.width,
						hazard.height
					);

					// Draw lava bubbles
					ctx.fillStyle = '#FFCC00';  // Bright yellow for bubbles
					for (let i = 0; i < 5; i++) {
						const bubbleSize = 2 + Math.sin(time + i) * 2;
						const x = hazard.x + offsetX + Math.sin(time * 2 + i * 7) * (hazard.width * 0.4) + hazard.width * 0.5;
						const y = hazard.y + offsetY + Math.sin(time * 3 + i * 5) * (hazard.height * 0.3) + hazard.height * 0.5;

						ctx.beginPath();
						ctx.arc(x, y, bubbleSize, 0, Math.PI * 2);
						ctx.fill();
					}

					// Add some glow effect
					ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
					ctx.fillRect(
						hazard.x + offsetX,
						hazard.y + offsetY - 2,
						hazard.width,
						4
					);
				}
			}
		}

		// Draw coins with animation
		for (const coin of coins) {
			if (!coin.collected && isOnScreen(coin)) {
				// Animated coin with wobble and spin
				const wobble = Math.sin(Date.now() * 0.005 + coin.wobble) * 3;
				const spin = Math.sin(Date.now() * 0.004 + coin.wobble);
				const width = coin.width * (0.6 + Math.abs(spin) * 0.4);

				// Create a gold gradient for the coin
				const gradient = ctx.createLinearGradient(
					coin.x + offsetX - width / 2, coin.y + offsetY + wobble,
					coin.x + offsetX + width / 2, coin.y + offsetY + wobble
				);
				gradient.addColorStop(0, '#FFD700');  // Gold
				gradient.addColorStop(0.5, '#FFEC8B');  // Light gold
				gradient.addColorStop(1, '#DAA520');  // Golden yellow

				// Draw coin body
				ctx.fillStyle = gradient;
				ctx.beginPath();
				ctx.ellipse(
					coin.x + offsetX,
					coin.y + offsetY + wobble,
					width,
					coin.height,
					0, 0, Math.PI * 2
				);
				ctx.fill();

				// Add a border to the coin
				ctx.strokeStyle = '#B8860B';  // Dark golden
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.ellipse(
					coin.x + offsetX,
					coin.y + offsetY + wobble,
					width,
					coin.height,
					0, 0, Math.PI * 2
				);
				ctx.stroke();

				// Draw coin shine/highlight
				ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
				ctx.beginPath();
				ctx.ellipse(
					coin.x + offsetX - width/4,
					coin.y + offsetY - coin.height/4 + wobble,
					width/4,
					coin.height/4,
					0, 0, Math.PI * 2
				);
				ctx.fill();
			}
		}

		// Draw special treasures
		for (const treasure of treasures) {
			if (!treasure.collected && isOnScreen(treasure)) {
				// Update rotation animation
				treasure.rotation = (treasure.rotation + 0.02) % (Math.PI * 2);

				// Draw a chest or special item
				if (treasure.special) {
					// Special treasure - golden chest
					const chestX = treasure.x + offsetX;
					const chestY = treasure.y + offsetY;
					const chestWidth = treasure.width * 1.5;
					const chestHeight = treasure.height * 1.2;

					// Draw chest body
					ctx.fillStyle = '#8B4513';  // Brown
					ctx.fillRect(
						chestX,
						chestY,
						chestWidth,
						chestHeight
					);

					// Draw chest top/lid
					ctx.fillStyle = '#A0522D';  // Lighter brown
					ctx.beginPath();
					ctx.moveTo(chestX, chestY);
					ctx.lineTo(chestX + chestWidth, chestY);
					ctx.lineTo(chestX + chestWidth, chestY + chestHeight * 0.3);
					ctx.lineTo(chestX, chestY + chestHeight * 0.3);
					ctx.closePath();
					ctx.fill();

					// Draw chest decorations
					ctx.fillStyle = '#FFD700';  // Gold
					ctx.fillRect(
						chestX + chestWidth * 0.4,
						chestY + chestHeight * 0.4,
						chestWidth * 0.2,
						chestHeight * 0.2
					);

					// Draw chest metal bands
					ctx.strokeStyle = '#B8860B';  // Darker gold
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.rect(chestX, chestY, chestWidth, chestHeight);
					ctx.stroke();

					// Add a pulsing glow effect
					const glowSize = 5 + Math.sin(Date.now() * 0.005) * 2;
					const gradient = ctx.createRadialGradient(
						chestX + chestWidth / 2, chestY + chestHeight / 2, 0,
						chestX + chestWidth / 2, chestY + chestHeight / 2, chestWidth
					);
					gradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
					gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
					gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

					ctx.fillStyle = gradient;
					ctx.fillRect(
						chestX - glowSize,
						chestY - glowSize,
						chestWidth + glowSize * 2,
						chestHeight + glowSize * 2
					);
				} else {
					// Regular treasure - gemstone
					const gemX = treasure.x + offsetX + treasure.width / 2;
					const gemY = treasure.y + offsetY + treasure.height / 2;

					// Draw gem with rotation
					ctx.save();
					ctx.translate(gemX, gemY);
					ctx.rotate(treasure.rotation);

					// Draw a beautiful gem
					ctx.fillStyle = '#00BFFF';  // Deep sky blue
					ctx.beginPath();
					ctx.moveTo(0, -treasure.height / 2);
					ctx.lineTo(treasure.width / 2, 0);
					ctx.lineTo(0, treasure.height / 2);
					ctx.lineTo(-treasure.width / 2, 0);
					ctx.closePath();
					ctx.fill();

					// Add gem shine
					ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
					ctx.beginPath();
					ctx.moveTo(0, -treasure.height / 4);
					ctx.lineTo(treasure.width / 4, 0);
					ctx.lineTo(0, treasure.height / 4);
					ctx.closePath();
					ctx.fill();

					ctx.restore();

					// Add a subtle glow effect
					const pulseIntensity = 0.3 + Math.sin(Date.now() * 0.005) * 0.1;
					ctx.fillStyle = `rgba(0, 191, 255, ${pulseIntensity})`;
					ctx.beginPath();
					ctx.arc(gemX, gemY, treasure.width, 0, Math.PI * 2);
					ctx.fill();
				}
			}
		}

		// Draw goal flag with animation
		if (isOnScreen(goal)) {
			// Wave flag with smooth animation
			const flagWave = Math.sin(Date.now() * 0.003) * 5;
			const flagPole = goal.x + offsetX + goal.width * 0.2;

			// Draw flag pole
			const gradient = ctx.createLinearGradient(
				flagPole, goal.y + offsetY,
				flagPole + goal.width * 0.1, goal.y + offsetY
			);
			gradient.addColorStop(0, '#8B4513');
			gradient.addColorStop(0.5, '#A0522D');
			gradient.addColorStop(1, '#8B4513');

			ctx.fillStyle = gradient;
			ctx.fillRect(
				flagPole - goal.width * 0.05,
				goal.y + offsetY,
				goal.width * 0.1,
				goal.height
			);

			// Draw ornate base
			ctx.fillStyle = '#5D4037';  // Darker brown
			ctx.fillRect(
				flagPole - goal.width * 0.15,
				goal.y + offsetY + goal.height - goal.width * 0.2,
				goal.width * 0.3,
				goal.width * 0.2
			);

			// Draw waving flag with cloth-like effect
			const flagY = goal.y + offsetY;
			const flagWidth = goal.width * 0.8;
			const flagHeight = goal.height * 0.3;

			// Create a flag gradient
			const flagGradient = ctx.createLinearGradient(
				flagPole, flagY,
				flagPole + flagWidth, flagY
			);
			flagGradient.addColorStop(0, '#FF0000');  // Red
			flagGradient.addColorStop(0.6, '#CC0000');  // Darker red
			flagGradient.addColorStop(1, '#880000');  // Darkest red

			ctx.fillStyle = flagGradient;

			// Draw a wavy flag shape
			ctx.beginPath();
			ctx.moveTo(flagPole, flagY);

			// Top edge of flag with wave effect
			for (let i = 0; i <= 10; i++) {
				const waveX = flagPole + (i / 10) * flagWidth;
				const waveAmount = (i / 10) * flagWave;
				const waveY = flagY + Math.sin(i / 3) * waveAmount;

				ctx.lineTo(waveX, waveY);
			}

			// Bottom edge of flag with wave effect (slightly offset)
			for (let i = 10; i >= 0; i--) {
				const waveX = flagPole + (i / 10) * flagWidth;
				const waveAmount = (i / 10) * flagWave;
				const waveY = flagY + flagHeight + Math.sin(i / 3 + 1) * waveAmount;

				ctx.lineTo(waveX, waveY);
			}

			ctx.closePath();
			ctx.fill();

			// Add flag details - star or emblem
			ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
			const starX = flagPole + flagWidth * 0.3;
			const starY = flagY + flagHeight / 2 + Math.sin(1 / 3) * ((0.3 / 10) * flagWave);

			// Draw a star
			drawStar(ctx, starX, starY, 5, flagHeight * 0.2, flagHeight * 0.1);

			// If this is a checkpoint flag before the goal, make it look different
			if (!goal.animate) {
				ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';  // Yellow
				const checkX = flagPole + flagWidth * 0.5;
				const checkY = flagY + flagHeight / 2 + Math.sin(2 / 3) * ((0.5 / 10) * flagWave);

				drawStar(ctx, checkX, checkY, 5, flagHeight * 0.15, flagHeight * 0.07);
			}

			// Add flag shine along the top
			ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(flagPole, flagY + 2);

			// Follow the top wave with a highlight
			for (let i = 0; i <= 10; i += 3) {
				const waveX = flagPole + (i / 10) * flagWidth * 0.7;
				const waveAmount = (i / 10) * flagWave;
				const waveY = flagY + Math.sin(i / 3) * waveAmount + 2;

				ctx.lineTo(waveX, waveY);
			}

			ctx.stroke();

			// Add a gold ornament at the top of the flagpole
			ctx.fillStyle = '#FFD700';
			ctx.beginPath();
			ctx.arc(flagPole, goal.y + offsetY, goal.width * 0.07, 0, Math.PI * 2);
			ctx.fill();
		}

		// Draw enemies
		for (const enemy of enemies) {
			if (isOnScreen(enemy)) {
				// Update animation frame
				enemy.animationFrame = (enemy.animationFrame || 0) + 0.1;

				// Draw enemy based on type and theme
				if (enemy.type === 'flyer') {
					// Draw flying enemy with wings
					const wingOffset = Math.sin(Date.now() * 0.01) * 5;

					// Draw wings
					ctx.fillStyle = adjustColorBrightness(enemy.color, -20);

					// Left wing
					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width/2, enemy.y + offsetY + enemy.height/2);
					ctx.rotate(-Math.PI / 4 + Math.sin(Date.now() * 0.01) * 0.2);

					ctx.beginPath();
					ctx.ellipse(
						-enemy.width * 0.6, 0,
						enemy.width * 0.7, enemy.height * 0.3,
						0, 0, Math.PI * 2
					);
					ctx.fill();
					ctx.restore();

					// Right wing
					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width/2, enemy.y + offsetY + enemy.height/2);
					ctx.rotate(Math.PI / 4 - Math.sin(Date.now() * 0.01) * 0.2);

					ctx.beginPath();
					ctx.ellipse(
						enemy.width * 0.6, 0,
						enemy.width * 0.7, enemy.height * 0.3,
						0, 0, Math.PI * 2
					);
					ctx.fill();
					ctx.restore();

					// Draw body
					ctx.fillStyle = enemy.color;
					ctx.beginPath();
					ctx.ellipse(
						enemy.x + offsetX + enemy.width/2,
						enemy.y + offsetY + enemy.height/2,
						enemy.width/2,
						enemy.height/2,
						0, 0, Math.PI * 2
					);
					ctx.fill();

					// Draw eyes
					const eyeOffset = enemy.direction > 0 ? enemy.width * 0.15 : -enemy.width * 0.15;
					const eyeSize = enemy.width / 5;

					// White of eye
					ctx.fillStyle = 'white';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset,
						enemy.y + offsetY + enemy.height/3,
						eyeSize,
						0, Math.PI * 2
					);
					ctx.fill();

					// Pupil
					ctx.fillStyle = 'black';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset + enemy.direction * eyeSize/2,
						enemy.y + offsetY + enemy.height/3,
						eyeSize/2,
						0, Math.PI * 2
					);
					ctx.fill();

					// Add a tail
					ctx.fillStyle = adjustColorBrightness(enemy.color, 20);
					ctx.beginPath();
					ctx.moveTo(enemy.x + offsetX + enemy.width/2, enemy.y + offsetY + enemy.height * 0.8);
					ctx.lineTo(enemy.x + offsetX + enemy.width/2 - enemy.width * 0.3, enemy.y + offsetY + enemy.height * 1.2);
					ctx.lineTo(enemy.x + offsetX + enemy.width/2 + enemy.width * 0.3, enemy.y + offsetY + enemy.height * 1.2);
					ctx.closePath();
					ctx.fill();
				}
				else if (enemy.type === 'jumper') {
					// Draw a jumper enemy - frog/toad like
					const squishY = enemy.velocityY < 0 ? 0.2 : (enemy.velocityY > 1 ? -0.1 : 0);

					// Draw body
					ctx.fillStyle = enemy.color;
					ctx.beginPath();
					ctx.ellipse(
						enemy.x + offsetX + enemy.width/2,
						enemy.y + offsetY + enemy.height * (0.6 - squishY),
						enemy.width/2,
						enemy.height/2 * (1 + squishY),
						0, 0, Math.PI * 2
					);
					ctx.fill();

					// Draw head
					ctx.beginPath();
					ctx.ellipse(
						enemy.x + offsetX + enemy.width/2 + (enemy.direction * enemy.width * 0.1),
						enemy.y + offsetY + enemy.height * 0.3,
						enemy.width * 0.4,
						enemy.height * 0.3,
						0, 0, Math.PI * 2
					);
					ctx.fill();

					// Draw eyes
					const eyeOffset = enemy.direction * enemy.width * 0.2;
					const eyeY = enemy.y + offsetY + enemy.height * 0.2;

					// Left eye (in direction of travel)
					ctx.fillStyle = 'white';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset + enemy.width * 0.15,
						eyeY,
						enemy.width * 0.1,
						0, Math.PI * 2
					);
					ctx.fill();

					// Pupils
					ctx.fillStyle = 'black';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset + enemy.width * 0.15 + enemy.direction * enemy.width * 0.05,
						eyeY,
						enemy.width * 0.05,
						0, Math.PI * 2
					);
					ctx.fill();

					// Draw legs
					ctx.fillStyle = adjustColorBrightness(enemy.color, -20);

					// Back legs
					const legAngle = Math.sin(enemy.animationFrame * 0.5) * 0.2;

					// Left back leg
					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width * 0.3, enemy.y + offsetY + enemy.height * 0.6);
					ctx.rotate(-Math.PI/4 + legAngle);
					ctx.fillRect(0, 0, enemy.width * 0.1, enemy.height * 0.5);
					ctx.restore();

					// Right back leg
					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width * 0.7, enemy.y + offsetY + enemy.height * 0.6);
					ctx.rotate(Math.PI/4 - legAngle);
					ctx.fillRect(0, 0, enemy.width * 0.1, enemy.height * 0.5);
					ctx.restore();

					// Front legs (smaller)
					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width * 0.35, enemy.y + offsetY + enemy.height * 0.5);
					ctx.rotate(-Math.PI/6 - legAngle);
					ctx.fillRect(0, 0, enemy.width * 0.08, enemy.height * 0.3);
					ctx.restore();

					ctx.save();
					ctx.translate(enemy.x + offsetX + enemy.width * 0.65, enemy.y + offsetY + enemy.height * 0.5);
					ctx.rotate(Math.PI/6 + legAngle);
					ctx.fillRect(0, 0, enemy.width * 0.08, enemy.height * 0.3);
					ctx.restore();
				}
				else {
					// Draw a walker enemy
					const walkOffset = Math.sin(enemy.animationFrame) * 2;

					// Draw body
					ctx.fillStyle = enemy.color;
					ctx.fillRect(
						enemy.x + offsetX,
						enemy.y + offsetY,
						enemy.width,
						enemy.height
					);

					// Draw legs
					ctx.fillStyle = adjustColorBrightness(enemy.color, -30);

					// Front leg
					ctx.fillRect(
						enemy.x + offsetX + (enemy.direction > 0 ? enemy.width * 0.7 : enemy.width * 0.1),
						enemy.y + offsetY + enemy.height,
						enemy.width * 0.2,
						walkOffset
					);

					// Back leg
					ctx.fillRect(
						enemy.x + offsetX + (enemy.direction > 0 ? enemy.width * 0.2 : enemy.width * 0.6),
						enemy.y + offsetY + enemy.height,
						enemy.width * 0.2,
						-walkOffset
					);

					// Draw face direction
					const eyeOffset = enemy.direction > 0 ? enemy.width * 0.2 : -enemy.width * 0.2;
					const eyeSize = enemy.width / 5;

					// Draw eye
					ctx.fillStyle = 'white';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset,
						enemy.y + offsetY + enemy.height/3,
						eyeSize,
						0, Math.PI * 2
					);
					ctx.fill();

					// Draw pupil
					ctx.fillStyle = 'black';
					ctx.beginPath();
					ctx.arc(
						enemy.x + offsetX + enemy.width/2 + eyeOffset + enemy.direction * eyeSize/2,
						enemy.y + offsetY + enemy.height/3,
						eyeSize/2,
						0, Math.PI * 2
					);
					ctx.fill();

					// Draw angry eyebrow
					ctx.strokeStyle = 'black';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(
						enemy.x + offsetX + enemy.width/2 + eyeOffset - eyeSize,
						enemy.y + offsetY + enemy.height/3 - eyeSize
					);
					ctx.lineTo(
						enemy.x + offsetX + enemy.width/2 + eyeOffset + eyeSize,
						enemy.y + offsetY + enemy.height/3 - eyeSize/2
					);
					ctx.stroke();
				}

				// If enemy is invulnerable or in a special state, add visual effect
				if (enemy.invulnerable) {
					ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
					ctx.fillRect(
						enemy.x + offsetX - 5,
						enemy.y + offsetY - 5,
						enemy.width + 10,
						enemy.height + 10
					);
				}
			}
		}

		// Draw particles and update particle emitters
		updateAndDrawParticles(offsetX, offsetY);

		// Draw player with animation
		if (player.invulnerable === 0 || Math.floor(Date.now() / 100) % 2 === 0) {
			// Calculate animation frame for running
			const runFrame = player.velocityX !== 0 ? Math.floor(player.animation % 4) : 0;
			const jumpFrame = player.isJumping ? 1 : 0;

			// Draw player body
			ctx.fillStyle = config.platformer.playerColor;

			// Main body with shadow
			const gradient = ctx.createLinearGradient(
				player.x + offsetX, player.y + offsetY,
				player.x + offsetX + player.width, player.y + offsetY
			);
			gradient.addColorStop(0, player.facing > 0 ? config.platformer.playerColor : adjustColorBrightness(config.platformer.playerColor, -20));
			gradient.addColorStop(1, player.facing > 0 ? adjustColorBrightness(config.platformer.playerColor, -20) : config.platformer.playerColor);

			ctx.fillStyle = gradient;

			// Body shape depends on jumping state
			if (player.isJumping) {
				// Crouched body for jumping
				ctx.fillRect(
					player.x + offsetX,
					player.y + offsetY + jumpFrame * 3,
					player.width,
					player.height - jumpFrame * 3
				);
			} else {
				// Normal body with slight bounce for running
				const bounceOffset = player.velocityX !== 0 ? Math.abs(Math.sin(player.animation * 2)) * 2 : 0;

				ctx.fillRect(
					player.x + offsetX,
					player.y + offsetY - bounceOffset,
					player.width,
					player.height + bounceOffset
				);
			}

			// Draw player face
			const faceOffsetX = player.facing > 0 ? player.width * 0.25 : -player.width * 0.25;

			// Draw eyes
			const eyeSize = player.width / 5;
			ctx.fillStyle = 'white';
			ctx.beginPath();
			ctx.arc(
				player.x + offsetX + player.width/2 + faceOffsetX,
				player.y + offsetY + player.height/3,
				eyeSize,
				0, Math.PI * 2
			);
			ctx.fill();

			// Draw pupil
			ctx.fillStyle = 'black';
			ctx.beginPath();
			ctx.arc(
				player.x + offsetX + player.width/2 + faceOffsetX + player.facing * eyeSize/3,
				player.y + offsetY + player.height/3,
				eyeSize/2,
				0, Math.PI * 2
			);
			ctx.fill();

			// Draw mouth
			if (player.isJumping) {
				// "O" mouth for jumping/effort
				ctx.beginPath();
				ctx.arc(
					player.x + offsetX + player.width/2 + faceOffsetX * 0.5,
					player.y + offsetY + player.height * 0.6,
					eyeSize * 0.6,
					0, Math.PI * 2
				);
				ctx.stroke();
			} else if (player.velocityX !== 0) {
				// Smile for running - slightly open
				ctx.beginPath();
				ctx.arc(
					player.x + offsetX + player.width/2 + faceOffsetX * 0.5,
					player.y + offsetY + player.height * 0.5,
					eyeSize * 0.8,
					0, Math.PI
				);
				ctx.stroke();

				// Add a little open mouth
				ctx.beginPath();
				ctx.ellipse(
					player.x + offsetX + player.width/2 + faceOffsetX * 0.5,
					player.y + offsetY + player.height * 0.5,
					eyeSize * 0.4,
					eyeSize * 0.2,
					0, 0, Math.PI
				);
				ctx.fill();
			} else {
				// Neutral expression for standing
				ctx.beginPath();
				ctx.moveTo(
					player.x + offsetX + player.width/2 + faceOffsetX * 0.5 - eyeSize * 0.6,
					player.y + offsetY + player.height * 0.6
				);
				ctx.lineTo(
					player.x + offsetX + player.width/2 + faceOffsetX * 0.5 + eyeSize * 0.6,
					player.y + offsetY + player.height * 0.6
				);
				ctx.stroke();
			}

			// Draw running animation (legs)
			if (player.velocityX !== 0 && !player.isJumping) {
				const legWidth = player.width * 0.2;
				const legOffset = Math.sin(player.animation * 1.5) * 5;

				ctx.fillRect(
					player.x + offsetX + player.width * 0.25,
					player.y + offsetY + player.height,
					legWidth,
					legOffset
				);

				ctx.fillRect(
					player.x + offsetX + player.width * 0.65,
					player.y + offsetY + player.height,
					legWidth,
					-legOffset
				);
			} else if (player.isJumping) {
				// Draw legs tucked up for jumping
				const legWidth = player.width * 0.2;

				ctx.fillRect(
					player.x + offsetX + player.width * 0.25,
					player.y + offsetY + player.height * 0.8,
					legWidth,
					player.height * 0.2
				);

				ctx.fillRect(
					player.x + offsetX + player.width * 0.65,
					player.y + offsetY + player.height * 0.8,
					legWidth,
					player.height * 0.2
				);
			}

			// Add a little hat or accessory if desired
			ctx.fillStyle = '#FF8800';  // Orange hat
			ctx.beginPath();
			ctx.moveTo(player.x + offsetX + player.width * 0.3, player.y + offsetY);
			ctx.lineTo(player.x + offsetX + player.width * 0.7, player.y + offsetY);
			ctx.lineTo(player.x + offsetX + player.width * 0.5, player.y + offsetY - player.height * 0.3);
			ctx.closePath();
			ctx.fill();

			// Add hat detail
			ctx.strokeStyle = '#CC6600';
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(player.x + offsetX + player.width * 0.4, player.y + offsetY - player.height * 0.1);
			ctx.lineTo(player.x + offsetX + player.width * 0.6, player.y + offsetY - player.height * 0.1);
			ctx.stroke();
		}

		// Draw UI
		drawPlatformerUI();
	}

	/**
	 * Update and draw particles without random elements in rendering
	 */
	function updateAndDrawParticles(offsetX, offsetY) {
		// Update existing particles
		for (let i = particles.length - 1; i >= 0; i--) {
			const p = particles[i];

			// Update particle position and properties
			p.x += p.vx;
			p.y += p.vy;
			p.size *= 0.95;
			p.life--;

			// Skip drawing particles that are offscreen
			if (p.x + offsetX < -20 || p.x + offsetX > canvas.width + 20 ||
				p.y + offsetY < -20 || p.y + offsetY > canvas.height + 20) {
				if (p.life <= 0) {
					particles.splice(i, 1);
				}
				continue;
			}

			// Draw particle with appropriate style
			ctx.globalAlpha = p.life / 60;

			if (p.type === 'sparkle') {
				// Draw a star-like sparkle
				const halfSize = p.size / 2;
				ctx.fillStyle = p.color;

				ctx.beginPath();
				ctx.moveTo(p.x + offsetX, p.y + offsetY - p.size);
				ctx.lineTo(p.x + offsetX + halfSize, p.y + offsetY - halfSize);
				ctx.lineTo(p.x + offsetX + p.size, p.y + offsetY);
				ctx.lineTo(p.x + offsetX + halfSize, p.y + offsetY + halfSize);
				ctx.lineTo(p.x + offsetX, p.y + offsetY + p.size);
				ctx.lineTo(p.x + offsetX - halfSize, p.y + offsetY + halfSize);
				ctx.lineTo(p.x + offsetX - p.size, p.y + offsetY);
				ctx.lineTo(p.x + offsetX - halfSize, p.y + offsetY - halfSize);
				ctx.closePath();
				ctx.fill();
			} else {
				// Draw standard circular particle
				ctx.fillStyle = p.color;
				ctx.beginPath();
				ctx.arc(p.x + offsetX, p.y + offsetY, p.size, 0, Math.PI * 2);
				ctx.fill();
			}

			// Remove dead particles
			if (p.life <= 0) {
				particles.splice(i, 1);
			}
		}

		// Reset alpha
		ctx.globalAlpha = 1;

		// Process particle emitters
		for (const emitter of particleEmitters) {
			// Only emit if on screen
			if (isOnScreen({
				x: emitter.x - 50,
				y: emitter.y - 50,
				width: 100,
				height: 100
			})) {
				// Emit new particles based on rate and time
				// Use a deterministic approach based on time and position
				const time = Date.now();
				const shouldEmit = (time % 1000) / 1000 < emitter.rate;

				if (shouldEmit) {
					const count = 1 + Math.floor((emitter.x % 3));
					for (let i = 0; i < count; i++) {
						const phase = (emitter.x + i * 100) % 628 / 100; // 0 to 2π range
						particles.push({
							x: emitter.x + Math.cos(phase) * 5,
							y: emitter.y + Math.sin(phase) * 5,
							vx: (emitter.speedX || 0) + Math.cos(phase + Math.PI/2) * 0.3,
							vy: (emitter.speedY || 0) + Math.sin(phase + Math.PI/2) * 0.3,
							size: emitter.size * (0.7 + ((emitter.x + i * 7) % 7) / 10),
							color: emitter.color,
							life: emitter.lifetime * (0.8 + ((emitter.x + i * 13) % 5) / 10),
							type: emitter.type
						});
					}
				}
			}
		}
	}

	/**
	 * Draw a themed platform based on its properties without random elements
	 */
	function drawThemedPlatform(platform, offsetX, offsetY) {
		// Base colors by theme
		let base, highlight, shadow;

		switch (platform.theme) {
			case 'forest':
				base = platform.color;
				highlight = adjustColorBrightness(base, 20);
				shadow = adjustColorBrightness(base, -20);
				break;
			case 'desert':
				base = platform.color;
				highlight = adjustColorBrightness(base, 15);
				shadow = adjustColorBrightness(base, -15);
				break;
			case 'mountain':
				base = platform.color;
				highlight = adjustColorBrightness(base, 25);
				shadow = adjustColorBrightness(base, -25);
				break;
			case 'volcano':
				base = platform.color;
				highlight = adjustColorBrightness(base, 30);
				shadow = adjustColorBrightness(base, -30);
				break;
			default:
				base = platform.color || '#8B4513';
				highlight = adjustColorBrightness(base, 20);
				shadow = adjustColorBrightness(base, -20);
		}

		// Draw main platform
		ctx.fillStyle = base;
		ctx.fillRect(
			platform.x + offsetX,
			platform.y + offsetY,
			platform.width,
			platform.height
		);

		// Draw highlight (top edge)
		ctx.fillStyle = highlight;
		ctx.fillRect(
			platform.x + offsetX,
			platform.y + offsetY,
			platform.width,
			platform.height * 0.2
		);

		// Draw shadow (bottom edge)
		ctx.fillStyle = shadow;
		ctx.fillRect(
			platform.x + offsetX,
			platform.y + offsetY + platform.height * 0.8,
			platform.width,
			platform.height * 0.2
		);

		// Draw themed details based on platform type
		if (platform.type === 1) {
			// Forest - add grass/moss
			ctx.fillStyle = '#2D5F3E';  // Dark green

			// Draw small grass clumps
			for (let i = 0; i < 3; i++) {
				const grassX = platform.x + offsetX + (i / 3) * platform.width + platform.width * 0.1;
				const grassWidth = platform.width * 0.2;
				const grassHeight = platform.height * 0.15;

				ctx.beginPath();
				ctx.moveTo(grassX, platform.y + offsetY);
				ctx.lineTo(grassX + grassWidth/2, platform.y + offsetY - grassHeight);
				ctx.lineTo(grassX + grassWidth, platform.y + offsetY);
				ctx.fill();
			}
		}
		else if (platform.type === 2) {
			// Desert - add texture
			ctx.fillStyle = adjustColorBrightness(base, 10);

			// Draw sand ripples
			for (let i = 0; i < 3; i++) {
				const rippleY = platform.y + offsetY + (i / 3) * platform.height + platform.height * 0.2;

				ctx.beginPath();
				ctx.moveTo(platform.x + offsetX, rippleY);
				ctx.quadraticCurveTo(
					platform.x + offsetX + platform.width/2, rippleY - platform.height * 0.05,
					platform.x + offsetX + platform.width, rippleY
				);
				ctx.stroke();
			}
		}
		else if (platform.type === 3) {
			// Mountain - add rocks
			ctx.fillStyle = adjustColorBrightness(base, -10);

			// Draw rock outcroppings
			for (let i = 0; i < 2; i++) {
				const rockX = platform.x + offsetX + platform.width * (0.3 + i * 0.4);
				const rockY = platform.y + offsetY;
				const rockSize = platform.width * 0.15;

				ctx.beginPath();
				ctx.moveTo(rockX, rockY);
				ctx.lineTo(rockX + rockSize, rockY - rockSize);
				ctx.lineTo(rockX + rockSize * 2, rockY);
				ctx.fill();
			}
		}
		else if (platform.type === 4) {
			// Volcano - add lava cracks
			ctx.strokeStyle = '#FF4500';  // Bright orange
			ctx.lineWidth = 2;

			// Draw glowing cracks
			const crackX = platform.x + offsetX + platform.width * 0.3;
			const crackY = platform.y + offsetY;

			ctx.beginPath();
			ctx.moveTo(crackX, crackY);
			ctx.lineTo(crackX + platform.width * 0.1, crackY + platform.height * 0.3);
			ctx.lineTo(crackX + platform.width * 0.3, crackY + platform.height * 0.2);
			ctx.lineTo(crackX + platform.width * 0.4, crackY + platform.height * 0.4);
			ctx.stroke();

			// Add glow
			ctx.strokeStyle = 'rgba(255, 69, 0, 0.3)';
			ctx.lineWidth = 4;
			ctx.stroke();
		}

		// Add a platform edge/border for all types
		ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
		ctx.lineWidth = 1;
		ctx.strokeRect(
			platform.x + offsetX,
			platform.y + offsetY,
			platform.width,
			platform.height
		);
	}

	/**
	 * Draw a star shape
	 */
	function drawStar(ctx, x, y, spikes, outerRadius, innerRadius) {
		let rot = Math.PI / 2 * 3;
		let step = Math.PI / spikes;

		ctx.beginPath();
		ctx.moveTo(x, y - outerRadius);

		for (let i = 0; i < spikes; i++) {
			ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
			rot += step;

			ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
			rot += step;
		}

		ctx.lineTo(x, y - outerRadius);
		ctx.closePath();
		ctx.fill();
	}

	/**
	 * Adjust color brightness
	 */
	function adjustColorBrightness(hex, percent) {
		// Convert hex to RGB
		let r = parseInt(hex.substring(1, 3), 16);
		let g = parseInt(hex.substring(3, 5), 16);
		let b = parseInt(hex.substring(5, 7), 16);

		// Adjust brightness
		r = Math.max(0, Math.min(255, r + percent));
		g = Math.max(0, Math.min(255, g + percent));
		b = Math.max(0, Math.min(255, b + percent));

		// Convert back to hex
		return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
	}

	/**
	 * Draw the platformer UI
	 */
	function drawPlatformerUI() {
		// Draw phase indicator
		ctx.fillStyle = '#ffffff';
		ctx.font = '20px Arial';
		ctx.textAlign = 'center';
		ctx.fillText('PHASE 2: PLAY YOUR LEVEL', canvas.width / 2, 30);

		// Draw stats
		ctx.font = '18px Arial';
		ctx.textAlign = 'left';
		ctx.fillText(`LEVEL: ${gameStats.level}`, 20, 30);

		ctx.textAlign = 'right';
		ctx.fillText(`LIVES: ${gameStats.lives}`, canvas.width - 20, 30);

		ctx.textAlign = 'center';
		ctx.fillText(`SCORE: ${gameStats.score}`, canvas.width / 2, 60);
	}

	/**
	 * Check if an object is visible on screen
	 */
	function isOnScreen(obj) {
		return obj.x + obj.width > camera.x &&
			obj.x < camera.x + canvas.width &&
			obj.y + obj.height > camera.y &&
			obj.y < camera.y + canvas.height;
	}

	/**
	 * Draw the menu screen
	 */
	function drawMenu() {
		// Clear canvas
		ctx.fillStyle = '#333333';
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// Draw title
		ctx.fillStyle = '#ffffff';
		ctx.font = '32px Arial';
		ctx.textAlign = 'center';
		ctx.fillText('TETRIS BLOCK ADVENTURE', canvas.width / 2, canvas.height / 3);

		// Draw instructions
		ctx.font = '20px Arial';
		ctx.fillText('Build in Tetris mode, then play your creation!', canvas.width / 2, canvas.height / 2);

		// Draw start button
		ctx.fillStyle = '#4CAF50';
		const buttonWidth = 200;
		const buttonHeight = 50;
		const buttonX = canvas.width / 2 - buttonWidth / 2;
		const buttonY = canvas.height * 0.7 - buttonHeight / 2;

		ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

		ctx.fillStyle = '#ffffff';
		ctx.font = '24px Arial';
		ctx.fillText('START GAME', canvas.width / 2, canvas.height * 0.7 + 10);

		// Add instruction for how to start
		ctx.font = '16px Arial';
		ctx.fillText('Press ENTER or click/tap button to start', canvas.width / 2, canvas.height * 0.7 + 60);

		// Store button coordinates for click detection
		menuButton = {
			x: buttonX,
			y: buttonY,
			width: buttonWidth,
			height: buttonHeight
		};
	}

	/**
	 * Draw the game over screen
	 */
	function drawGameOver() {
		// Clear canvas
		ctx.fillStyle = '#333333';
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// Draw game over
		ctx.fillStyle = '#ffffff';
		ctx.font = '48px Arial';
		ctx.textAlign = 'center';
		ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 3);

		// Draw final score
		ctx.font = '32px Arial';
		ctx.fillText(`FINAL SCORE: ${gameStats.score}`, canvas.width / 2, canvas.height / 2);

		// Draw levels completed
		ctx.font = '24px Arial';
		ctx.fillText(`LEVELS COMPLETED: ${gameStats.level - 1}`, canvas.width / 2, canvas.height / 2 + 50);

		// Draw play again button
		ctx.fillStyle = '#4CAF50';
		const buttonWidth = 200;
		const buttonHeight = 50;
		const buttonX = canvas.width / 2 - buttonWidth / 2;
		const buttonY = canvas.height * 0.7 - buttonHeight / 2;

		ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

		ctx.fillStyle = '#ffffff';
		ctx.font = '24px Arial';
		ctx.fillText('PLAY AGAIN', canvas.width / 2, canvas.height * 0.7 + 10);

		// Add instruction for how to restart
		ctx.font = '16px Arial';
		ctx.fillText('Press ENTER or click/tap button to restart', canvas.width / 2, canvas.height * 0.7 + 60);

		// Store button coordinates for click detection
		gameOverButton = {
			x: buttonX,
			y: buttonY,
			width: buttonWidth,
			height: buttonHeight
		};
	}

	/**
	 * Main game loop
	 */
	function gameLoop(timestamp) {
		// Update game based on current state
		switch (gameState) {
			case GAME_STATE.MENU:
				drawMenu();
				break;

			case GAME_STATE.TETRIS:
				updateTetris(timestamp);
				drawTetris();
				break;

			case GAME_STATE.PLATFORMER:
				updatePlatformer();
				drawPlatformer();
				break;

			case GAME_STATE.GAME_OVER:
				drawGameOver();
				break;
		}

		// Continue game loop
		requestAnimationFrame(gameLoop);
	}
</script>
</body>
</html>