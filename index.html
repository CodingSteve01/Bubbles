<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Merge</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        :root {
            --bubble-size: 60px;
            --grid-gap: 10px;
        }
        
        .dark {
            --bg-color: #1f2937;
            --text-color: #f3f4f6;
            --grid-color: #374151;
            --bubble-shadow: rgba(0, 0, 0, 0.3);
        }
        
        .light {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --grid-color: #e5e7eb;
            --bubble-shadow: rgba(0, 0, 0, 0.1);
        }
        
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            transition: background-color 0.3s, color 0.3s;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .game-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: var(--grid-gap);
            background-color: var(--grid-color);
            border-radius: 10px;
            padding: var(--grid-gap);
            margin-bottom: 20px;
            position: relative;
        }
        
        .grid-cell {
            width: var(--bubble-size);
            height: var(--bubble-size);
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .bubble {
            width: var(--bubble-size);
            height: var(--bubble-size);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            position: absolute;
            box-shadow: 0 4px 8px var(--bubble-shadow);
            cursor: grab;
            transition: transform 0.1s;
            user-select: none;
            z-index: 1;
        }
        
        .bubble:active {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 10;
        }
        
        .bubble-merge {
            animation: merge 0.3s ease-in-out;
        }
        
        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .bubble-pop {
            animation: pop 0.5s ease-out;
        }
        
        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        .new-bubble-indicator {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            transition: opacity 0.3s;
        }
        
        .points-indicator {
            position: absolute;
            font-weight: bold;
            color: #4ade80;
            animation: float-up 1s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes float-up {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        .surprise-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: var(--bg-color);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        
        .special-bubble {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            border: 2px solid gold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        /* Responsive adjustments */
        @media (max-width: 500px) {
            :root {
                --bubble-size: 50px;
                --grid-gap: 8px;
            }
            
            .game-container {
                padding: 10px;
            }
        }
        
        @media (max-width: 400px) {
            :root {
                --bubble-size: 40px;
                --grid-gap: 6px;
            }
        }
    </style>
</head>
<body :class="theme">
    <div id="app" class="game-container">
        <header class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold">Bubble Merge</h1>
            <div class="flex space-x-2">
                <button @click="toggleTheme" class="p-2 rounded-full" :class="theme === 'dark' ? 'bg-gray-700' : 'bg-gray-200'">
                    <svg v-if="theme === 'dark'" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                    <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                    </svg>
                </button>
                <button @click="switchLanguage" class="p-2 rounded-full" :class="theme === 'dark' ? 'bg-gray-700' : 'bg-gray-200'">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
                    </svg>
                </button>
            </div>
        </header>
        
        <div class="game-stats flex justify-between mb-4">
            <div>
                <div class="text-sm opacity-70">{{ translate({ en: 'Score', de: 'Punktestand' }) }}</div>
                <div class="text-2xl font-bold">{{ score }}</div>
            </div>
            <div>
                <div class="text-sm opacity-70">{{ translate({ en: 'Highest Bubble', de: 'Höchste Blase' }) }}</div>
                <div class="text-2xl font-bold">{{ translate({ en: 'Level', de: 'Level' }) }} {{ highestBubble }}</div>
            </div>
        </div>
        
        <div class="next-bubble mb-4">
            <div class="text-sm opacity-70">{{ translate({ en: 'Next Bubble', de: 'Nächste Blase' }) }}:</div>
            <div class="flex items-center space-x-2">
                <div :style="getBubbleStyle(nextBubble)" class="bubble static">
                    {{ nextBubble }}
                </div>
                <div v-if="specialNextBubble" class="text-sm text-yellow-400">
                    {{ translate({ en: 'Special bubble!', de: 'Spezialblase!' }) }}
                </div>
            </div>
        </div>
        
        <div class="relative">
            <div ref="gameGrid" class="game-grid">
                <div v-for="(cell, index) in gridCells" :key="index" class="grid-cell"></div>
                
                <div v-for="bubble in bubbles" 
                     :key="bubble.id" 
                     :style="getBubblePosition(bubble)"
                     :class="['bubble', {'special-bubble': bubble.isSpecial}]"
                     :style="[getBubblePosition(bubble), getBubbleStyle(bubble.value)]"
                     @mousedown="startDrag($event, bubble)"
                     @touchstart="startDrag($event, bubble)">
                    {{ bubble.value }}
                </div>
                
                <div v-for="indicator in pointsIndicators" 
                     :key="indicator.id"
                     class="points-indicator"
                     :style="{ left: indicator.x + 'px', top: indicator.y + 'px' }">
                    +{{ indicator.points }}
                </div>
                
                <div v-if="showNewBubbleIndicator" class="new-bubble-indicator">
                    {{ translate({ en: 'New bubble added', de: 'Neue Blase erscheint' }) }}
                </div>
            </div>
            
            <div v-if="surprise" class="surprise-effect" :style="surprise.style"></div>
        </div>
        
        <div class="flex justify-between mt-4">
            <button @click="resetGame" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                {{ translate({ en: 'Reset Game', de: 'Neu starten' }) }}
            </button>
            <button @click="showInstructions = true" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                {{ translate({ en: 'Instructions', de: 'Anleitung' }) }}
            </button>
        </div>
        
        <div v-if="gameOver" class="game-over-modal">
            <div class="modal-content">
                <h2 class="text-2xl font-bold mb-4">{{ translate({ en: 'Game Over!', de: 'Spiel vorbei!' }) }}</h2>
                <p class="mb-2">{{ translate({ en: 'Your Score', de: 'Dein Punktestand' }) }}: {{ score }}</p>
                <p class="mb-4">{{ translate({ en: 'Highest Bubble', de: 'Höchste Blase' }) }}: {{ translate({ en: 'Level', de: 'Level' }) }} {{ highestBubble }}</p>
                
                <div v-if="isHighScore" class="bg-yellow-100 text-yellow-800 p-3 rounded-lg mb-4 animate-pulse">
                    {{ translate({ en: 'New High Score!', de: 'Neuer Highscore!' }) }}
                </div>
                
                <button @click="resetGame" class="px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors mb-4 w-full">
                    {{ translate({ en: 'Play Again', de: 'Noch einmal spielen' }) }}
                </button>
                
                <div class="text-center opacity-70 text-sm">
                    {{ translate({ en: 'Tip: Try to create space by combining bubbles strategically!', de: 'Tipp: Versuche strategisch Platz zu schaffen, indem du Blasen kombinierst!' }) }}
                </div>
            </div>
        </div>
        
        <div v-if="showInstructions" class="game-over-modal">
            <div class="modal-content">
                <h2 class="text-2xl font-bold mb-4">{{ translate({ en: 'How to Play', de: 'Spielanleitung' }) }}</h2>
                <ol class="text-left mb-6 space-y-2">
                    <li>1. {{ translate({ en: 'Drag bubbles to move them', de: 'Ziehe Blasen, um sie zu bewegen' }) }}</li>
                    <li>2. {{ translate({ en: 'Merge identical bubbles to combine them', de: 'Verbinde gleiche Blasen, um sie zu verschmelzen' }) }}</li>
                    <li>3. {{ translate({ en: 'Bubbles can merge horizontally, vertically, and diagonally', de: 'Blasen können horizontal, vertikal und diagonal verschmelzen' }) }}</li>
                    <li>4. {{ translate({ en: 'A new bubble appears after each move', de: 'Nach jedem Zug erscheint eine neue Blase' }) }}</li>
                    <li>5. {{ translate({ en: 'Create higher level bubbles for more points', de: 'Bilde möglichst hohe Blasen für mehr Punkte' }) }}</li>
                    <li>6. {{ translate({ en: 'Game ends when the grid is full', de: 'Das Spiel endet, wenn das Feld voll ist' }) }}</li>
                    <li>7. {{ translate({ en: 'Special bubbles appear occasionally with unique effects', de: 'Gelegentlich erscheinen Spezialblasen mit besonderen Effekten' }) }}</li>
                </ol>
                <button @click="showInstructions = false" class="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors w-full">
                    {{ translate({ en: 'Got It!', de: 'Verstanden!' }) }}
                </button>
            </div>
        </div>
    </div>

    <script>
        const { ref, reactive, computed, onMounted, watch } = Vue;
        
        // Localization plugin mock
        const translate = ({ en, de }) => {
            return app.language === 'en' ? en : de;
        };

        const app = Vue.createApp({
            setup() {
                // Game state
                const gridSize = 4;
                const theme = ref('light');
                const language = ref('de');
                const gameGrid = ref(null);
                const bubbles = ref([]);
                const nextBubble = ref(1);
                const specialNextBubble = ref(false);
                const score = ref(0);
                const highestBubble = ref(1);
                const highScore = ref(0);
                const gameOver = ref(false);
                const isHighScore = ref(false);
                const showInstructions = ref(false);
                const showNewBubbleIndicator = ref(false);
                const pointsIndicators = ref([]);
                const surprise = ref(null);
                const draggingBubble = ref(null);
                const bubbleStartPos = { x: 0, y: 0 };
                const pointerStartPos = { x: 0, y: 0 };
                const gridCells = Array(gridSize * gridSize).fill(null);
                const specialBubbleChance = 0.1; // 10% chance for special bubble
                const movesUntilSpecialBubble = ref(Math.floor(Math.random() * 5) + 5); // 5-10 moves
                const movesCount = ref(0);
                
                // Game difficulty and progression
                const difficultyLevel = ref(1);
                const consecutiveMerges = ref(0);
                const lastMoveTime = ref(Date.now());
                const bubbleColors = {
                    1: { bg: '#FF9AA2', text: '#000' },
                    2: { bg: '#FFB7B2', text: '#000' },
                    3: { bg: '#FFDAC1', text: '#000' },
                    4: { bg: '#E2F0CB', text: '#000' },
                    5: { bg: '#B5EAD7', text: '#000' },
                    6: { bg: '#C7CEEA', text: '#000' },
                    7: { bg: '#B7B6F9', text: '#000' },
                    8: { bg: '#9FA0FF', text: '#fff' },
                    9: { bg: '#818DFF', text: '#fff' },
                    10: { bg: '#6D7DFF', text: '#fff' },
                    11: { bg: '#5E6DFF', text: '#fff' },
                    12: { bg: '#4E5DFF', text: '#fff' },
                    13: { bg: '#3F4FF4', text: '#fff' },
                    14: { bg: '#2F3FE9', text: '#fff' },
                    15: { bg: '#1F2FDF', text: '#fff' },
                    16: { bg: '#102BD4', text: '#fff' }
                };
                
                // Load game from local storage
                const loadGame = () => {
                    try {
                        const savedGame = localStorage.getItem('bubbleMergeGame');
                        if (savedGame) {
                            const gameData = JSON.parse(savedGame);
                            bubbles.value = gameData.bubbles || [];
                            nextBubble.value = gameData.nextBubble || 1;
                            score.value = gameData.score || 0;
                            highestBubble.value = gameData.highestBubble || 1;
                            highScore.value = gameData.highScore || 0;
                            difficultyLevel.value = gameData.difficultyLevel || 1;
                            theme.value = gameData.theme || 'light';
                            language.value = gameData.language || 'de';
                            
                            // Add IDs if they're missing (for backward compatibility)
                            bubbles.value.forEach((bubble, index) => {
                                if (!bubble.id) bubble.id = Date.now() + index;
                            });
                        } else {
                            initializeGame();
                        }
                    } catch (error) {
                        console.error("Error loading game: ", error);
                        initializeGame();
                    }
                };
                
                // Save game to local storage
                const saveGame = () => {
                    try {
                        const gameData = {
                            bubbles: bubbles.value,
                            nextBubble: nextBubble.value,
                            score: score.value,
                            highestBubble: highestBubble.value,
                            highScore: highScore.value,
                            difficultyLevel: difficultyLevel.value,
                            theme: theme.value,
                            language: language.value
                        };
                        localStorage.setItem('bubbleMergeGame', JSON.stringify(gameData));
                    } catch (error) {
                        console.error("Error saving game: ", error);
                    }
                };
                
                // Initialize game
                const initializeGame = () => {
                    bubbles.value = [];
                    nextBubble.value = getNextBubbleValue();
                    specialNextBubble.value = false;
                    score.value = 0;
                    highestBubble.value = 1;
                    difficultyLevel.value = 1;
                    consecutiveMerges.value = 0;
                    gameOver.value = false;
                    movesCount.value = 0;
                    
                    // Add initial bubbles
                    for (let i = 0; i < 3; i++) {
                        addRandomBubble();
                    }
                    
                    // Initialize next bubble
                    updateNextBubble();
                };
                
                // Reset game
                const resetGame = () => {
                    initializeGame();
                    saveGame();
                    gameOver.value = false;
                };
                
                // Generate next bubble value based on difficulty
                const getNextBubbleValue = () => {
                    // As game progresses, increase chances of higher numbers
                    const baseValue = Math.random() < 0.7 ? 1 : 2;
                    
                    // Higher chance for level 2 bubbles as difficulty increases
                    if (difficultyLevel.value > 3 && Math.random() < 0.2) {
                        return 2;
                    }
                    
                    // Tiny chance for level 3 bubble in higher difficulties
                    if (difficultyLevel.value > 5 && Math.random() < 0.05) {
                        return 3;
                    }
                    
                    return baseValue;
                };
                
                // Update next bubble
                const updateNextBubble = () => {
                    nextBubble.value = getNextBubbleValue();
                    
                    // Check if it's time for a special bubble
                    movesCount.value++;
                    movesUntilSpecialBubble.value--;
                    
                    if (movesUntilSpecialBubble.value <= 0 && Math.random() < specialBubbleChance) {
                        specialNextBubble.value = true;
                        movesUntilSpecialBubble.value = Math.floor(Math.random() * 10) + 10; // Reset counter
                    } else {
                        specialNextBubble.value = false;
                    }
                };
                
                // Add random bubble to the grid
                const addRandomBubble = () => {
                    if (isBoardFull()) {
                        gameOver.value = true;
                        checkHighScore();
                        return;
                    }
                    
                    // Find empty cells
                    const emptyCells = [];
                    
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            const isEmpty = !bubbles.value.some(b => b.row === row && b.col === col);
                            if (isEmpty) {
                                emptyCells.push({ row, col });
                            }
                        }
                    }
                    
                    if (emptyCells.length === 0) return;
                    
                    // Select random empty cell
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    
                    // Add new bubble
                    const newBubble = {
                        id: Date.now(),
                        value: nextBubble.value,
                        row: randomCell.row,
                        col: randomCell.col,
                        isNew: true,
                        isSpecial: specialNextBubble.value
                    };
                    
                    bubbles.value.push(newBubble);
                    showNewBubbleIndicator.value = true;
                    
                    // Hide new bubble indicator after 1 second
                    setTimeout(() => {
                        showNewBubbleIndicator.value = false;
                    }, 1000);
                    
                    // Update next bubble
                    updateNextBubble();
                    
                    // Save game state
                    saveGame();
                    
                    // Check for game over
                    if (isBoardFull() && !hasPossibleMoves()) {
                        gameOver.value = true;
                        checkHighScore();
                    }
                };
                
                // Check if the board is full
                const isBoardFull = () => {
                    return bubbles.value.length >= gridSize * gridSize;
                };
                
                // Check if there are possible moves (same-value bubbles adjacent)
                const hasPossibleMoves = () => {
                    for (let i = 0; i < bubbles.value.length; i++) {
                        const bubble = bubbles.value[i];
                        
                        // Check all 8 directions (horizontal, vertical, diagonal)
                        const directions = [
                            { dr: -1, dc: 0 },  // up
                            { dr: 1, dc: 0 },   // down
                            { dr: 0, dc: -1 },  // left
                            { dr: 0, dc: 1 },   // right
                            { dr: -1, dc: -1 }, // up-left
                            { dr: -1, dc: 1 },  // up-right
                            { dr: 1, dc: -1 },  // down-left
                            { dr: 1, dc: 1 }    // down-right
                        ];
                        
                        for (const dir of directions) {
                            const newRow = bubble.row + dir.dr;
                            const newCol = bubble.col + dir.dc;
                            
                            // Check if the new position is valid
                            if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                                // Find if there's a bubble at this position
                                const adjacentBubble = bubbles.value.find(b => b.row === newRow && b.col === newCol);
                                
                                // If there's a bubble with the same value, there's a possible move
                                if (adjacentBubble && adjacentBubble.value === bubble.value) {
                                    return true;
                                }
                            }
                        }
                    }
                    
                    return false;
                };
                
                // Check for high score
                const checkHighScore = () => {
                    if (score.value > highScore.value) {
                        highScore.value = score.value;
                        isHighScore.value = true;
                        saveGame();
                    } else {
                        isHighScore.value = false;
                    }
                };
                
                // Toggle theme
                const toggleTheme = () => {
                    theme.value = theme.value === 'light' ? 'dark' : 'light';
                    saveGame();
                };
                
                // Switch language
                const switchLanguage = () => {
                    language.value = language.value === 'de' ? 'en' : 'de';
                    saveGame();
                };
                
                // Get bubble style based on value
                const getBubbleStyle = (value) => {
                    const color = bubbleColors[value] || { bg: '#555', text: '#fff' };
                    return {
                        backgroundColor: color.bg,
                        color: color.text
                    };
                };
                
                // Get bubble position
                const getBubblePosition = (bubble) => {
                    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-size'));
                    const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));
                    
                    // Calculate position based on row and column
                    const x = bubble.col * (cellSize + gridGap) + gridGap;
                    const y = bubble.row * (cellSize + gridGap) + gridGap;
                    
                    // If being dragged, use the drag position
                    if (draggingBubble.value && draggingBubble.value.id === bubble.id) {
                        const rect = gameGrid.value.getBoundingClientRect();
                        const dragX = bubble.dragX - rect.left;
                        const dragY = bubble.dragY - rect.top;
                        
                        return {
                            transform: `translate(${dragX}px, ${dragY}px)`,
                            zIndex: '100'
                        };
                    }
                    
                    return {
                        transform: `translate(${x}px, ${y}px)`
                    };
                };
                
                // Start dragging a bubble
                const startDrag = (event, bubble) => {
                    // Prevent default to avoid browser drag behavior
                    event.preventDefault();
                    
                    // Get touch or mouse position
                    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                    
                    const rect = gameGrid.value.getBoundingClientRect();
                    const gridX = clientX - rect.left;
                    const gridY = clientY - rect.top;
                    
                    // Set up dragging state
                    draggingBubble.value = bubble;
                    draggingBubble.value.dragX = clientX;
                    draggingBubble.value.dragY = clientY;
                    
                    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-size'));
                    const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));
                    
                    // Store starting position
                    bubbleStartPos.x = bubble.col * (cellSize + gridGap) + gridGap;
                    bubbleStartPos.y = bubble.row * (cellSize + gridGap) + gridGap;
                    pointerStartPos.x = gridX;
                    pointerStartPos.y = gridY;
                    
                    // Add event listeners for drag and end
                    if (event.touches) {
                        window.addEventListener('touchmove', dragMove);
                        window.addEventListener('touchend', dragEnd);
                    } else {
                        window.addEventListener('mousemove', dragMove);
                        window.addEventListener('mouseup', dragEnd);
                    }
                };
                
                // Handle drag movement
                const dragMove = (event) => {
                    if (!draggingBubble.value) return;
                    
                    // Get touch or mouse position
                    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                    
                    // Update bubble position
                    draggingBubble.value.dragX = clientX;
                    draggingBubble.value.dragY = clientY;
                };
                
                // End dragging
                const dragEnd = (event) => {
                    if (!draggingBubble.value) return;
                    
                    // Remove event listeners
                    window.removeEventListener('mousemove', dragMove);
                    window.removeEventListener('mouseup', dragEnd);
                    window.removeEventListener('touchmove', dragMove);
                    window.removeEventListener('touchend', dragEnd);
                    
                    // Get the grid rectangle
                    const rect = gameGrid.value.getBoundingClientRect();
                    
                    // Get the final mouse/touch position relative to the grid
                    const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
                    const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
                    const gridX = clientX - rect.left;
                    const gridY = clientY - rect.top;
                    
                    // Calculate cell size and grid gap
                    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-size'));
                    const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));
                    
                    // Calculate the row and column based on position
                    const col = Math.floor((gridX - gridGap) / (cellSize + gridGap));
                    const row = Math.floor((gridY - gridGap) / (cellSize + gridGap));
                    
                    // Validate new position is within grid bounds
                    if (col >= 0 && col < gridSize && row >= 0 && row < gridSize) {
                        // Check if the cell is empty
                        const targetCell = bubbles.value.find(b => b.row === row && b.col === col && b.id !== draggingBubble.value.id);
                        
                        if (!targetCell) {
                            // Move the bubble to the new position
                            const oldRow = draggingBubble.value.row;
                            const oldCol = draggingBubble.value.col;
                            draggingBubble.value.row = row;
                            draggingBubble.value.col = col;
                            
                            // Only count as a move if the bubble actually moved
                            if (oldRow !== row || oldCol !== col) {
                                // Check for merges after moving
                                checkForMerges(draggingBubble.value);
                                
                                // Record move time for pace calculation
                                const currentTime = Date.now();
                                const timeDiff = currentTime - lastMoveTime.value;
                                lastMoveTime.value = currentTime;
                                
                                // Adjust difficulty based on move pace and game progression
                                adjustDifficulty(timeDiff);
                                
                                // Add a new bubble after each move
                                addRandomBubble();
                            }
                        } else if (targetCell.value === draggingBubble.value.value) {
                            // Merge bubbles if they have the same value
                            mergeBubbles(draggingBubble.value, targetCell);
                        }
                    }
                    
                    // Clear dragging state
                    draggingBubble.value = null;
                };
                
                // Check for potential merges after a move
                const checkForMerges = (bubble) => {
                    // Direction vectors for all 8 directions
                    const directions = [
                        { dr: -1, dc: 0 },  // up
                        { dr: 1, dc: 0 },   // down
                        { dr: 0, dc: -1 },  // left
                        { dr: 0, dc: 1 },   // right
                        { dr: -1, dc: -1 }, // up-left
                        { dr: -1, dc: 1 },  // up-right
                        { dr: 1, dc: -1 },  // down-left
                        { dr: 1, dc: 1 }    // down-right
                    ];
                    
                    let mergeFound = false;
                    
                    // Check all 8 directions for potential merges
                    for (const dir of directions) {
                        const newRow = bubble.row + dir.dr;
                        const newCol = bubble.col + dir.dc;
                        
                        // Validate position is within grid
                        if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                            // Find if there's a bubble at this position
                            const adjacentBubble = bubbles.value.find(b => 
                                b.row === newRow && 
                                b.col === newCol && 
                                b.id !== bubble.id
                            );
                            
                            // If there's a bubble with the same value, merge them
                            if (adjacentBubble && adjacentBubble.value === bubble.value) {
                                mergeBubbles(bubble, adjacentBubble);
                                mergeFound = true;
                                break;
                            }
                        }
                    }
                    
                    // Update consecutive merges counter
                    if (mergeFound) {
                        consecutiveMerges.value++;
                    } else {
                        consecutiveMerges.value = 0;
                    }
                    
                    return mergeFound;
                };
                
                // Merge two bubbles
                const mergeBubbles = (bubble1, bubble2) => {
                    // Remove the second bubble
                    bubbles.value = bubbles.value.filter(b => b.id !== bubble2.id);
                    
                    // Update the value of the first bubble
                    bubble1.value++;
                    
                    // Check if this is a special bubble
                    if (bubble1.isSpecial || bubble2.isSpecial) {
                        handleSpecialBubbleMerge(bubble1);
                    }
                    
                    // Add merge animation class
                    bubble1.merging = true;
                    setTimeout(() => {
                        const index = bubbles.value.findIndex(b => b.id === bubble1.id);
                        if (index !== -1) {
                            bubbles.value[index].merging = false;
                        }
                    }, 300);
                    
                    // Update highest bubble value
                    if (bubble1.value > highestBubble.value) {
                        highestBubble.value = bubble1.value;
                        
                        // Show surprise effect for milestone bubbles
                        if (bubble1.value >= 8 && bubble1.value % 2 === 0) {
                            showMilestoneSurprise(bubble1);
                        }
                    }
                    
                    // Calculate points
                    const points = Math.pow(2, bubble1.value);
                    score.value += points;
                    
                    // Show points indicator
                    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-size'));
                    const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap'));
                    const x = bubble1.col * (cellSize + gridGap) + gridGap + cellSize / 2;
                    const y = bubble1.row * (cellSize + gridGap) + gridGap;
                    
                    pointsIndicators.value.push({
                        id: Date.now(),
                        points,
                        x,
                        y
                    });
                    
                    // Remove points indicator after animation
                    setTimeout(() => {
                        pointsIndicators.value.shift();
                    }, 1000);
                    
                    // Check for chain reactions (bubbles that can now be merged)
                    setTimeout(() => {
                        checkForMerges(bubble1);
                    }, 300);
                    
                    // Save game state
                    saveGame();
                };
                
                // Handle special bubble merge effects
                const handleSpecialBubbleMerge = (bubble) => {
                    // Mark as no longer special
                    bubble.isSpecial = false;
                    
                    // Determine a random special effect
                    const effectType = Math.floor(Math.random() * 4);
                    
                    switch (effectType) {
                        case 0: // Clear same-value bubbles
                            clearSameValueBubbles(bubble);
                            break;
                        case 1: // Clear row/column
                            clearRowOrColumn(bubble);
                            break;
                        case 2: // Power up a random bubble
                            powerUpRandomBubble();
                            break;
                        case 3: // Extra points
                            awardBonusPoints();
                            break;
                    }
                };
                
                // Clear all bubbles with the same value
                const clearSameValueBubbles = (bubble) => {
                    const value = bubble.value;
                    const bubblesToRemove = bubbles.value.filter(b => 
                        b.id !== bubble.id && b.value === value
                    );
                    
                    // Award points for each removed bubble
                    let bonusPoints = 0;
                    bubblesToRemove.forEach(b => {
                        bonusPoints += Math.pow(2, b.value);
                        showPopAnimation(b);
                    });
                    
                    // Show surprise message
                    showSurpriseEffect(translate({ 
                        en: 'All level ' + value + ' bubbles cleared!', 
                        de: 'Alle Level ' + value + ' Blasen gelöscht!'
                    }));
                    
                    // Remove bubbles after animation
                    setTimeout(() => {
                        bubbles.value = bubbles.value.filter(b => 
                            bubblesToRemove.findIndex(rb => rb.id === b.id) === -1
                        );
                        
                        // Add bonus points
                        score.value += bonusPoints;
                        
                        // Show bonus points indicator
                        if (bonusPoints > 0) {
                            pointsIndicators.value.push({
                                id: Date.now(),
                                points: bonusPoints,
                                x: 100,
                                y: 100
                            });
                            
                            setTimeout(() => {
                                pointsIndicators.value.shift();
                            }, 1000);
                        }
                    }, 500);
                };
                
                // Clear row or column containing the bubble
                const clearRowOrColumn = (bubble) => {
                    const isRow = Math.random() < 0.5;
                    const bubblesToRemove = isRow
                        ? bubbles.value.filter(b => b.id !== bubble.id && b.row === bubble.row)
                        : bubbles.value.filter(b => b.id !== bubble.id && b.col === bubble.col);
                    
                    // Award points for each removed bubble
                    let bonusPoints = 0;
                    bubblesToRemove.forEach(b => {
                        bonusPoints += Math.pow(2, b.value);
                        showPopAnimation(b);
                    });
                    
                    // Show surprise message
                    showSurpriseEffect(translate({ 
                        en: isRow ? 'Row cleared!' : 'Column cleared!', 
                        de: isRow ? 'Reihe gelöscht!' : 'Spalte gelöscht!'
                    }));
                    
                    // Remove bubbles after animation
                    setTimeout(() => {
                        bubbles.value = bubbles.value.filter(b => 
                            bubblesToRemove.findIndex(rb => rb.id === b.id) === -1
                        );
                        
                        // Add bonus points
                        score.value += bonusPoints;
                        
                        // Show bonus points indicator
                        if (bonusPoints > 0) {
                            pointsIndicators.value.push({
                                id: Date.now(),
                                points: bonusPoints,
                                x: 100,
                                y: 100
                            });
                            
                            setTimeout(() => {
                                pointsIndicators.value.shift();
                            }, 1000);
                        }
                    }, 500);
                };
                
                // Power up a random bubble (increase its value by 1)
                const powerUpRandomBubble = () => {
                    if (bubbles.value.length < 2) return;
                    
                    // Select a random bubble excluding the one just merged
                    const eligibleBubbles = bubbles.value.filter(b => !b.isSpecial);
                    if (eligibleBubbles.length === 0) return;
                    
                    const randomIndex = Math.floor(Math.random() * eligibleBubbles.length);
                    const bubbleToUpgrade = eligibleBubbles[randomIndex];
                    
                    // Upgrade the bubble
                    const index = bubbles.value.findIndex(b => b.id === bubbleToUpgrade.id);
                    if (index !== -1) {
                        bubbles.value[index].value++;
                        bubbles.value[index].poweringUp = true;
                        
                        // Update highest bubble if needed
                        if (bubbles.value[index].value > highestBubble.value) {
                            highestBubble.value = bubbles.value[index].value;
                        }
                        
                        // Show animation
                        setTimeout(() => {
                            if (index < bubbles.value.length) {
                                bubbles.value[index].poweringUp = false;
                            }
                        }, 500);
                        
                        // Show surprise message
                        showSurpriseEffect(translate({ 
                            en: 'Random bubble upgraded!', 
                            de: 'Zufällige Blase aufgewertet!'
                        }));
                    }
                };
                
                // Award bonus points
                const awardBonusPoints = () => {
                    const bonusMultiplier = Math.floor(Math.random() * 3) + 2; // 2x to 4x
                    const basePoints = Math.pow(2, highestBubble.value);
                    const bonusPoints = basePoints * bonusMultiplier;
                    
                    // Add points
                    score.value += bonusPoints;
                    
                    // Show bonus points indicator in center
                    pointsIndicators.value.push({
                        id: Date.now(),
                        points: bonusPoints,
                        x: 100,
                        y: 100
                    });
                    
                    setTimeout(() => {
                        pointsIndicators.value.shift();
                    }, 1000);
                    
                    // Show surprise message
                    showSurpriseEffect(translate({ 
                        en: bonusMultiplier + 'x points bonus!', 
                        de: bonusMultiplier + 'x Punkte Bonus!'
                    }));
                };
                
                // Show pop animation for a bubble
                const showPopAnimation = (bubble) => {
                    const index = bubbles.value.findIndex(b => b.id === bubble.id);
                    if (index !== -1) {
                        bubbles.value[index].popping = true;
                    }
                };
                
                // Show milestone surprise effect
                const showMilestoneSurprise = (bubble) => {
                    const messages = {
                        8: { en: 'Great job! Level 8 reached!', de: 'Super! Level 8 erreicht!' },
                        10: { en: 'Amazing! Level 10!', de: 'Fantastisch! Level 10!' },
                        12: { en: 'Incredible! Level 12!', de: 'Unglaublich! Level 12!' },
                        14: { en: 'Magnificent! Level 14!', de: 'Großartig! Level 14!' },
                        16: { en: 'Legendary! Level 16!', de: 'Legendär! Level 16!' }
                    };
                    
                    const message = messages[bubble.value] || 
                        { en: 'New high level!', de: 'Neues hohes Level!' };
                    
                    showSurpriseEffect(translate(message));
                    
                    // Add confetti effect for high levels
                    if (bubble.value >= 10) {
                        showConfetti();
                    }
                };
                
                // Show surprise effect with message
                const showSurpriseEffect = (message) => {
                    surprise.value = {
                        message,
                        style: {
                            textAlign: 'center',
                            padding: '20px',
                            fontSize: '1.5rem',
                            fontWeight: 'bold',
                            color: '#FFD700',
                            textShadow: '0 0 10px rgba(255, 215, 0, 0.8)',
                            animation: 'fadeInOut 2s forwards'
                        }
                    };
                    
                    // Add style for animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes fadeInOut {
                            0% { opacity: 0; transform: scale(0.5); }
                            20% { opacity: 1; transform: scale(1.2); }
                            70% { opacity: 1; transform: scale(1); }
                            100% { opacity: 0; transform: scale(1.1); }
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Remove surprise after animation
                    setTimeout(() => {
                        surprise.value = null;
                        document.head.removeChild(style);
                    }, 2000);
                };
                
                // Show confetti celebration effect
                const showConfetti = () => {
                    const confettiCount = 100;
                    const container = document.createElement('div');
                    container.className = 'surprise-effect';
                    
                    for (let i = 0; i < confettiCount; i++) {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.cssText = `
                            position: absolute;
                            width: ${Math.random() * 10 + 5}px;
                            height: ${Math.random() * 10 + 5}px;
                            background-color: hsl(${Math.random() * 360}, 100%, 70%);
                            top: -10px;
                            left: ${Math.random() * 100}%;
                            opacity: ${Math.random() * 0.5 + 0.5};
                            animation: confetti-fall ${Math.random() * 2 + 2}s linear forwards;
                        `;
                        container.appendChild(confetti);
                    }
                    
                    // Add style for animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes confetti-fall {
                            0% { transform: translateY(0) rotate(0deg); }
                            100% { transform: translateY(${window.innerHeight}px) rotate(${Math.random() * 360}deg); }
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Add to body and remove after animation
                    document.body.appendChild(container);
                    setTimeout(() => {
                        document.body.removeChild(container);
                        document.head.removeChild(style);
                    }, 4000);
                };
                
                // Adjust difficulty based on gameplay
                const adjustDifficulty = (timeDiff) => {
                    // Increase difficulty based on highest bubble and score
                    const baseDifficulty = Math.floor(highestBubble.value / 2);
                    const scoreDifficulty = Math.floor(score.value / 1000);
                    
                    // Consider move pace (faster moves = higher skill)
                    const paceModifier = timeDiff < 1000 ? 1 : 0;
                    
                    // Consider consecutive merges (combo bonus)
                    const comboModifier = Math.min(consecutiveMerges.value, 3);
                    
                    // Calculate new difficulty
                    const newDifficulty = baseDifficulty + scoreDifficulty + paceModifier + comboModifier;
                    difficultyLevel.value = Math.max(1, Math.min(10, newDifficulty));
                };
                
                // Load game on mount
                onMounted(() => {
                    loadGame();
                    
                    // Fall back to initializing game if loading failed
                    if (bubbles.value.length === 0) {
                        initializeGame();
                    }
                });
                
                // Watch for game state changes
                watch([bubbles, score, highestBubble], () => {
                    if (!gameOver.value) {
                        saveGame();
                    }
                });
                
                return {
                    theme,
                    language,
                    gameGrid,
                    gridCells,
                    bubbles,
                    nextBubble,
                    specialNextBubble,
                    score,
                    highestBubble,
                    gameOver,
                    isHighScore,
                    showInstructions,
                    showNewBubbleIndicator,
                    pointsIndicators,
                    surprise,
                    translate,
                    toggleTheme,
                    switchLanguage,
                    resetGame,
                    startDrag,
                    getBubbleStyle,
                    getBubblePosition
                };
            }
        });
        
        app.config.globalProperties.translate = translate;
        app.mount('#app');
    </script>
</body>
</html>
