<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Merge</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Animation für Blasen */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        .pop-animation {
            animation: pop 0.3s ease-in-out;
        }
        
        .appear-animation {
            animation: appear 0.3s ease-in-out;
        }
        
        .merge-animation {
            animation: merge 0.4s ease-in-out;
        }
        
        .shake-animation {
            animation: shake 0.5s ease-in-out;
        }
        
        .transition-all {
            transition: all 0.3s ease;
        }
        
        /* Farben für verschiedene Bubble-Level */
        .bubble-0 { background-color: #f3f4f6; color: #1f2937; }
        .bubble-1 { background-color: #93c5fd; color: #1e3a8a; }
        .bubble-2 { background-color: #60a5fa; color: #1e3a8a; }
        .bubble-3 { background-color: #3b82f6; color: #ffffff; }
        .bubble-4 { background-color: #2563eb; color: #ffffff; }
        .bubble-5 { background-color: #1d4ed8; color: #ffffff; }
        .bubble-6 { background-color: #1e40af; color: #ffffff; }
        .bubble-7 { background-color: #7c3aed; color: #ffffff; }
        .bubble-8 { background-color: #6d28d9; color: #ffffff; }
        .bubble-9 { background-color: #5b21b6; color: #ffffff; }
        .bubble-10 { background-color: #4c1d95; color: #ffffff; }
        .bubble-11 { background-color: #db2777; color: #ffffff; }
        .bubble-12 { background-color: #be185d; color: #ffffff; }
        .bubble-13 { background-color: #9d174d; color: #ffffff; }
        .bubble-14 { background-color: #831843; color: #ffffff; }
        .bubble-15 { background-color: #f59e0b; color: #ffffff; }
        .bubble-16 { background-color: #d97706; color: #ffffff; }
        .bubble-special { background: linear-gradient(45deg, #f59e0b, #d97706, #9d174d, #7c3aed, #2563eb); color: #ffffff; }
        
        .dark .bubble-0 { background-color: #374151; color: #f3f4f6; }
        
        /* Glassmorphism für die Spielfläche */
        .glassmorphism {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .dark .glassmorphism {
            background: rgba(17, 24, 39, 0.75);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(55, 65, 81, 0.18);
        }
        
        /* Hintergrund-Muster */
        .bg-pattern {
            background-image: radial-gradient(rgba(148, 163, 184, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .dark .bg-pattern {
            background-image: radial-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 min-h-screen transition-all bg-pattern">
    <div id="app" class="container mx-auto px-4 py-8 max-w-md">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold mb-2 text-gray-800 dark:text-white">{{ translate('gameTitle') }}</h1>
            <div class="flex justify-center gap-2 mb-4">
                <button @click="toggleTheme" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200">
                    <svg v-if="isDarkMode" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path>
                    </svg>
                    <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                    </svg>
                </button>
                <button @click="toggleLanguage" class="py-1 px-3 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200 text-sm font-medium">
                    {{ language === 'de' ? 'EN' : 'DE' }}
                </button>
            </div>
            <div class="flex justify-between items-center mb-2 mx-2">
                <div class="text-xl font-semibold text-gray-700 dark:text-gray-300">
                    {{ translate('score') }}: {{ score }}
                </div>
                <div class="text-xl font-semibold text-gray-700 dark:text-gray-300">
                    {{ translate('highestBubble') }}: {{ translate('level') }} {{ highestLevel }}
                </div>
            </div>
            <div class="glassmorphism p-4 mb-4">
                <div class="text-lg font-medium text-gray-700 dark:text-gray-300">
                    {{ translate('nextBubble') }}:
                </div>
                <div class="flex justify-center mt-2">
                    <div :class="['bubble-' + nextBubble, 'w-12 h-12 rounded-full flex items-center justify-center font-bold text-lg shadow-lg']">
                        {{ nextBubble }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Board -->
        <div class="glassmorphism p-4 rounded-lg mb-4">
            <div class="grid grid-cols-5 gap-2 relative" :class="{'shake-animation': isShaking}">
                <template v-for="(cell, index) in gameBoard" :key="index">
                    <div 
                        class="aspect-square rounded-full cursor-pointer flex items-center justify-center transition-all shadow-md relative"
                        :class="[
                            cell ? 'bubble-' + cell.value : 'bg-gray-200 dark:bg-gray-700', 
                            cell?.isNew ? 'appear-animation' : '',
                            cell?.isMerged ? 'merge-animation' : '',
                            cell?.isPopping ? 'pop-animation' : ''
                        ]"
                        @click="selectBubble(index)"
                        @mouseenter="highlightMoves(index)"
                        @mouseleave="clearHighlights()"
                    >
                        <span v-if="cell" class="font-bold text-lg">{{ cell.value }}</span>
                        <div v-if="selectedBubbleIndex === index" class="absolute inset-0 border-2 border-yellow-500 rounded-full"></div>
                        <div v-if="highlightedCells.includes(index)" class="absolute inset-0 bg-yellow-500 bg-opacity-20 rounded-full"></div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Game Controls -->
        <div class="flex justify-between mb-6">
            <button @click="resetGame" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg shadow-md transition-colors">
                {{ translate('playAgain') }}
            </button>
            <button @click="showInstructions = !showInstructions" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg shadow-md transition-colors">
                {{ translate('instructions') }}
            </button>
        </div>

        <!-- Instructions Modal -->
        <div v-if="showInstructions" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
                <h2 class="text-xl font-bold mb-4 text-gray-800 dark:text-white">{{ translate('gameTitle') }}</h2>
                <ol class="list-decimal pl-6 mb-4 text-gray-700 dark:text-gray-300 space-y-2">
                    <li>{{ translate('instruction1') }}</li>
                    <li>{{ translate('instruction2') }}</li>
                    <li>{{ translate('instruction3') }}</li>
                    <li>{{ translate('instruction4') }}</li>
                    <li>{{ translate('instruction5') }}</li>
                </ol>
                <div class="text-center">
                    <button @click="showInstructions = false" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg">
                        {{ translate('play') }}
                    </button>
                </div>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div v-if="isGameOver" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full text-center">
                <h2 class="text-2xl font-bold mb-4 text-gray-800 dark:text-white">{{ translate('gameOver') }}</h2>
                <p class="mb-2 text-gray-700 dark:text-gray-300">{{ translate('yourScore') }}: {{ score }}</p>
                <p class="mb-4 text-gray-700 dark:text-gray-300">{{ translate('highestBubble') }}: {{ translate('level') }} {{ highestLevel }}</p>
                <button @click="resetGame" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg shadow-md transition-colors">
                    {{ translate('playAgain') }}
                </button>
            </div>
        </div>

        <!-- Bonus Effect -->
        <div v-if="showBonus" class="fixed inset-0 pointer-events-none flex items-center justify-center">
            <div class="text-4xl font-bold text-yellow-500 pop-animation">+{{ bonusPoints }} {{ translate('bonusPoints') }}!</div>
        </div>
    </div>

    <script>
        // Translations
        const translations = {
            en: {
                gameTitle: 'Bubble Merge',
                score: 'Score',
                highestBubble: 'Highest Bubble',
                level: 'Level',
                nextBubble: 'Next Bubble',
                playAgain: 'Play Again',
                instructions: 'Instructions',
                gameOver: 'Game Over!',
                yourScore: 'Your Score',
                instruction1: 'Drag bubbles to move them',
                instruction2: 'Connect same bubbles to merge them',
                instruction3: 'A new bubble appears after each move',
                instruction4: 'Create higher level bubbles for more points',
                instruction5: 'Game ends when the board is full',
                play: 'Play',
                bonusPoints: 'BONUS'
            },
            de: {
                gameTitle: 'Bubble Merge',
                score: 'Punktestand',
                highestBubble: 'Höchste Blase',
                level: 'Level',
                nextBubble: 'Nächste Blase',
                playAgain: 'Noch einmal spielen',
                instructions: 'Anleitung',
                gameOver: 'Spiel vorbei!',
                yourScore: 'Dein Punktestand',
                instruction1: 'Ziehe Blasen, um sie zu bewegen',
                instruction2: 'Verbinde gleiche Blasen, um sie zu verschmelzen',
                instruction3: 'Nach jedem Zug erscheint eine neue Blase',
                instruction4: 'Bilde möglichst hohe Blasen für mehr Punkte',
                instruction5: 'Das Spiel endet, wenn das Feld voll ist',
                play: 'Spielen',
                bonusPoints: 'BONUS'
            }
        };

        function translate(key) {
            return translations[app.language][key] || key;
        }

        // Vue App
        const app = Vue.createApp({
            data() {
                return {
                    gameBoard: Array(25).fill(null),
                    score: 0,
                    highScore: 0,
                    highestLevel: 1,
                    nextBubble: 1,
                    isGameOver: false,
                    showInstructions: false,
                    language: 'de',
                    isDarkMode: false,
                    selectedBubbleIndex: null,
                    highlightedCells: [],
                    isShaking: false,
                    showBonus: false,
                    bonusPoints: 0,
                    comboCounter: 0,
                    specialBubbleChance: 0.05, // 5% chance for special bubble
                    consecutiveMoves: 0,
                    hasLocalStorage: false
                };
            },
            created() {
                // Check if localStorage is available
                try {
                    this.hasLocalStorage = typeof localStorage !== 'undefined';
                    if (this.hasLocalStorage) {
                        const savedHighScore = localStorage.getItem('bubbleMergeHighScore');
                        const savedHighestLevel = localStorage.getItem('bubbleMergeHighestLevel');
                        const savedTheme = localStorage.getItem('bubbleMergeTheme');
                        const savedLanguage = localStorage.getItem('bubbleMergeLanguage');
                        
                        if (savedHighScore) this.highScore = parseInt(savedHighScore);
                        if (savedHighestLevel) this.highestLevel = parseInt(savedHighestLevel);
                        if (savedTheme) this.isDarkMode = savedTheme === 'dark';
                        if (savedLanguage) this.language = savedLanguage;
                    }
                } catch (e) {
                    console.log('LocalStorage not available:', e);
                    this.hasLocalStorage = false;
                }
                
                // Set theme
                this.applyTheme();
                
                // Start the game
                this.initGame();
            },
            methods: {
                initGame() {
                    // Clear the board
                    this.gameBoard = Array(25).fill(null);
                    this.score = 0;
                    this.isGameOver = false;
                    this.comboCounter = 0;
                    this.consecutiveMoves = 0;
                    
                    // Add initial bubbles
                    for (let i = 0; i < 5; i++) {
                        this.addRandomBubble();
                    }
                    
                    // Set next bubble
                    this.generateNextBubble();
                },
                generateNextBubble() {
                    // 80% chance for level 1, 15% for level 2, 5% for level 3
                    let randomValue;
                    const rand = Math.random();
                    
                    if (this.consecutiveMoves > 10 && Math.random() < this.specialBubbleChance) {
                        // Special bubble with random value between 5 and highest level - 2
                        const minLevel = Math.min(5, this.highestLevel - 2);
                        const maxLevel = Math.max(minLevel, Math.min(this.highestLevel - 1, 8));
                        randomValue = Math.floor(Math.random() * (maxLevel - minLevel + 1)) + minLevel;
                        this.consecutiveMoves = 0; // Reset consecutive moves
                    } else if (rand < 0.8) {
                        randomValue = 1;
                    } else if (rand < 0.95) {
                        randomValue = 2;
                    } else {
                        randomValue = 3;
                    }
                    
                    this.nextBubble = randomValue;
                },
                addRandomBubble() {
                    const emptyCells = this.gameBoard.map((cell, index) => cell === null ? index : -1).filter(index => index !== -1);
                    
                    if (emptyCells.length === 0) {
                        // Check if any moves are possible
                        const canMove = this.checkForPossibleMoves();
                        if (!canMove) {
                            this.gameOver();
                        }
                        return false;
                    }
                    
                    const randomIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    
                    this.gameBoard[randomIndex] = {
                        value: this.nextBubble,
                        isNew: true,
                        isMerged: false,
                        isPopping: false
                    };
                    
                    // Generate next bubble
                    this.generateNextBubble();
                    
                    // Remove isNew flag after animation
                    setTimeout(() => {
                        if (this.gameBoard[randomIndex]) {
                            this.gameBoard[randomIndex].isNew = false;
                        }
                    }, 300);
                    
                    return true;
                },
                selectBubble(index) {
                    // If no bubble is selected and the cell is not empty
                    if (this.selectedBubbleIndex === null && this.gameBoard[index]) {
                        this.selectedBubbleIndex = index;
                        return;
                    }
                    
                    // If a bubble is already selected
                    if (this.selectedBubbleIndex !== null) {
                        // If clicking on the same bubble, deselect it
                        if (this.selectedBubbleIndex === index) {
                            this.selectedBubbleIndex = null;
                            return;
                        }
                        
                        // If clicking on an empty cell, move the bubble
                        if (!this.gameBoard[index]) {
                            // Check if the move is valid (adjacent horizontal, vertical or diagonal)
                            if (this.isValidMove(this.selectedBubbleIndex, index)) {
                                this.moveBubble(this.selectedBubbleIndex, index);
                                this.selectedBubbleIndex = null;
                                this.consecutiveMoves++;
                                return;
                            } else {
                                // Invalid move - shake the board
                                this.shakeBoard();
                                return;
                            }
                        }
                        
                        // If clicking on another bubble with the same value, merge them
                        if (this.gameBoard[index] && 
                            this.gameBoard[this.selectedBubbleIndex] && 
                            this.gameBoard[index].value === this.gameBoard[this.selectedBubbleIndex].value) {
                            if (this.isValidMove(this.selectedBubbleIndex, index)) {
                                this.mergeBubbles(this.selectedBubbleIndex, index);
                                this.selectedBubbleIndex = null;
                                this.consecutiveMoves++;
                            } else {
                                // Invalid move - shake the board
                                this.shakeBoard();
                            }
                            return;
                        }
                        
                        // If clicking on a different bubble, switch selection
                        this.selectedBubbleIndex = this.gameBoard[index] ? index : null;
                    }
                },
                isValidMove(fromIndex, toIndex) {
                    const fromRow = Math.floor(fromIndex / 5);
                    const fromCol = fromIndex % 5;
                    const toRow = Math.floor(toIndex / 5);
                    const toCol = toIndex % 5;
                    
                    // Check if the move is to an adjacent cell (horizontal, vertical, or diagonal)
                    return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
                },
                highlightMoves(index) {
                    if (!this.gameBoard[index]) return;
                    
                    const row = Math.floor(index / 5);
                    const col = index % 5;
                    const highlighted = [];
                    
                    // Check all adjacent cells (horizontal, vertical, diagonal)
                    for (let r = Math.max(0, row - 1); r <= Math.min(4, row + 1); r++) {
                        for (let c = Math.max(0, col - 1); c <= Math.min(4, col + 1); c++) {
                            const checkIndex = r * 5 + c;
                            if (checkIndex !== index) {
                                // Empty cell or same value bubble
                                if (!this.gameBoard[checkIndex] || 
                                    (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === this.gameBoard[index].value)) {
                                    highlighted.push(checkIndex);
                                }
                            }
                        }
                    }
                    
                    this.highlightedCells = highlighted;
                },
                clearHighlights() {
                    this.highlightedCells = [];
                },
                moveBubble(fromIndex, toIndex) {
                    // Move the bubble
                    this.gameBoard[toIndex] = { ...this.gameBoard[fromIndex] };
                    this.gameBoard[fromIndex] = null;
                    
                    // Check for matches
                    setTimeout(() => {
                        this.checkMatches(toIndex);
                    }, 100);
                },
                mergeBubbles(fromIndex, toIndex) {
                    const value = this.gameBoard[fromIndex].value;
                    const newValue = value + 1;
                    
                    // Update highest level
                    if (newValue > this.highestLevel) {
                        this.highestLevel = newValue;
                        this.saveHighestLevel();
                    }
                    
                    // Merge the bubbles - the target position gets the new value
                    this.gameBoard[toIndex] = {
                        value: newValue,
                        isNew: false,
                        isMerged: true,
                        isPopping: false
                    };
                    
                    // Remove the source bubble
                    this.gameBoard[fromIndex] = null;
                    
                    // Calculate score (higher level merges give exponentially more points)
                    const mergePoints = Math.pow(2, newValue);
                    this.score += mergePoints;
                    
                    // Update high score if needed
                    if (this.score > this.highScore) {
                        this.highScore = this.score;
                        this.saveHighScore();
                    }
                    
                    // Increment combo counter
                    this.comboCounter++;
                    
                    // Add bonus for combos
                    if (this.comboCounter > 1) {
                        const bonusMultiplier = Math.min(this.comboCounter, 5); // Cap at 5x
                        this.bonusPoints = mergePoints * (bonusMultiplier - 1);
                        this.score += this.bonusPoints;
                        this.showBonusEffect();
                    }
                    
                    // Remove isMerged flag after animation
                    setTimeout(() => {
                        if (this.gameBoard[toIndex]) {
                            this.gameBoard[toIndex].isMerged = false;
                            
                            // Check for matches after merging
                            this.checkMatches(toIndex);
                        }
                    }, 400);
                },
                checkMatches(index) {
                    if (!this.gameBoard[index]) return;
                    
                    const row = Math.floor(index / 5);
                    const col = index % 5;
                    const value = this.gameBoard[index].value;
                    
                    const matches = [];
                    
                    // Check horizontal, vertical, and diagonal matches
                    
                    // Horizontal check
                    let horizontalMatches = [index];
                    
                    // Check left
                    for (let c = col - 1; c >= 0; c--) {
                        const checkIndex = row * 5 + c;
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            horizontalMatches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    // Check right
                    for (let c = col + 1; c < 5; c++) {
                        const checkIndex = row * 5 + c;
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            horizontalMatches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    if (horizontalMatches.length >= 3) {
                        matches.push(...horizontalMatches);
                    }
                    
                    // Vertical check
                    let verticalMatches = [index];
                    
                    // Check up
                    for (let r = row - 1; r >= 0; r--) {
                        const checkIndex = r * 5 + col;
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            verticalMatches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    // Check down
                    for (let r = row + 1; r < 5; r++) {
                        const checkIndex = r * 5 + col;
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            verticalMatches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    if (verticalMatches.length >= 3) {
                        matches.push(...verticalMatches);
                    }
                    
                    // Diagonal check (top-left to bottom-right)
                    let diagonal1Matches = [index];
                    
                    // Check top-left
                    for (let offset = 1; row - offset >= 0 && col - offset >= 0; offset++) {
                        const checkIndex = (row - offset) * 5 + (col - offset);
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            diagonal1Matches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    // Check bottom-right
                    for (let offset = 1; row + offset < 5 && col + offset < 5; offset++) {
                        const checkIndex = (row + offset) * 5 + (col + offset);
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            diagonal1Matches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    if (diagonal1Matches.length >= 3) {
                        matches.push(...diagonal1Matches);
                    }
                    
                    // Diagonal check (top-right to bottom-left)
                    let diagonal2Matches = [index];
                    
                    // Check top-right
                    for (let offset = 1; row - offset >= 0 && col + offset < 5; offset++) {
                        const checkIndex = (row - offset) * 5 + (col + offset);
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            diagonal2Matches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    // Check bottom-left
                    for (let offset = 1; row + offset < 5 && col - offset >= 0; offset++) {
                        const checkIndex = (row + offset) * 5 + (col - offset);
                        if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                            diagonal2Matches.push(checkIndex);
                        } else {
                            break;
                        }
                    }
                    
                    if (diagonal2Matches.length >= 3) {
                        matches.push(...diagonal2Matches);
                    }
                    
                    // Remove duplicates
                    const uniqueMatches = [...new Set(matches)];
                    
                    if (uniqueMatches.length >= 3) {
                        // Add popping animation to all matches
                        uniqueMatches.forEach(matchIndex => {
                            if (this.gameBoard[matchIndex]) {
                                this.gameBoard[matchIndex].isPopping = true;
                            }
                        });
                        
                        // Wait for animation to complete
                        setTimeout(() => {
                            // Remove the matches
                            uniqueMatches.forEach(matchIndex => {
                                this.gameBoard[matchIndex] = null;
                            });
                            
                            // Calculate score for popping (value * matches * 2)
                            const popPoints = value * uniqueMatches.length * 2;
                            this.score += popPoints;
                            
                            // Increment combo counter
                            this.comboCounter++;
                            
                            // Add bonus for combos
                            if (this.comboCounter > 1) {
                                const bonusMultiplier = Math.min(this.comboCounter, 5); // Cap at 5x
                                this.bonusPoints = popPoints * (bonusMultiplier - 1);
                                this.score += this.bonusPoints;
                                this.showBonusEffect();
                            }
                            
                            // Update high score if needed
                            if (this.score > this.highScore) {
                                this.highScore = this.score;
                                this.saveHighScore();
                            }
                            
                            // Add a new bubble after popping
                            setTimeout(() => {
                                this.addRandomBubble();
                            }, 300);
                        }, 300);
                        
                        return;
                    }
                    
                    // Reset combo counter if no matches
                    this.comboCounter = 0;
                    
                    // Add a new bubble after the move
                    setTimeout(() => {
                        this.addRandomBubble();
                    }, 300);
                },
                checkForPossibleMoves() {
                    // Check if there are any empty cells
                    const hasEmptyCells = this.gameBoard.some(cell => cell === null);
                    if (hasEmptyCells) return true;
                    
                    // Check if there are any adjacent cells with the same value
                    for (let i = 0; i < this.gameBoard.length; i++) {
                        const row = Math.floor(i / 5);
                        const col = i % 5;
                        const value = this.gameBoard[i]?.value;
                        
                        if (!value) continue;
                        
                        // Check adjacent cells
                        for (let r = Math.max(0, row - 1); r <= Math.min(4, row + 1); r++) {
                            for (let c = Math.max(0, col - 1); c <= Math.min(4, col + 1); c++) {
                                if (r === row && c === col) continue; // Skip self
                                
                                const checkIndex = r * 5 + c;
                                if (this.gameBoard[checkIndex] && this.gameBoard[checkIndex].value === value) {
                                    return true;
                                }
                            }
                        }
                    }
                    
                    return false;
                },
                gameOver() {
                    this.isGameOver = true;
                },
                resetGame() {
                    this.initGame();
                },
                saveHighScore() {
                    if (this.hasLocalStorage) {
                        try {
                            localStorage.setItem('bubbleMergeHighScore', this.highScore.toString());
                        } catch (e) {
                            console.log('Error saving high score:', e);
                        }
                    }
                },
                saveHighestLevel() {
                    if (this.hasLocalStorage) {
                        try {
                            localStorage.setItem('bubbleMergeHighestLevel', this.highestLevel.toString());
                        } catch (e) {
                            console.log('Error saving highest level:', e);
                        }
                    }
                },
                toggleTheme() {
                    this.isDarkMode = !this.isDarkMode;
                    this.applyTheme();
                    
                    if (this.hasLocalStorage) {
                        try {
                            localStorage.setItem('bubbleMergeTheme', this.isDarkMode ? 'dark' : 'light');
                        } catch (e) {
                            console.log('Error saving theme preference:', e);
                        }
                    }
                },
                applyTheme() {
                    if (this.isDarkMode) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                },
                toggleLanguage() {
                    this.language = this.language === 'de' ? 'en' : 'de';
                    
                    if (this.hasLocalStorage) {
                        try {
                            localStorage.setItem('bubbleMergeLanguage', this.language);
                        } catch (e) {
                            console.log('Error saving language preference:', e);
                        }
                    }
                },
                shakeBoard() {
                    this.isShaking = true;
                    setTimeout(() => {
                        this.isShaking = false;
                    }, 500);
                },
                showBonusEffect() {
                    this.showBonus = true;
                    setTimeout(() => {
                        this.showBonus = false;
                    }, 1000);
                }
            }
        });

        // Make translate function available to the template
        app.config.globalProperties.translate = translate;
        
        // Mount the app
        app.mount('#app');
    </script>
</body>
</html>
