<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Merge</title>
    <style>
        :root {
            --bg-color: #f0f9ff;
            --text-color: #1e293b;
            --grid-color: #e2e8f0;
            --grid-border: #94a3b8;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --bubble-colors: #f87171, #facc15, #4ade80, #60a5fa, #a78bfa, #f472b6, #fb923c, #22d3ee;
            --accent-color: #3b82f6;
            --chain-highlight: #fef08a;
            --modal-bg: rgba(0, 0, 0, 0.5);
            --modal-content-bg: #f0f9ff;
            --gold-color: #fbbf24;
        }

        [data-theme="dark"] {
            --bg-color: #0f172a;
            --text-color: #f1f5f9;
            --grid-color: #1e293b;
            --grid-border: #475569;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --accent-color: #60a5fa;
            --chain-highlight: #fbbf24;
            --modal-content-bg: #1e293b;
            --gold-color: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 16px;
            transition: background-color 0.3s, color 0.3s;
        }

        header {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .score-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
        }

        .coins {
            display: flex;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: var(--gold-color);
            background-color: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
        }

        .coin-icon {
            margin-right: 4px;
            font-size: 18px;
        }

        .level {
            font-size: 16px;
        }

        .controls {
            display: flex;
            gap: 12px;
        }

        button {
            background-color: var(--grid-color);
            color: var(--text-color);
            border: 1px solid var(--grid-border);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            opacity: 0.9;
        }

        button:active {
            transform: scale(0.97);
        }

        .icon {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }

        .game-container {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px var(--shadow-color);
        }

        .game-stats {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            margin-bottom: 16px;
        }

        .next-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            box-shadow: 0 4px 10px var(--shadow-color);
            flex: 1;
            margin-right: 10px;
        }

        .goal-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            box-shadow: 0 4px 10px var(--shadow-color);
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .goal-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background-color: var(--accent-color);
            transition: width 0.5s ease-out;
        }

        .next-label, .goal-label {
            font-weight: bold;
            margin-right: 12px;
        }

        #next-bubble, #goal-bubble {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.2), inset 0 4px 8px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.15);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            background-size: cover;
            background-position: center;
            z-index: 1;
            will-change: transform;
        }

        .bubble-inner {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0) 70%);
            font-size: 1.2em;
        }

        .bubble.dragging {
            opacity: 0.8;
            z-index: 100;
            cursor: grabbing;
            transform: scale(1.1);
            box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.2), inset 0 4px 8px rgba(255, 255, 255, 0.2), 0 10px 20px rgba(0, 0, 0, 0.25);
        }

        .bubble.merging {
            z-index: 50;
            animation: merge 0.5s forwards;
        }

        .bubble.chain-merge {
            animation: chain-merge 0.6s forwards;
        }

        .bubble.falling {
            transition: top 0.3s ease-in-out;
        }

        @keyframes merge {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
                filter: brightness(1.5);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes chain-merge {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.4);
                filter: brightness(1.8);
                box-shadow: 0 0 30px var(--chain-highlight);
            }
            70% {
                transform: scale(1.2);
                filter: brightness(1.5);
                box-shadow: 0 0 20px var(--chain-highlight);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0px var(--chain-highlight);
            }
        }

        .bubble.merging {
            animation-duration: 0.4s;
        }

        .bubble.chain-merge {
            animation-duration: 0.5s;
        }

        .new-bubble {
            animation: pop 0.3s forwards;
        }

        @keyframes pop {
            0% {
                transform: scale(0);
            }
            70% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        .score-popup {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 18px;
            animation: float-up 1.2s forwards;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        }

        .chain-bonus {
            color: var(--chain-highlight);
            font-size: 22px;
            animation: float-up-bonus 1.5s forwards;
        }

        @keyframes float-up {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.2);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1);
            }
        }

        @keyframes float-up-bonus {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.5);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-150px) scale(1.2);
            }
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            pointer-events: none;
            z-index: 0;
        }

        .grid-cell {
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            border-radius: 16px;
            padding: 24px;
            max-width: 90%;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s;
            -webkit-overflow-scrolling: touch;
            position: relative; /* F√ºr festes Footer-Positioning */
        }

        /* VER√ÑNDERT: Sticky Footer f√ºr Modals */
        .button-group {
            position: sticky;
            bottom: 0;
            padding-top: 15px;
            background-color: var(--modal-content-bg);
            margin-top: auto;
            z-index: 10;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* VER√ÑNDERT: Verbesserte Tab-Buttons */
        .tab-container {
            width: 100%;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab-buttons {
            position: sticky;
            top: 0;
            z-index: 5;
            background-color: var(--modal-content-bg);
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--grid-border);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-bottom: 5px;
        }

        /* VER√ÑNDERT: Verbessertes Tab-Content Scrolling */
        .tab-content {
            display: none;
            width: 100%;
            padding-bottom: 15px; /* Platz f√ºr den Button-Footer */
        }

        /* Verstecke Scrollbar, behalte Funktionalit√§t */
        .tab-buttons::-webkit-scrollbar {
            display: none;
        }

        .modal-content::-webkit-scrollbar {
            width: 6px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: var(--grid-color);
            border-radius: 10px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: var(--grid-border);
            border-radius: 10px;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal h2 {
            margin-bottom: 16px;
            font-size: 28px;
        }

        .modal p {
            margin-bottom: 24px;
            text-align: center;
            line-height: 1.6;
        }

        .primary-button {
            background-color: var(--accent-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
        }

        .secondary-button {
            background-color: var(--grid-color);
            padding: 10px 20px;
            border-radius: 8px;
        }

        /* NEU: Scroll-to-Top Button */
        .scroll-top-button {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            padding: 8px 12px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            display: none;
        }

        /* Info-Popup f√ºr Challenges */
        .challenge-info-button {
            background: none;
            border: none;
            color: var(--accent-color);
            font-size: 18px;
            cursor: pointer;
            margin-left: 5px;
            padding: 2px;
        }

        .challenge-tooltip {
            position: absolute;
            background-color: var(--accent-color);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            max-width: 250px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
        }

        .challenge-info-button:hover + .challenge-tooltip {
            opacity: 1;
        }

        /* Verbesserter Achievement-Fortschritt */
        .achievement-badge {
            position: relative;
            overflow: hidden;
        }

        .achievement-badge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent 65%, rgba(255, 255, 255, 0.2) 80%, transparent 95%);
            background-size: 200% 200%;
            animation: shine 2s infinite;
            pointer-events: none;
            opacity: 0.6;
        }

        @keyframes shine {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        /* Achievement-Level-Badge */
        .achievement-level {
            background-color: var(--accent-color);
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }

        /* Dynamische Achievement-Kategorie */
        .achievement-category {
            margin-bottom: 20px;
            padding: 10px;
            background-color: var(--grid-color);
            border-radius: 8px;
        }

        .achievement-category-title {
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .achievement-badge {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            width: 100%;
        }

        .achievement-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 16px;
            flex-shrink: 0;
        }

        .achievement-info {
            flex-grow: 1;
        }

        .achievement-title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .achievement-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        .achievement-progress {
            width: 100%;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .achievement-progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.5s;
        }

        .achievement-level {
            font-size: 12px;
            margin-left: 8px;
            padding: 2px 6px;
            background-color: var(--accent-color);
            color: white;
            border-radius: 10px;
        }

        .stats-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
        }

        .stats-table td {
            padding: 8px;
            text-align: left;
        }

        .stats-table td:last-child {
            text-align: right;
            font-weight: bold;
        }

        .challenge-container {
            border-top: 1px solid var(--grid-border);
            padding-top: 20px;
            width: 100%;
            margin-top: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .challenge-progress {
            width: 100%;
            height: 10px;
            background-color: var(--grid-color);
            border-radius: 5px;
            margin: 12px 0;
            overflow: hidden;
        }

        .challenge-progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.5s;
        }

        .challenge-reward {
            display: inline-block;
            background-color: var(--chain-highlight);
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 8px;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-5px);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(5px);
            }
        }

        #tutorials-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 900;
            pointer-events: none;
        }

        .tutorial {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 16px;
            border-radius: 8px;
            max-width: 80%;
            font-size: 16px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            pointer-events: all;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-5px);
            }
        }

        .tutorial:after {
            content: '';
            position: absolute;
            border: 10px solid transparent;
        }

        .tutorial.bottom:after {
            border-top-color: rgba(59, 130, 246, 0.9);
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tutorial.top:after {
            border-bottom-color: rgba(59, 130, 246, 0.9);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tutorial button {
            background-color: white;
            color: #3b82f6;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            margin-top: 10px;
            font-weight: bold;
        }

        .game-info {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-color);
            opacity: 0.8;
        }

        .chain-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: var(--chain-highlight);
            color: black;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            animation: pulse 0.6s infinite alternate;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            100% {
                transform: scale(1.1);
            }
        }

        .special-mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .special-mode-banner {
            background-color: var(--accent-color);
            color: white;
            text-align: center;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 8px;
            font-weight: bold;
            width: 100%;
            max-width: 600px;
        }

        .challenge-modes {
            margin-top: 20px;
            width: 100%;
        }

        .challenge-modes h3 {
            margin-bottom: 15px;
        }

        .mode-button {
            background-color: var(--grid-color);
            color: var(--text-color);
            border: 1px solid var(--grid-border);
            padding: 10px 15px;
            margin-bottom: 10px;
            margin-right: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
        }

        .mode-button.active {
            background-color: var(--accent-color);
            color: white;
        }

        .mode-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .mode-icon {
            margin-right: 8px;
            font-size: 18px;
        }

        .mode-description {
            margin-top: 5px;
            font-size: 14px;
            opacity: 0.8;
        }

        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: bold;
            opacity: 0.6;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-button.active {
            opacity: 1;
            border-bottom-color: var(--accent-color);
        }

        .tab-content {
            display: none;
            width: 100%;
            max-height: 50vh;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        .progress-label {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
        }

        .upgrade-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: var(--grid-color);
            border-radius: 8px;
            margin-bottom: 10px;
            width: 100%;
        }

        .upgrade-info {
            flex-grow: 1;
            margin-right: 10px;
        }

        .upgrade-title {
            font-weight: bold;
        }

        .upgrade-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        .upgrade-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
        }

        .upgrade-button:disabled {
            background-color: var(--grid-border);
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-cost {
            margin-left: .5rem;
            font-size: 12px;
            display: block;
            text-align: center;
        }

        .notification-badge {
            position: relative;
        }

        .notification-badge::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            display: none;
        }

        .notification-badge.active::after {
            display: block;
        }

        /* Verbesserte Responsivit√§t */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            header {
                padding: 0 5px;
                margin-bottom: 10px;
            }

            .score {
                font-size: 18px;
            }

            .coins {
                font-size: 16px;
                padding: 3px 6px;
            }

            .level {
                font-size: 12px;
            }

            .controls {
                gap: 8px;
            }

            button {
                padding: 6px 8px;
                font-size: 14px;
            }

            .icon {
                width: 16px;
                height: 16px;
            }

            .game-container {
                margin-bottom: 5px;
            }

            #next-bubble, #goal-bubble,
            #next-bubble > .bubble, #goal-bubble > .bubble{
                width: 40px !important;
                height: 40px !important;
            }

            .next-label, .goal-label {
                font-size: 12px;
                margin-right: 5px;
            }

            .next-container, .goal-container {
                padding: 8px;
            }

            .modal-content {
                padding: 16px;
                width: 95%;
                max-height: 85vh;
                border-radius: 12px;
            }

            .modal h2 {
                font-size: 20px;
                margin-bottom: 10px;
            }

            .modal p {
                font-size: 14px;
                margin-bottom: 16px;
            }

            .game-info {
                flex-direction: column;
                align-items: center;
                gap: 5px;
                text-align: center;
                font-size: 12px;
                margin-top: 10px;
            }

            .game-stats {
                flex-direction: column;
                gap: 8px;
                margin-top: 10px;
                margin-bottom: 10px;
            }

            .next-container, .goal-container {
                margin-right: 0;
                margin-bottom: 0;
            }

            .button-group {
                padding-top: 10px;
            }

            .achievement-badge {
                padding: 8px;
            }

            .achievement-icon {
                width: 30px;
                height: 30px;
                margin-right: 10px;
            }

            .achievement-title {
                font-size: 14px;
            }

            .achievement-desc {
                font-size: 12px;
            }

            .tab-button {
                padding: 8px 12px;
                font-size: 14px;
            }

            .upgrade-item {
                padding: 8px;
                flex-direction: column;
                align-items: flex-start;
            }

            .upgrade-info {
                margin-right: 0;
                margin-bottom: 8px;
                width: 100%;
            }

            .upgrade-button {
                width: 100%;
            }

            .tutorial {
                padding: 12px;
                font-size: 14px;
            }

            #modes-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .mode-button {
                margin: 0;
                padding: 8px;
                font-size: 12px;
                width: 100%;
            }

            .stats-table {
                font-size: 13px;
            }

            .stats-table td {
                padding: 6px;
            }

            #challenge-description {
                font-size: 13px;
            }

            .bubble-inner {
                font-size: 1em;
            }

            .game-container {
                aspect-ratio: 1 / 1;
                max-width: 95vw;
            }
        }

        @media (max-width: 360px) {
            body {
                padding: 5px;
            }

            .score {
                font-size: 16px;
            }

            .coins {
                font-size: 14px;
                padding: 2px 5px;
            }

            .level {
                font-size: 11px;
            }

            button {
                padding: 5px 7px;
            }

            .icon {
                width: 14px;
                height: 14px;
            }

            .modal-content {
                padding: 12px;
            }

            .modal h2 {
                font-size: 18px;
            }

            .tab-button {
                padding: 6px 8px;
                font-size: 12px;
            }

            #next-bubble, #goal-bubble {
                width: 35px;
                height: 35px;
            }

            .game-stats, .game-info {
                margin-top: 5px;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
<header>
    <div class="score-container">
        <div class="score-row">
            <div class="score">0</div>
            <div class="coins"><span class="coin-icon">üí∞</span><span id="coins-display">0</span></div>
        </div>
        <div class="level">Level 1</div>
    </div>
    <div class="controls">
        <button id="stats-button" aria-label="Statistiken" class="notification-badge">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M3 3v18h18"></path>
                <path d="M8 13v4"></path>
                <path d="M12 9v8"></path>
                <path d="M16 6v11"></path>
            </svg>
        </button>
        <button id="theme-toggle" aria-label="Farbmodus umschalten">
            <svg class="icon moon-icon" viewBox="0 0 24 24">
                <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </svg>
            <svg class="icon sun-icon" style="display: none;" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="4"></circle>
                <path d="M12 2v2"></path>
                <path d="M12 20v2"></path>
                <path d="m4.93 4.93 1.41 1.41"></path>
                <path d="m17.66 17.66 1.41 1.41"></path>
                <path d="M2 12h2"></path>
                <path d="M20 12h2"></path>
                <path d="m6.34 17.66-1.41 1.41"></path>
                <path d="m19.07 4.93-1.41 1.41"></path>
            </svg>
        </button>
        <button id="restart-button" aria-label="Neustarten">
            <svg class="icon" viewBox="0 0 24 24">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                <path d="M3 3v5h5"></path>
            </svg>
        </button>
    </div>
</header>

<div id="special-mode-banner" class="special-mode-banner" style="display: none;">
    Schwerkraft-Modus: Blasen fallen nach unten
</div>

<div class="game-container" id="game-container">
    <div class="grid-overlay" id="grid-overlay"></div>
    <div class="chain-counter" id="chain-counter">x1</div>
    <div class="special-mode-indicator" id="special-mode-indicator" style="display: none;">
        üîÑ Schwerkraft
    </div>
</div>

<div class="game-stats">
    <div class="next-container">
        <div class="next-label">N√§chste:</div>
        <div id="next-bubble"></div>
    </div>
    <div class="goal-container">
        <div class="goal-label">Ziel:</div>
        <div id="goal-bubble"></div>
        <div class="goal-progress" id="goal-progress"></div>
    </div>
</div>

<div class="game-info">
    <div>Kombiniere gleiche Blasen f√ºr Punkte und Kettenreaktionen</div>
    <div>Speichere und teile deinen Highscore</div>
</div>

<div class="modal" id="game-over-modal">
    <div class="modal-content">
        <h2>Spiel vorbei!</h2>
        <p>Dein Punktestand: <span id="final-score">0</span></p>
        <p>H√∂chste Blase: <span id="highest-bubble">2</span> (<span id="highest-value">4</span>)</p>

        <table class="stats-table">
            <tr>
                <td>M√ºnzen:</td>
                <td id="stats-coins">0</td>
            </tr>
            <tr>
                <td>L√§ngste Kette:</td>
                <td id="longest-chain">0</td>
            </tr>
            <tr>
                <td>Gespielte Zeit:</td>
                <td id="played-time">0:00</td>
            </tr>
            <tr>
                <td>Gesamte Z√ºge:</td>
                <td id="total-moves">0</td>
            </tr>
        </table>

        <div class="button-group">
            <button class="primary-button" id="play-again-button">Noch einmal spielen</button>
            <button class="secondary-button" id="share-button">Teilen</button>
        </div>
    </div>
</div>

<div class="modal" id="stats-modal">
    <div class="modal-content">
        <h2>Spielmen√º</h2>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="stats">Statistik</button>
                <button class="tab-button" data-tab="achievements">Erfolge</button>
                <button class="tab-button" data-tab="challenges">Herausforderungen</button>
                <button class="tab-button" data-tab="upgrades">Verbesserungen</button>
                <button class="tab-button" data-tab="modes">Spielmodi</button>
            </div>

            <div class="tab-content active" id="stats-tab">
                <table class="stats-table">
                    <tr>
                        <td>Highscore:</td>
                        <td id="stats-highscore">0</td>
                    </tr>
                    <tr>
                        <td>H√∂chste Blase:</td>
                        <td id="stats-highest-bubble">2 (4)</td>
                    </tr>
                    <tr>
                        <td>L√§ngste Kette:</td>
                        <td id="stats-longest-chain">0</td>
                    </tr>
                    <tr>
                        <td>Gespielte Spiele:</td>
                        <td id="stats-games-played">0</td>
                    </tr>
                    <tr>
                        <td>Spielfeldgr√∂√üe:</td>
                        <td id="stats-grid-size">6x6</td>
                    </tr>
                    <tr>
                        <td>M√ºnzen:</td>
                        <td id="stats-coins-value">0</td>
                    </tr>
                    <tr>
                        <td>Aktueller Score:</td>
                        <td id="stats-current-score">0</td>
                    </tr>
                </table>
            </div>

            <div class="tab-content" id="achievements-tab">
                <div id="achievements-container">
                    <!-- Achievements werden hier dynamisch eingef√ºgt -->
                </div>
            </div>

            <div class="tab-content" id="challenges-tab">
                <div class="challenge-container">
                    <h3>Aktuelle Herausforderung</h3>
                    <p id="challenge-description">Erzeuge eine Kette mit mindestens 3 Verschmelzungen</p>
                    <div class="challenge-progress">
                        <div class="challenge-progress-bar" id="challenge-progress-bar" style="width: 0%;"></div>
                    </div>
                    <div class="progress-label">
                        <span id="challenge-progress-text">0/3</span>
                        <span>Belohnung: <span class="challenge-reward" id="challenge-reward">+500 Punkte</span></span>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="upgrades-tab">
                <div id="upgrades-container">
                    <!-- Upgrades werden hier eingef√ºgt -->
                </div>
            </div>

            <div class="tab-content" id="modes-tab">
                <h3>Spezial-Spielmodi</h3>
                <p class="mode-description">Diese Modi bieten neue Herausforderungen und Spielmechaniken.</p>

                <div id="modes-container">
                    <button class="mode-button" data-mode="normal">
                        <span class="mode-icon">üéÆ</span>
                        Standard
                    </button>
                    <button class="mode-button" data-mode="gravity">
                        <span class="mode-icon">‚¨áÔ∏è</span>
                        Schwerkraft
                    </button>
                    <button class="mode-button" data-mode="timeAttack" disabled>
                        <span class="mode-icon">‚è±Ô∏è</span>
                        Zeit-Modus
                        <span class="challenge-reward" style="margin-left: 5px">Bald!</span>
                    </button>
                    <button class="mode-button" data-mode="colorBlind" disabled>
                        <span class="mode-icon">üé®</span>
                        Farbmuster
                        <span class="challenge-reward" style="margin-left: 5px">Bald!</span>
                    </button>
                </div>

                <div id="active-mode-description" style="margin-top: 15px;">
                    <strong>Standard-Modus:</strong> Das klassische Bubble Merge Spielerlebnis.
                </div>
            </div>
        </div>

        <div class="button-group" style="margin-top: 20px;">
            <button class="primary-button" id="close-stats-button">Schlie√üen</button>
            <button class="secondary-button" id="reset-stats-button">Zur√ºcksetzen</button>
        </div>
    </div>
</div>

<div class="modal" id="tutorial-modal">
    <div class="modal-content">
        <h2>Bubble Merge</h2>
        <p>1. Ziehe Blasen auf andere gleiche Blasen, um sie zu verschmelzen<br>
            2. Blasen verschmelzen nur durch aktives Ziehen<br>
            3. Erzeuge Kettenreaktionen f√ºr Bonuspunkte<br>
            4. Erreiche das Ziel f√ºr die n√§chste Stufe<br>
            5. Schalte Spielfeld-Erweiterungen frei<br>
            6. Das Spiel endet, wenn das Feld voll ist</p>
        <div class="button-group">
            <button class="primary-button" id="start-game-button">Spielen</button>
        </div>
    </div>
</div>

<div id="tutorials-container"></div>

<script>
	// Haupt-Game-State
	const gameState = {
		score: 0,
		level: 1,
		grid: [],
		gridSize: 6,         // Initiale Spielfeldgr√∂√üe
		maxGridSize: 10,     // Maximale Spielfeldgr√∂√üe
		bubbles: [],
		nextBubble: null,
		maxLevel: 1,
		maxValue: 2,         // Actual value (2^level)
		draggedBubble: null,
		dragOffsetX: 0,
		dragOffsetY: 0,
		hasSavedGame: false,
		gameOver: false,
		newGameStarted: false,
		tutorialStep: 0,
		moveMade: false,     // Flag f√ºr den ersten Zug
		startTime: null,     // Startzeit des Spiels
		playTime: 0,         // Spielzeit in Sekunden
		moves: 0,            // Anzahl der Z√ºge
		chainCount: 0,       // Anzahl der Verschmelzungen in aktueller Kette
		longestChain: 0,     // L√§ngste Kette im Spiel
		currentGoal: 4,      // Aktuelles Ziel (2^3 = 8)
		goalProgress: 0,     // Fortschritt zum aktuellen Ziel (0-100%)
		processingChain: false, // Flag f√ºr laufende Kettenreaktionen
		mergeQueue: [],      // Queue f√ºr Kettenreaktionen
		specialMode: 'normal', // Aktueller Spielmodus
		gravityEnabled: false, // Schwerkraft Modus

		// Stats f√ºr persistente Speicherung
		stats: {
			highscore: 0,
			highestLevel: 1,
			highestValue: 2,
			longestChain: 0,
			gamesPlayed: 0,
			achievements: {},  // Ge√§ndert zu einem Objekt f√ºr Tracking des Fortschritts
			currentChallenge: 0,
			challengeProgress: 0,
			gridSize: 6,
			unlockedGridSize: 6,
			coins: 0,
			upgrades: []
		},
		// Aktuelle Challenge
		challenge: null
	};

	// Definiere die Achievement-Kategorien
	const ACHIEVEMENT_CATEGORIES = [
		{
			id: 'bubbles',
			name: 'Blasen-Meister',
			icon: 'üî¢',
			getLevel: (value) => Math.floor(Math.log2(value) / 2),  // 4, 16, 64, 256, 1024, ...
			getNextTarget: (level) => Math.pow(2, (level + 1) * 2), // N√§chstes Ziel
			getProgress: (value, nextTarget) => {
				if (value === 0) return 0;
				const logValue = Math.log2(value);
				const logTarget = Math.log2(nextTarget);
				const prevTarget = nextTarget / 4; // Vorheriges Ziel ist immer 1/4 des aktuellen
				const logPrevTarget = Math.log2(prevTarget);
				// Berechne prozentuale Fortschritt auf logarithmischer Skala
				return Math.min(100, Math.max(0, ((logValue - logPrevTarget) / (logTarget - logPrevTarget)) * 100));
			}
		},
		{
			id: 'chains',
			name: 'Ketten-Meister',
			icon: '‚õìÔ∏è',
			getLevel: (value) => {
				if (value < 3) return 0;
				if (value < 5) return 1;
				if (value < 7) return 2;
				if (value < 10) return 3;
				if (value < 15) return 4;
				if (value < 20) return 5;
				return 6 + Math.floor((value - 20) / 5);  // Ab Level 6 alle 5 Werte ein neues Level
			},
			getNextTarget: (level) => {
				if (level === 0) return 3;
				if (level === 1) return 5;
				if (level === 2) return 7;
				if (level === 3) return 10;
				if (level === 4) return 15;
				if (level === 5) return 20;
				return 20 + (level - 5) * 5;  // Ab Level 6: 25, 30, 35, ...
			},
			getProgress: (value, nextTarget) => {
				// Wenn kein Wert, kein Fortschritt
				if (value === 0) return 0;

				// Berechne den aktuellen Level basierend auf dem Wert
				const level = ACHIEVEMENT_CATEGORIES[1].getLevel(value);

				// Wenn wir auf Level 0 sind, berechne Fortschritt von 0 zum ersten Ziel (3)
				if (level === 0) {
					return Math.min(100, Math.max(0, (value / 3) * 100));
				}

				// Sonst, berechne Fortschritt vom vorherigen zum n√§chsten Ziel
				const prevTarget = ACHIEVEMENT_CATEGORIES[1].getNextTarget(level - 1);

				// Sichere Division
				if (nextTarget === prevTarget) return 100;

				return Math.min(100, Math.max(0, ((value - prevTarget) / (nextTarget - prevTarget)) * 100));
			}
		},
		{
			id: 'score',
			name: 'Punkte-J√§ger',
			icon: 'üèÜ',
			getLevel: (value) => {
				if (value < 1000) return 0;
				if (value < 5000) return 1;
				if (value < 10000) return 2;
				if (value < 50000) return 3;
				if (value < 100000) return 4;
				return 5 + Math.floor(Math.log10(value / 100000));  // Ab Level 5 alle 10x ein neues Level
			},
			getNextTarget: (level) => {
				if (level === 0) return 1000;
				if (level === 1) return 5000;
				if (level === 2) return 10000;
				if (level === 3) return 50000;
				if (level === 4) return 100000;
				return 100000 * Math.pow(10, level - 4);  // Ab Level 5: 1M, 10M, 100M, ...
			},
			getProgress: (value, nextTarget) => {
				if (value === 0) return 0;
				let prevTarget;
				const level = ACHIEVEMENT_CATEGORIES[2].getLevel(value);
				if (level === 0) {
					prevTarget = 0;
				} else {
					prevTarget = ACHIEVEMENT_CATEGORIES[2].getNextTarget(level - 1);
				}
				// Logarithmischer Fortschritt f√ºr h√∂here Levels
				if (level > 3) {
					const logValue = Math.log10(value);
					const logTarget = Math.log10(nextTarget);
					const logPrevTarget = Math.log10(prevTarget);
					return Math.min(100, Math.max(0, ((logValue - logPrevTarget) / (logTarget - logPrevTarget)) * 100));
				}
				return Math.min(100, Math.max(0, ((value - prevTarget) / (nextTarget - prevTarget)) * 100));
			}
		},
		{
			id: 'games',
			name: 'Spieler-Level',
			icon: 'üéÆ',
			getLevel: (value) => {
				if (value < 10) return 0;
				if (value < 50) return 1;
				if (value < 100) return 2;
				return 3 + Math.floor(Math.log10(value / 100));  // Ab Level 3 alle 10x ein neues Level
			},
			getNextTarget: (level) => {
				if (level === 0) return 10;
				if (level === 1) return 50;
				if (level === 2) return 100;
				return 100 * Math.pow(10, level - 2);  // Ab Level 3: 1000, 10000, ...
			},
			getProgress: (value, nextTarget) => {
				if (value === 0) return 0;
				let prevTarget;
				const level = ACHIEVEMENT_CATEGORIES[3].getLevel(value);
				if (level === 0) {
					prevTarget = 0;
				} else {
					prevTarget = ACHIEVEMENT_CATEGORIES[3].getNextTarget(level - 1);
				}
				// Logarithmischer Fortschritt f√ºr h√∂here Levels
				if (level > 2) {
					const logValue = Math.log10(value);
					const logTarget = Math.log10(nextTarget);
					const logPrevTarget = Math.log10(prevTarget);
					return Math.min(100, Math.max(0, ((logValue - logPrevTarget) / (logTarget - logPrevTarget)) * 100));
				}
				return Math.min(100, Math.max(0, ((value - prevTarget) / (nextTarget - prevTarget)) * 100));
			}
		}
	];

	// VER√ÑNDERT: √úberarbeitete CHALLENGES mit progressiveren Zielen
	const CHALLENGES = [
		{description: 'Erzeuge eine Kette mit mindestens 3 Verschmelzungen', target: 3, type: 'chain', reward: 500},
		{description: 'Erreiche eine 16er-Blase', target: 16, type: 'value', reward: 750},
		{description: 'Sammle 1.000 Punkte in einem Spiel', target: 1000, type: 'score', reward: 1000},
		{description: 'Erzeuge eine Kette mit mindestens 4 Verschmelzungen', target: 4, type: 'chain', reward: 1500},
		{description: 'Erreiche eine 32er-Blase', target: 32, type: 'value', reward: 2000},
		{description: 'Sammle 2.000 Punkte in einem Spiel', target: 2000, type: 'score', reward: 2500},
		{description: 'Erzeuge eine Kette mit mindestens 5 Verschmelzungen', target: 5, type: 'chain', reward: 3500},
		{description: 'Erreiche eine 64er-Blase', target: 64, type: 'value', reward: 5000}
	];

	// Verf√ºgbare Upgrades
	const UPGRADES = [
		{
			id: 'grid_7',
			title: 'Spielfeld 7x7',
			description: 'Erweitere dein Spielfeld auf 7x7 Zellen',
			cost: 10000,
			gridSize: 7,
			requires: []
		},
		{
			id: 'grid_8',
			title: 'Spielfeld 8x8',
			description: 'Erweitere dein Spielfeld auf 8x8 Zellen',
			cost: 30000,
			gridSize: 8,
			requires: ['grid_7']
		},
		{
			id: 'grid_9',
			title: 'Spielfeld 9x9',
			description: 'Erweitere dein Spielfeld auf 9x9 Zellen',
			cost: 75000,
			gridSize: 9,
			requires: ['grid_8']
		},
		{
			id: 'grid_10',
			title: 'Spielfeld 10x10',
			description: 'Erweitere dein Spielfeld auf 10x10 Zellen (Maximum)',
			cost: 150000,
			gridSize: 10,
			requires: ['grid_9']
		},
		{
			id: 'chain_bonus',
			title: 'Kettenbonus +50%',
			description: 'Erh√∂he deine Punkteausbeute bei Kettenreaktionen um 50%',
			cost: 2500,
			requires: ['grid_7']
		},
		{
			id: 'score_bonus',
			title: 'Punkte +25%',
			description: 'Erh√∂he deine Grundpunktezahl um 25%',
			cost: 5000,
			requires: ['grid_8']
		},
		{
			id: 'mode_timeAttack',
			title: 'Zeit-Modus freischalten',
			description: 'Schalte den Zeit-Modus frei, in dem jede Verschmelzung zus√§tzliche Zeit gibt',
			cost: 25000,
			requires: ['grid_8']
		},
		{
			id: 'mode_colorBlind',
			title: 'Farbmuster-Modus freischalten',
			description: 'Schalte den Farbmuster-Modus frei, mit speziellen Mustern statt Farben',
			cost: 35000,
			requires: ['grid_8']
		}
	];

	// Spezial-Modi Beschreibungen
	const MODE_DESCRIPTIONS = {
		normal: '<strong>Standard-Modus:</strong> Das klassische Bubble Merge Spielerlebnis.',
		gravity: '<strong>Schwerkraft-Modus:</strong> Blasen fallen nach jeder Bewegung nach unten. Erzeuge Kaskadeneffekte!',
		timeAttack: '<strong>Zeit-Modus:</strong> Du hast nur begrenzte Zeit. Jede Verschmelzung gibt dir zus√§tzliche Sekunden.',
		colorBlind: '<strong>Farbmuster-Modus:</strong> Blasen haben spezielle Muster statt Farben.'
	};

	// √úbersetzungs-Funktion
	function translate(text) {
		// Vereinfachte Version der √úbersetzungsfunktion
		return text.de;
	}

	// DOM-Elemente - Hier 'let' statt 'const' f√ºr Elemente, die sp√§ter aktualisiert werden
	const gameContainer = document.getElementById('game-container');
	let gridOverlay = document.getElementById('grid-overlay');
	const nextBubbleContainer = document.getElementById('next-bubble');
	const goalBubbleContainer = document.getElementById('goal-bubble');
	const goalProgress = document.getElementById('goal-progress');
	let chainCounter = document.getElementById('chain-counter');
	const scoreElement = document.querySelector('.score');
	const coinsElement = document.getElementById('coins-display');
	const levelElement = document.querySelector('.level');
	const themeToggle = document.getElementById('theme-toggle');
	const moonIcon = document.querySelector('.moon-icon');
	const sunIcon = document.querySelector('.sun-icon');
	const restartButton = document.getElementById('restart-button');
	const statsButton = document.getElementById('stats-button');
	const gameOverModal = document.getElementById('game-over-modal');
	const statsModal = document.getElementById('stats-modal');
	const finalScoreElement = document.getElementById('final-score');
	const highestBubbleElement = document.getElementById('highest-bubble');
	const highestValueElement = document.getElementById('highest-value');
	const longestChainElement = document.getElementById('longest-chain');
	const playedTimeElement = document.getElementById('played-time');
	const totalMovesElement = document.getElementById('total-moves');
	const playAgainButton = document.getElementById('play-again-button');
	const shareButton = document.getElementById('share-button');
	const tutorialModal = document.getElementById('tutorial-modal');
	const startGameButton = document.getElementById('start-game-button');
	const tutorialsContainer = document.getElementById('tutorials-container');
	const statsHighscoreElement = document.getElementById('stats-highscore');
	const statsHighestBubbleElement = document.getElementById('stats-highest-bubble');
	const statsLongestChainElement = document.getElementById('stats-longest-chain');
	const statsGamesPlayedElement = document.getElementById('stats-games-played');
	const statsGridSizeElement = document.getElementById('stats-grid-size');
	const statsCoinsElement = document.getElementById('stats-coins-value');
	const statsCurrentScoreElement = document.getElementById('stats-current-score');
	const achievementsContainer = document.getElementById('achievements-container');
	const challengeDescription = document.getElementById('challenge-description');
	const challengeProgressBar = document.getElementById('challenge-progress-bar');
	const challengeProgressText = document.getElementById('challenge-progress-text');
	const challengeReward = document.getElementById('challenge-reward');
	const closeStatsButton = document.getElementById('close-stats-button');
	const resetStatsButton = document.getElementById('reset-stats-button');
	const upgradesContainer = document.getElementById('upgrades-container');
	const tabButtons = document.querySelectorAll('.tab-button');
	const tabContents = document.querySelectorAll('.tab-content');
	const modeButtons = document.querySelectorAll('.mode-button');
	const activeModeDescription = document.getElementById('active-mode-description');
	const specialModeBanner = document.getElementById('special-mode-banner');
	let specialModeIndicator = document.getElementById('special-mode-indicator');

	// Konstanten
	const BUBBLE_COLORS = [
		'#f87171', // rot
		'#facc15', // gelb
		'#4ade80', // gr√ºn
		'#60a5fa', // blau
		'#a78bfa', // lila
		'#f472b6', // pink
		'#fb923c', // orange
		'#22d3ee'  // t√ºrkis
	];

	// Formatierungsfunktion f√ºr gro√üe Zahlen
	function toFixedMax1(num) {
		// Stelle sicher, dass z.B. 1.0 zu 1 wird.
		return parseFloat(num.toFixed(1));
	}

	function formatNumber(num) {
		if (num < 1000) return parseFloat(num);
		if (num < 1000000) return parseFloat((num / 1000).toFixed(1)) + 'K';
		if (num < 1000000000) return parseFloat((num / 1000000).toFixed(1)) + 'M';
		return parseFloat((num / 1000000000).toFixed(1)) + 'G';
	}

	// Zeit-Formatierung
	function formatTime(seconds) {
		const mins = Math.floor(seconds / 60);
		const secs = seconds % 60;
		return `${mins}:${secs.toString().padStart(2, '0')}`;
	}

	// Hilfsfunktionen
	function getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	function calculateBubbleSize() {
		const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);

		// F√ºr kleine Bildschirme: Gr√∂√üere Bubble-zu-Grid-Verh√§ltnis f√ºr bessere Bedienbarkeit
		let sizeRatio;
		if (window.innerWidth <= 360) {
			sizeRatio = 0.9;  // 90% der Zellgr√∂√üe f√ºr sehr kleine Bildschirme
		} else if (window.innerWidth <= 600) {
			sizeRatio = 0.88; // 88% f√ºr kleine Bildschirme
		} else {
			sizeRatio = 0.85; // 85% f√ºr normale Bildschirme
		}

		return (containerSize / gameState.gridSize) * sizeRatio;
	}

	function getBubblePosition(row, col) {
		const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);
		const cellSize = containerSize / gameState.gridSize;
		const bubbleSize = calculateBubbleSize();
		const offsetX = (cellSize - bubbleSize) / 2;
		const offsetY = (cellSize - bubbleSize) / 2;

		return {
			x: col * cellSize + offsetX,
			y: row * cellSize + offsetY
		};
	}

	function getGridCellFromPosition(x, y) {
		const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);
		const cellSize = containerSize / gameState.gridSize;

		const col = Math.floor(x / cellSize);
		const row = Math.floor(y / cellSize);

		// Bounds check
		if (row >= 0 && row < gameState.gridSize && col >= 0 && col < gameState.gridSize) {
			return {row, col};
		}

		return null;
	}

	function createBubbleElement(level, row, col, isNext = false) {
		const bubble = document.createElement('div');
		bubble.className = 'bubble new-bubble';

		const size = isNext ? (window.innerWidth <= 360 ? 40 : window.innerWidth <= 600 ? 50 : 60) : calculateBubbleSize();
		bubble.style.width = `${size}px`;
		bubble.style.height = `${size}px`;

		// Verbesserte Farbgebung mit Helligkeitsanpassung
		const colorIndex = (level - 1) % BUBBLE_COLORS.length;
		const baseColor = BUBBLE_COLORS[colorIndex];

		// Glasartiger Effekt basierend auf Level
		bubble.style.backgroundColor = baseColor;

		const inner = document.createElement('div');
		inner.className = 'bubble-inner';

		// Wert berechnen (2^level)
		const value = Math.pow(2, level);
		inner.textContent = formatNumber(value);

		// Schriftgr√∂√üe f√ºr gr√∂√üere Zahlen anpassen
		if (value >= 1000000) {
			inner.style.fontSize = '0.8em';
		} else if (value >= 10000) {
			inner.style.fontSize = '0.9em';
		}

		bubble.appendChild(inner);

		if (!isNext) {
			const pos = getBubblePosition(row, col);
			bubble.style.left = `${pos.x}px`;
			bubble.style.top = `${pos.y}px`;

			// Datenspeicherung f√ºr einfachen Zugriff
			bubble.dataset.row = row;
			bubble.dataset.col = col;
			bubble.dataset.level = level;
			bubble.dataset.value = value;

			// Event-Listener f√ºr Desktop
			bubble.addEventListener('mousedown', startDragging);

			// Event-Listener f√ºr Touch-Ger√§te
			bubble.addEventListener('touchstart', handleTouchStart, {passive: false});
		} else {
			bubble.style.position = 'relative';
			bubble.style.left = '0';
			bubble.style.top = '0';
		}

		return bubble;
	}

	// VER√ÑNDERT: Verbesserte Bubble-Erzeugung f√ºr strategischeres Gameplay
	function createRandomBubble() {
		// Wahrscheinlichkeiten basierend auf dem aktuellen Spielfortschritt
		const maxPossibleLevel = Math.min(gameState.maxLevel, 4);
		const progressFactor = Math.min(gameState.score / 3000, 1); // Progression bis 3000 Punkte

		// Analyse des aktuellen Spielfelds
		const bubbleCounts = {};
		for (let row = 0; row < gameState.gridSize; row++) {
			for (let col = 0; col < gameState.gridSize; col++) {
				const level = gameState.grid[row][col];
				if (level) {
					bubbleCounts[level] = (bubbleCounts[level] || 0) + 1;
				}
			}
		}

		// Falls es weniger als 2 Blasen eines bestimmten Levels gibt, diese bevorzugt erzeugen
		const underrepresentedLevels = [];
		for (let i = 1; i <= Math.min(maxPossibleLevel, 3); i++) {
			if ((bubbleCounts[i] || 0) < 2) {
				underrepresentedLevels.push(i);
			}
		}

		let level;
		const rand = Math.random();

		// 30% Chance, ein unterrepr√§sentiertes Level zu w√§hlen
		if (underrepresentedLevels.length > 0 && rand < 0.3) {
			const index = Math.floor(Math.random() * underrepresentedLevels.length);
			level = underrepresentedLevels[index];
		} else if (rand < 0.7 - (0.2 * progressFactor)) {
			// Basis-Chance f√ºr Level 1 (sinkt von 70% auf 50% bei hoher Punktzahl)
			level = 1;
		} else if (rand < 0.9 - (0.1 * progressFactor)) {
			// Chance f√ºr Level 2 (bleibt etwa bei 20%)
			level = Math.min(2, maxPossibleLevel);
		} else if (rand < 0.98) {
			// Chance f√ºr Level 3 (steigt leicht an)
			level = Math.min(3, maxPossibleLevel);
		} else {
			// Kleine Chance f√ºr h√∂here Level (bis zum bisher erreichten)
			level = getRandomInt(1, maxPossibleLevel);
		}

		return level;
	}

	function addNewBubble() {
		// Finde eine leere Zelle
		const emptyCells = [];

		// Pr√ºfe, ob das Grid ordnungsgem√§√ü initialisiert wurde
		if (!gameState.grid || !Array.isArray(gameState.grid) || gameState.grid.length === 0) {
			console.error("Grid wurde nicht richtig initialisiert!");
			gameState.grid = [];
			for (let i = 0; i < gameState.gridSize; i++) {
				gameState.grid[i] = new Array(gameState.gridSize).fill(null);
			}
		}

		// Bei Schwerkraft-Modus bevorzugt oberste Reihe verwenden
		if (gameState.gravityEnabled) {
			for (let col = 0; col < gameState.gridSize; col++) {
				if (!gameState.grid[0][col]) {
					emptyCells.push({row: 0, col: col});
				}
			}

			// Falls oberste Reihe voll ist, andere Zellen suchen
			if (emptyCells.length === 0) {
				for (let row = 1; row < gameState.gridSize; row++) {
					for (let col = 0; col < gameState.gridSize; col++) {
						if (!gameState.grid[row][col]) {
							emptyCells.push({row, col});
						}
					}
				}
			}
		} else {
			// Normal-Modus: Alle leeren Zellen ber√ºcksichtigen
			for (let row = 0; row < gameState.gridSize; row++) {
				for (let col = 0; col < gameState.gridSize; col++) {
					if (!gameState.grid[row][col]) {
						emptyCells.push({row, col});
					}
				}
			}
		}

		// Wenn keine leeren Zellen mehr, Spiel vorbei
		if (emptyCells.length === 0) {
			gameOver();
			return false;
		}

		// Zuf√§llige leere Zelle ausw√§hlen
		const cellIndex = getRandomInt(0, emptyCells.length - 1);
		const {row, col} = emptyCells[cellIndex];

		// Neue Blase mit dem vorbereiteten Level hinzuf√ºgen
		const level = gameState.nextBubble;
		const bubble = createBubbleElement(level, row, col);
		gameContainer.appendChild(bubble);
		gameState.grid[row][col] = level;
		gameState.bubbles.push(bubble);

		// Neue n√§chste Blase vorbereiten
		prepareNextBubble();

		// Bei Schwerkraft-Modus: Nach dem Hinzuf√ºgen Schwerkraft anwenden
		if (gameState.gravityEnabled) {
			setTimeout(() => {
				applyGravity();
			}, 100);
		}

		// Pr√ºfe, ob es m√∂gliche Z√ºge gibt
		if (emptyCells.length === 1) {
			setTimeout(checkForPossibleMoves, 300);
		}

		// Chain-Counter zur√ºcksetzen, wenn Zug abgeschlossen
		resetChainCounter();

		return true;
	}

	function prepareNextBubble() {
		gameState.nextBubble = createRandomBubble();
		nextBubbleContainer.innerHTML = '';
		const bubble = createBubbleElement(gameState.nextBubble, 0, 0, true);
		nextBubbleContainer.appendChild(bubble);
	}

	function updateGoalDisplay() {
		// Ziel-Blase anzeigen (die n√§chste zu erreichende Blase)
		const goalLevel = Math.log2(gameState.currentGoal);
		goalBubbleContainer.innerHTML = '';
		const bubble = createBubbleElement(goalLevel, 0, 0, true);
		goalBubbleContainer.appendChild(bubble);

		// Fortschrittsbalken aktualisieren
		goalProgress.style.width = `${gameState.goalProgress}%`;
	}

	function startDragging(e) {
		if (gameState.gameOver || gameState.processingChain) return;

		const bubble = e.currentTarget;
		const rect = bubble.getBoundingClientRect();

		gameState.draggedBubble = bubble;
		gameState.dragOffsetX = e.clientX - rect.left;
		gameState.dragOffsetY = e.clientY - rect.top;

		bubble.classList.add('dragging');

		document.addEventListener('mousemove', onDrag);
		document.addEventListener('mouseup', stopDragging);

		e.preventDefault();
	}

	function handleTouchStart(e) {
		if (gameState.gameOver || gameState.processingChain) return;

		const bubble = e.currentTarget;
		const touch = e.touches[0];
		const rect = bubble.getBoundingClientRect();

		gameState.draggedBubble = bubble;
		gameState.dragOffsetX = touch.clientX - rect.left;
		gameState.dragOffsetY = touch.clientY - rect.top;

		bubble.classList.add('dragging');

		document.addEventListener('touchmove', handleTouchMove, {passive: false});
		document.addEventListener('touchend', handleTouchEnd);

		e.preventDefault();
	}

	function handleTouchMove(e) {
		if (!gameState.draggedBubble) return;

		const touch = e.touches[0];
		onDrag({
			clientX: touch.clientX,
			clientY: touch.clientY,
			preventDefault: () => e.preventDefault()
		});
	}

	function handleTouchEnd() {
		stopDragging();
		document.removeEventListener('touchmove', handleTouchMove);
		document.removeEventListener('touchend', handleTouchEnd);
	}

	function onDrag(e) {
		if (!gameState.draggedBubble) return;

		const containerRect = gameContainer.getBoundingClientRect();
		const x = e.clientX - containerRect.left - gameState.dragOffsetX;
		const y = e.clientY - containerRect.top - gameState.dragOffsetY;

		gameState.draggedBubble.style.left = `${x}px`;
		gameState.draggedBubble.style.top = `${y}px`;

		e.preventDefault();
	}

	// VER√ÑNDERT: Verbesserte Bewegungsmechanik f√ºr intuitiveres Spielgef√ºhl
	function stopDragging() {
		if (!gameState.draggedBubble) return;

		const bubble = gameState.draggedBubble;
		const oldRow = parseInt(bubble.dataset.row);
		const oldCol = parseInt(bubble.dataset.col);
		const level = parseInt(bubble.dataset.level);

		// Position im Container
		const containerRect = gameContainer.getBoundingClientRect();
		const bubbleRect = bubble.getBoundingClientRect();
		const bubbleCenterX = bubbleRect.left + bubbleRect.width / 2 - containerRect.left;
		const bubbleCenterY = bubbleRect.top + bubbleRect.height / 2 - containerRect.top;

		// Zielzelle finden mit verbesserter Toleranz
		const targetCell = getGridCellFromPosition(bubbleCenterX, bubbleCenterY);

		// Blase zur√ºck zur Ausgangsposition animieren
		bubble.classList.remove('dragging');

		let moveMade = false;

		if (targetCell) {
			const {row, col} = targetCell;

			// Gleiche Zelle - kein Zug
			if (row === oldRow && col === oldCol) {
				const pos = getBubblePosition(oldRow, oldCol);
				bubble.style.left = `${pos.x}px`;
				bubble.style.top = `${pos.y}px`;
				gameState.draggedBubble = null;
				return;
			}

			// Debug ausgeben (zum Testen, kann sp√§ter entfernt werden)
			console.log(`Bewegung von [${oldRow},${oldCol}] nach [${row},${col}]`);
			console.log(`Zielzelle enth√§lt: ${gameState.grid[row][col]}, Blase Level: ${level}`);

			// Zuerst pr√ºfen, ob die Zielzelle bereits belegt ist
			if (gameState.grid[row][col] !== null) {
				console.log("Zelle ist belegt");

				// Wenn Zielzelle belegt ist, pr√ºfe, ob gleiches Level
				if (gameState.grid[row][col] === level) {
					console.log("Gleiches Level, versuche zu verschmelzen");
					// Gleiche Blasen verschmelzen
					gameState.grid[oldRow][oldCol] = null;

					// Zielblase finden
					const targetBubble = gameState.bubbles.find(
						b => parseInt(b.dataset.row) === row && parseInt(b.dataset.col) === col
					);

					if (targetBubble) {
						console.log("Zielblase gefunden, verschmelze");
						// Level erh√∂hen
						gameState.grid[row][col] = level + 1;

						// Effekt und Animation
						queueMerge(bubble, targetBubble, level + 1, row, col);

						moveMade = true;

						// Starte Kettenreaktion-Z√§hler
						startChainReaction();

						// Achievement-Fortschritt f√ºr Blasenwert aktualisieren
						const newValue = Math.pow(2, level + 1);
						updateAchievementProgress('bubbles', newValue);

						// Tutorial-Fortschritt
						if (gameState.tutorialStep === 2) {
							showTutorial(3);
						}
					} else {
						console.log("Zielblase nicht gefunden, Fehler!");
						// Fallback: Zur√ºck zur alten Position
						const pos = getBubblePosition(oldRow, oldCol);
						bubble.style.left = `${pos.x}px`;
						bubble.style.top = `${pos.y}px`;
					}
				} else {
					console.log("Unterschiedliches Level, kann nicht verschmelzen");
					// Verbesserte Feedback-Animation f√ºr ungleiche Levels
					const pos = getBubblePosition(oldRow, oldCol);
					bubble.style.left = `${pos.x}px`;
					bubble.style.top = `${pos.y}px`;

					// Sanfteres Feedback
					bubble.style.transition = "all 0.3s ease-in-out";
					bubble.style.transform = "scale(0.9)";
					setTimeout(() => {
						bubble.style.transform = "";
						setTimeout(() => {
							bubble.style.transition = "";
						}, 300);
					}, 300);

					// Visuelles Feedback auch f√ºr die Zielblase
					const targetBubble = gameState.bubbles.find(
						b => parseInt(b.dataset.row) === row && parseInt(b.dataset.col) === col
					);

					if (targetBubble) {
						targetBubble.style.transition = "all 0.3s ease-in-out";
						targetBubble.style.transform = "scale(1.1)";
						setTimeout(() => {
							targetBubble.style.transform = "";
							setTimeout(() => {
								targetBubble.style.transition = "";
							}, 300);
						}, 300);
					}
				}
			} else {
				console.log("Zelle ist leer, bewege Blase");
				// Zelle ist leer - einfach bewegen
				gameState.grid[oldRow][oldCol] = null;
				gameState.grid[row][col] = level;

				bubble.dataset.row = row;
				bubble.dataset.col = col;

				const pos = getBubblePosition(row, col);
				bubble.style.left = `${pos.x}px`;
				bubble.style.top = `${pos.y}px`;

				moveMade = true;

				// Pr√ºfe nach der Bewegung, ob dies Kettenreaktionen ausl√∂sen kann
				const neighbors = [
					{row: row - 1, col: col},  // oben
					{row: row + 1, col: col},  // unten
					{row: row, col: col - 1},  // links
					{row: row, col: col + 1}   // rechts
				];

				for (const n of neighbors) {
					if (n.row >= 0 && n.row < gameState.gridSize &&
						n.col >= 0 && n.col < gameState.gridSize &&
						gameState.grid[n.row][n.col] === level) {

						// Highlight der m√∂glichen Verschmelzung
						const neighborBubble = gameState.bubbles.find(
							b => parseInt(b.dataset.row) === n.row && parseInt(b.dataset.col) === n.col
						);

						if (neighborBubble) {
							neighborBubble.style.boxShadow = "0 0 8px var(--chain-highlight)";
							setTimeout(() => {
								neighborBubble.style.boxShadow = "";
							}, 500);
						}
					}
				}

				// Tutorial-Fortschritt
				if (gameState.tutorialStep === 1) {
					showTutorial(2);
				}
			}
		} else {
			// Au√üerhalb des Spielfelds, zur√ºck zur Ausgangsposition mit Animation
			const pos = getBubblePosition(oldRow, oldCol);
			bubble.style.transition = "all 0.3s ease-in-out";
			bubble.style.left = `${pos.x}px`;
			bubble.style.top = `${pos.y}px`;

			setTimeout(() => {
				bubble.style.transition = "";
			}, 300);
		}

		gameState.draggedBubble = null;

		document.removeEventListener('mousemove', onDrag);
		document.removeEventListener('mouseup', stopDragging);

		// Neue Blase nach erfolgreichem Zug hinzuf√ºgen
		if (moveMade) {
			gameState.moveMade = true;
			gameState.moves++;

			// Nach dem 5. Zug Tipps anzeigen, wenn n√∂tig
			setupChainReactionTips();

			// Auto-Save nach erfolgreicher Bewegung
			saveStatsToStorage();

			// Verz√∂gerung, um Kettenreaktionen abzuwarten
			checkQueue(function () {
				if (!gameState.gameOver) {
					// Bei Schwerkraft-Modus: Schwerkraft anwenden
					if (gameState.gravityEnabled) {
						applyGravity(function () {
							addNewBubble();
						});
					} else {
						addNewBubble();
					}
				}
			});
		}
	}

	// VER√ÑNDERT: Verbesserte Version von startChainReaction f√ºr besseres Feedback
	function startChainReaction() {
		// Erh√∂he Z√§hler und zeige ihn
		gameState.chainCount++;
		updateChainCounter();

		// Ab 3er-Kette: Visuelles Feedback verst√§rken
		if (gameState.chainCount >= 3) {
			// Kurzes Aufleuchten des Spielfelds
			gameContainer.style.boxShadow = "0 0 15px var(--chain-highlight)";
			setTimeout(() => {
				gameContainer.style.boxShadow = "";
			}, 300);

			// Kleines Tutorial-Popup f√ºr die erste lange Kette
			if (gameState.chainCount === 3 && gameState.stats.longestChain < 3) {
				createScorePopup("Kettenbonus! +50%",
					gameContainer.offsetWidth / 2,
					gameContainer.offsetHeight / 2 - 40,
					true);
			}
		}
	}

	function updateChainCounter() {
		// Zeige den Chain-Counter nur bei mehr als 1 Verschmelzung
		if (gameState.chainCount > 1) {
			chainCounter.textContent = `x${gameState.chainCount}`;
			chainCounter.style.opacity = '1';

			// Herausforderungen pr√ºfen
			checkChallengeProgress('chain', gameState.chainCount);

			// Update l√§ngste Kette im Spiel
			if (gameState.chainCount > gameState.longestChain) {
				gameState.longestChain = gameState.chainCount;

				// Auch direkt in den Statistiken aktualisieren
				if (gameState.longestChain > gameState.stats.longestChain) {
					gameState.stats.longestChain = gameState.longestChain;

					// Achievement-Fortschritt f√ºr Ketten aktualisieren
					updateAchievementProgress('chains', gameState.longestChain);

					// Speichern der aktualisierten Statistik
					saveStatsToStorage();
				}
			}
		}
	}

	function resetChainCounter() {
		gameState.chainCount = 0;
		chainCounter.style.opacity = '0';
	}

	function queueMerge(bubble1, bubble2, newLevel, row, col, isChain = false) {
		gameState.processingChain = true;

		// F√ºge Verschmelzung zur Queue hinzu
		gameState.mergeQueue.push({
			bubble1: bubble1,
			bubble2: bubble2,
			newLevel: newLevel,
			row: row,
			col: col,
			isChain: isChain
		});

		// Im Zeit-Modus: Bonus-Zeit f√ºr erfolgreiche Verschmelzung
		if (gameState.specialMode === 'timeAttack') {
			addTimeAttackBonus(newLevel);
		}

		// Starte die Verarbeitung, wenn sie nicht bereits l√§uft
		if (gameState.mergeQueue.length === 1) {
			processNextMerge();
		}
	}

	// Verarbeite die n√§chste Verschmelzung in der Queue
	function processNextMerge() {
		if (gameState.mergeQueue.length === 0) {
			gameState.processingChain = false;
			return;
		}

		const merge = gameState.mergeQueue[0];
		const {bubble1, bubble2, newLevel, row, col, isChain} = merge;

		// Sicherheitscheck
		if (!bubble1 || !bubble2 || !bubble1.parentNode || !bubble2.parentNode) {
			gameState.mergeQueue.shift();
			processNextMerge();
			return;
		}

		// Aktualisiere h√∂chstes Level
		if (newLevel > gameState.maxLevel) {
			gameState.maxLevel = newLevel;
			const newValue = Math.pow(2, newLevel);
			gameState.maxValue = newValue;

			// Achievement-Fortschritt f√ºr Blasenwert aktualisieren
			updateAchievementProgress('bubbles', newValue);

			// Pr√ºfe, ob wir das Ziel erreicht haben
			if (newValue >= gameState.currentGoal) {
				// Neues Ziel setzen (n√§chste Potenz von 2)
				gameState.currentGoal = gameState.currentGoal * 2;
				gameState.goalProgress = 0;

				// Bonuspunkte f√ºr Zielerreichung
				const bonus = newValue * 2;
				updateScore(bonus, true);
				createScorePopup(`ZIEL! +${formatNumber(bonus)}`, row, col, true);
			} else {
				// Fortschritt zum Ziel aktualisieren (logarithmisch)
				const progress = (Math.log2(newValue) / Math.log2(gameState.currentGoal)) * 100;
				gameState.goalProgress = Math.min(progress, 99); // Nie ganz 100% erreichen, bis zum tats√§chlichen Ziel
			}

			updateGoalDisplay();

			// Pr√ºfe Challenge-Fortschritt f√ºr Werte
			checkChallengeProgress('value', newValue);
		}

		// Animation f√ºr die zweite Blase
		bubble2.classList.add(isChain ? 'chain-merge' : 'merging');

		// Entferne die erste Blase sofort
		if (bubble1 && bubble1.parentNode) {
			bubble1.remove();
		}

		// Aktualisiere die Blasen-Liste
		gameState.bubbles = gameState.bubbles.filter(b => b !== bubble1);

		// Punkte hinzuf√ºgen mit Chain-Bonus
		const chainMultiplier = Math.max(1, isChain ? Math.min(gameState.chainCount, 10) : 1);

		// Verbesserter Chain-Bonus mit Upgrades
		let bonusMultiplier = 1;
		if (gameState.stats.upgrades.includes('chain_bonus')) {
			bonusMultiplier = 1.5; // +50% f√ºr Chain-Bonus-Upgrade
		}

		// Anwendung des verbesserten Multiplikators
		const effectiveMultiplier = chainMultiplier * bonusMultiplier;
		const points = Math.pow(2, newLevel) * 5 * effectiveMultiplier;

		updateScore(points);

		// Punkte-Popup
		const pos = getBubblePosition(row, col);
		if (effectiveMultiplier > 1) {
			createScorePopup(`+${formatNumber(points)} (x${effectiveMultiplier.toFixed(1)})`, pos.x, pos.y, true);
		} else {
			createScorePopup(`+${formatNumber(points)}`, pos.x, pos.y);
		}

		// Nach Animationszeit die aktualisierte Blase zeigen
		setTimeout(() => {
			// Nochmals pr√ºfen, ob die Blase noch existiert
			if (bubble2 && bubble2.parentNode) {
				bubble2.dataset.level = newLevel;
				const value = Math.pow(2, newLevel);
				bubble2.dataset.value = value;

				const bubbleInner = bubble2.querySelector('.bubble-inner');
				if (bubbleInner) {
					bubbleInner.textContent = formatNumber(value);
				}

				const colorIndex = (newLevel - 1) % BUBBLE_COLORS.length;
				bubble2.style.backgroundColor = BUBBLE_COLORS[colorIndex];

				bubble2.classList.remove(isChain ? 'chain-merge' : 'merging');

				// Entferne diese Verschmelzung aus der Queue
				gameState.mergeQueue.shift();

				// Pr√ºfe m√∂gliche Nachbar-Verschmelzungen (nur direkte Nachbarn)
				checkAdjacentMerges(row, col, newLevel);

				// Verarbeite die n√§chste Verschmelzung in der Queue
				setTimeout(processNextMerge, 50);
			} else {
				// Fallback, wenn die Blase nicht mehr existiert
				gameState.mergeQueue.shift();
				processNextMerge();
			}

			// Im Zeit-Modus: Bonus-Zeit hinzuf√ºgen
			if (gameState.specialMode === 'timeAttack') {
				addTimeAttackBonus(newLevel);
			}
		}, 300);
	}

	// Pr√ºft, ob die Queue leer ist und ruft den Callback auf
	function checkQueue(callback) {
		if (gameState.mergeQueue.length === 0) {
			gameState.processingChain = false;
			if (callback) callback();
		} else {
			// Warte, bis die Queue leer ist
			setTimeout(() => checkQueue(callback), 100);
		}
	}

	// VER√ÑNDERT: Verbesserte Funktion zum Pr√ºfen benachbarter Verschmelzungen
	function checkAdjacentMerges(row, col, level) {
		// Erweiterte Suche nach Nachbarn (auch Diagonalen und weiter entfernte f√ºr Schwerkraftmodus)
		const neighbors = [];

		// Direkte Nachbarn (keine Diagonalen)
		neighbors.push({row: row - 1, col: col});  // oben
		neighbors.push({row: row + 1, col: col});  // unten
		neighbors.push({row: row, col: col - 1});  // links
		neighbors.push({row: row, col: col + 1});  // rechts

		// Filtere g√ºltige Nachbarn
		const validNeighbors = neighbors.filter(n =>
			n.row >= 0 && n.row < gameState.gridSize &&
			n.col >= 0 && n.col < gameState.gridSize &&
			gameState.grid[n.row][n.col] === level
		);

		if (validNeighbors.length > 0) {
			// W√§hle einen zuf√§lligen passenden Nachbarn - das erh√∂ht die Chancen auf verschiedene Kettenreaktionen
			const randomIndex = Math.floor(Math.random() * validNeighbors.length);
			const target = validNeighbors[randomIndex];

			// Finde Quell- und Ziel-Blasen
			const sourceBubble = gameState.bubbles.find(
				b => parseInt(b.dataset.row) === row && parseInt(b.dataset.col) === col
			);

			const targetBubble = gameState.bubbles.find(
				b => parseInt(b.dataset.row) === target.row && parseInt(b.dataset.col) === target.col
			);

			// Sicherheitscheck
			if (!sourceBubble || !targetBubble) {
				return false;
			}

			// Aktualisiere das Spielfeld
			gameState.grid[row][col] = null;
			gameState.grid[target.row][target.col] = level + 1;

			// Erh√∂he Kettenreaktion-Z√§hler
			startChainReaction();

			// F√ºge neue Verschmelzung zur Queue hinzu
			queueMerge(sourceBubble, targetBubble, level + 1, target.row, target.col, true);

			return true;
		}

		return false;
	}

	// VER√ÑNDERT: Verbesserte applyGravity Funktion f√ºr bessere Kettenreaktionen
	function applyGravity(callback) {
		if (!gameState.gravityEnabled) {
			if (callback) callback();
			return;
		}

		let movesMade = 0;
		const movesNeeded = [];

		// Gehe von unten nach oben durch das Spielfeld
		for (let col = 0; col < gameState.gridSize; col++) {
			for (let row = gameState.gridSize - 1; row > 0; row--) {
				// Wenn aktuelle Zelle leer ist
				if (!gameState.grid[row][col]) {
					// Suche nach der n√§chsten nicht-leeren Zelle dar√ºber
					for (let above = row - 1; above >= 0; above--) {
						if (gameState.grid[above][col]) {
							// Verschiebe diese Blase nach unten
							movesNeeded.push({
								fromRow: above,
								fromCol: col,
								toRow: row,
								toCol: col,
								level: gameState.grid[above][col]
							});

							// Aktualisiere das Grid sofort
							gameState.grid[row][col] = gameState.grid[above][col];
							gameState.grid[above][col] = null;

							movesMade++;
							break; // Zur n√§chsten leeren Zelle
						}
					}
				}
			}
		}

		// Wende die Verschiebungen an
		if (movesMade > 0) {
			movesNeeded.forEach(move => {
				const bubble = gameState.bubbles.find(
					b => parseInt(b.dataset.row) === move.fromRow && parseInt(b.dataset.col) === move.fromCol
				);

				if (bubble) {
					// Aktualisiere die Blasendaten
					bubble.dataset.row = move.toRow;
					bubble.dataset.col = move.toCol;

					// F√ºge Fallanimation hinzu
					bubble.classList.add('falling');

					// Setze neue Position
					const pos = getBubblePosition(move.toRow, move.toCol);
					bubble.style.left = `${pos.x}px`;
					bubble.style.top = `${pos.y}px`;
				}
			});

			// Warte auf die Animation und pr√ºfe dann auf Kettenreaktionen
			setTimeout(() => {
				// Entferne Fallanimationen
				movesNeeded.forEach(move => {
					const bubble = gameState.bubbles.find(
						b => parseInt(b.dataset.row) === move.toRow && parseInt(b.dataset.col) === move.toCol
					);
					if (bubble) {
						bubble.classList.remove('falling');
					}
				});

				// Pr√ºfe auf Verschmelzungen nacheinander, um Kaskaden zu erm√∂glichen
				const checkNextMove = (index) => {
					if (index >= movesNeeded.length) {
						// Alle Bewegungen gepr√ºft, pr√ºfe ob weitere Schwerkraft-Anwendung n√∂tig ist
						if (movesMade > 0) {
							setTimeout(() => {
								applyGravity(callback);
							}, 50);
						} else if (callback) {
							callback();
						}
						return;
					}

					const move = movesNeeded[index];
					const level = move.level;

					// Pr√ºfe auf Verschmelzungen nach dem Fallen
					const merged = checkAdjacentMerges(move.toRow, move.toCol, level);

					// Wenn eine Verschmelzung stattgefunden hat, warten wir auf deren Abschluss
					if (merged) {
						checkQueue(() => {
							// Zur n√§chsten Bewegung
							checkNextMove(index + 1);
						});
					} else {
						// Keine Verschmelzung, direkt zur n√§chsten Bewegung
						checkNextMove(index + 1);
					}
				};

				// Starte mit der ersten Bewegung
				checkNextMove(0);

			}, 300);
		} else {
			// Keine Verschiebungen mehr n√∂tig
			if (callback) callback();
		}
	}

	function updateScore(points, isBonus = false, skipChallengeCheck = false) {
		// Bonus f√ºr Punkte-Upgrade
		if (gameState.stats.upgrades.includes('score_bonus')) {
			points = Math.floor(points * 1.25); // +25% f√ºr Punkte-Bonus-Upgrade
		}

		gameState.score += points;
		scoreElement.textContent = formatNumber(gameState.score);

		// Aktuelle Punktzahl auch in den Stats anzeigen
		statsCurrentScoreElement.textContent = formatNumber(gameState.score);

		// Highscore sofort aktualisieren wenn n√∂tig
		if (gameState.score > gameState.stats.highscore) {
			gameState.stats.highscore = gameState.score;
			statsHighscoreElement.textContent = formatNumber(gameState.stats.highscore);
		}

		// Coins f√ºr Upgrades sammeln (2% der erzielten Punkte)
		gameState.stats.coins += Math.floor(points * 0.02);
		coinsElement.textContent = formatNumber(gameState.stats.coins);
		statsCoinsElement.textContent = formatNumber(gameState.stats.coins);

		// Levelberechnung mit logarithmischer Progression
		const newLevel = Math.floor(Math.log2(gameState.score + 1) / 2) + 1;
		if (newLevel > gameState.level) {
			gameState.level = newLevel;
			levelElement.textContent = translate({de: `Level ${gameState.level}`});
		}

		// Achievement-Fortschritt f√ºr Punkte aktualisieren
		updateAchievementProgress('score', gameState.score);

		// Pr√ºfe Challenge-Fortschritt f√ºr Punkte nur, wenn nicht skipChallengeCheck
		if (!skipChallengeCheck) {
			checkChallengeProgress('score', gameState.score);
		}

		// Speichere Statistiken h√§ufiger
		if (gameState.score % 1000 === 0) {
			saveStatsToStorage();
		}
	}

	function createScorePopup(text, x, y, isBonus = false) {
		const popup = document.createElement('div');
		popup.className = isBonus ? 'score-popup chain-bonus' : 'score-popup';
		popup.textContent = text;
		popup.style.left = `${x}px`;
		popup.style.top = `${y}px`;

		gameContainer.appendChild(popup);

		// Entferne nach Animation
		setTimeout(() => popup.remove(), isBonus ? 1500 : 1200);
	}

	function checkForPossibleMoves() {
		let hasMoves = false;

		// Sicherheits√ºberpr√ºfung f√ºr das Grid
		if (!gameState.grid || !Array.isArray(gameState.grid) || gameState.grid.length === 0) {
			console.error("Grid-Fehler bei der Zugpr√ºfung");
			return true; // Nehme an, dass Z√ºge m√∂glich sind, um Game Over zu vermeiden
		}

		// Setze ein Minimum an leeren Feldern, um Game Over zu verhindern
		let emptyCount = 0;

		// Rest der Funktion bleibt gleich, aber z√§hle leere Felder...
		for (let row = 0; row < gameState.gridSize; row++) {
			for (let col = 0; col < gameState.gridSize; col++) {
				if (!gameState.grid[row][col]) {
					emptyCount++;
					hasMoves = true;
				}
			}
		}

		// Verhindere Game Over, wenn mehr als 1/3 der Felder leer sind
		if (emptyCount > (gameState.gridSize * gameState.gridSize / 3)) {
			return true;
		}

		// Pr√ºfe auf m√∂gliche Verschmelzungen
		if (!hasMoves) {
			for (let row = 0; row < gameState.gridSize; row++) {
				for (let col = 0; col < gameState.gridSize; col++) {
					const level = gameState.grid[row][col];

					// Nachbarn pr√ºfen
					const neighbors = [
						{row: row - 1, col: col},  // oben
						{row: row + 1, col: col},  // unten
						{row: row, col: col - 1},  // links
						{row: row, col: col + 1}   // rechts
					];

					for (const n of neighbors) {
						if (n.row >= 0 && n.row < gameState.gridSize &&
							n.col >= 0 && n.col < gameState.gridSize &&
							gameState.grid[n.row][n.col] === level) {
							hasMoves = true;
							break;
						}
					}

					if (hasMoves) break;
				}
				if (hasMoves) break;
			}
		}

		if (!hasMoves) {
			gameOver();
		}

		return hasMoves;
	}

	function showAchievementNotification(category, level) {
		// Finde die Achievement-Kategorie
		const achievement = ACHIEVEMENT_CATEGORIES.find(a => a.id === category);
		if (!achievement) return;

		// Erstelle eine Benachrichtigung
		const notification = document.createElement('div');
		notification.className = 'achievement-notification';
		notification.innerHTML = `
        <div class="achievement-notification-icon">${achievement.icon}</div>
        <div class="achievement-notification-content">
            <div class="achievement-notification-title">${achievement.name} Level ${level}</div>
            <div class="achievement-notification-desc">Neuer Erfolg freigeschaltet!</div>
        </div>
    `;

		// Stil der Benachrichtigung
		notification.style.position = 'fixed';
		notification.style.bottom = '20px';
		notification.style.left = '50%';
		notification.style.transform = 'translateX(-50%)';
		notification.style.backgroundColor = 'var(--accent-color)';
		notification.style.color = 'white';
		notification.style.padding = '10px 20px';
		notification.style.borderRadius = '10px';
		notification.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
		notification.style.display = 'flex';
		notification.style.alignItems = 'center';
		notification.style.zIndex = '2000';
		notification.style.opacity = '0';
		notification.style.transition = 'opacity 0.3s, transform 0.3s';
		notification.style.transform = 'translateX(-50%) translateY(20px)';

		// Icon-Stil
		const iconDiv = notification.querySelector('.achievement-notification-icon');
		iconDiv.style.marginRight = '10px';
		iconDiv.style.fontSize = '24px';
		iconDiv.style.width = '40px';
		iconDiv.style.height = '40px';
		iconDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
		iconDiv.style.borderRadius = '50%';
		iconDiv.style.display = 'flex';
		iconDiv.style.alignItems = 'center';
		iconDiv.style.justifyContent = 'center';

		// Titel-Stil
		const titleDiv = notification.querySelector('.achievement-notification-title');
		titleDiv.style.fontWeight = 'bold';
		titleDiv.style.marginBottom = '2px';

		// Zum DOM hinzuf√ºgen
		document.body.appendChild(notification);

		// Animation starten
		setTimeout(() => {
			notification.style.opacity = '1';
			notification.style.transform = 'translateX(-50%) translateY(0)';
		}, 100);

		// Nach einiger Zeit ausblenden
		setTimeout(() => {
			notification.style.opacity = '0';
			notification.style.transform = 'translateX(-50%) translateY(20px)';

			// Und entfernen
			setTimeout(() => {
				if (notification.parentNode) {
					notification.parentNode.removeChild(notification);
				}
			}, 300);
		}, 4000);
	}

	function gameOver() {
		if (gameState.gameOver) return;

		gameState.gameOver = true;

		// Spielzeit berechnen
		if (gameState.startTime) {
			const endTime = new Date();
			gameState.playTime = Math.floor((endTime - gameState.startTime) / 1000);
		}

		// Statistik-Updates
		updateStats();

		// UI aktualisieren
		finalScoreElement.textContent = formatNumber(gameState.score);
		highestBubbleElement.textContent = gameState.maxLevel;
		highestValueElement.textContent = formatNumber(gameState.maxValue);
		longestChainElement.textContent = gameState.longestChain;
		playedTimeElement.textContent = formatTime(gameState.playTime);
		totalMovesElement.textContent = gameState.moves;
		document.getElementById('stats-coins').textContent = formatNumber(gameState.stats.coins);

		setTimeout(() => {
			gameOverModal.classList.add('active');
		}, 500);
	}

	function updateStats() {
		// Highscore
		if (gameState.score > gameState.stats.highscore) {
			gameState.stats.highscore = gameState.score;
		}

		// H√∂chste Blase
		if (gameState.maxLevel > gameState.stats.highestLevel) {
			gameState.stats.highestLevel = gameState.maxLevel;
			gameState.stats.highestValue = gameState.maxValue;
		}

		// L√§ngste Kette - wurde bereits in updateChainCounter aktualisiert
		// aber sicherstellen, dass sie korrekt ist
		if (gameState.longestChain > gameState.stats.longestChain) {
			gameState.stats.longestChain = gameState.longestChain;
		}

		// Spiele gez√§hlt - unbedingt um 1 erh√∂hen
		gameState.stats.gamesPlayed++;
		console.log("Spiel beendet, gespielte Spiele erh√∂ht auf:", gameState.stats.gamesPlayed);

		// Achievement-Fortschritt f√ºr Spielezahl aktualisieren
		updateAchievementProgress('games', gameState.stats.gamesPlayed);

		// UI-Werte aktualisieren
		statsHighscoreElement.textContent = formatNumber(gameState.stats.highscore);
		statsHighestBubbleElement.textContent = `${gameState.stats.highestLevel} (${formatNumber(gameState.stats.highestValue)})`;
		statsLongestChainElement.textContent = gameState.stats.longestChain;
		statsGamesPlayedElement.textContent = gameState.stats.gamesPlayed;

		// In LocalStorage speichern
		saveStatsToStorage();
	}

	function createGridOverlay() {
		gridOverlay.innerHTML = '';
		gridOverlay.style.gridTemplateColumns = `repeat(${gameState.gridSize}, 1fr)`;
		gridOverlay.style.gridTemplateRows = `repeat(${gameState.gridSize}, 1fr)`;

		for (let i = 0; i < gameState.gridSize * gameState.gridSize; i++) {
			const cell = document.createElement('div');
			cell.className = 'grid-cell';
			gridOverlay.appendChild(cell);
		}
	}

	function initNewGame(forceNew = false) {
		// Immer ein neues Spiel erzwingen, wenn es Probleme gibt
		forceNew = forceNew || gameState.gameOver;

		// √úberpr√ºfe, ob ein gespeichertes Spiel vorhanden ist
		const restoreSavedGame = !forceNew && gameState.hasSavedGame;

		if (!restoreSavedGame) {
			// Normales neues Spiel starten
			gameState.score = 0;
			gameState.level = 1;
			gameState.maxLevel = 1;
			gameState.maxValue = 2;
			gameState.currentGoal = 8; // Start mit 8 (2^3)
			gameState.goalProgress = 0;
			gameState.longestChain = 0;
			gameState.moves = 0;
		}

		// Aktuelle Spielfeldgr√∂√üe verwenden
		gameState.gridSize = gameState.stats.gridSize;

		// Wenn kein gespeichertes Spiel oder erzwungenes Neuspiel, neues Grid erstellen
		if (!restoreSavedGame) {
			gameState.grid = [];
			for (let i = 0; i < gameState.gridSize; i++) {
				gameState.grid[i] = new Array(gameState.gridSize).fill(null);
			}
		}

		gameState.bubbles = [];
		gameState.draggedBubble = null;
		gameState.gameOver = false;
		gameState.moveMade = restoreSavedGame; // Bei gespeichertem Spiel bereits als "gestartet" markieren
		gameState.startTime = new Date();
		gameState.playTime = 0;
		gameState.processingChain = false;
		gameState.mergeQueue = [];

		// UI zur√ºcksetzen
		gameContainer.innerHTML = '<div class="grid-overlay" id="grid-overlay"></div><div class="chain-counter" id="chain-counter">x1</div>';

		// Spezial-Modus-Indikator hinzuf√ºgen, wenn aktiviert
		if (gameState.specialMode !== 'normal') {
			const indicator = document.createElement('div');
			indicator.id = 'special-mode-indicator';
			indicator.className = 'special-mode-indicator';

			if (gameState.specialMode === 'gravity') {
				indicator.innerHTML = 'üîÑ Schwerkraft';
			}

			gameContainer.appendChild(indicator);
			specialModeIndicator = document.getElementById('special-mode-indicator');
		}

		gridOverlay = document.getElementById('grid-overlay');
		chainCounter = document.getElementById('chain-counter');
		createGridOverlay();

		scoreElement.textContent = formatNumber(gameState.score);
		coinsElement.textContent = formatNumber(gameState.stats.coins);
		levelElement.textContent = translate({de: `Level ${gameState.level}`});

		// Score auch in den Stats anzeigen
		statsCurrentScoreElement.textContent = formatNumber(gameState.score);

		// N√§chste Blase und Ziel vorbereiten
		if (restoreSavedGame && gameState.nextBubble) {
			nextBubbleContainer.innerHTML = '';
			const bubble = createBubbleElement(gameState.nextBubble, 0, 0, true);
			nextBubbleContainer.appendChild(bubble);
		} else {
			prepareNextBubble();
		}

		updateGoalDisplay();

		// Aktualisiere die Modi-Buttons basierend auf freigeschalteten Modi
		updateModeButtons();

		if (restoreSavedGame) {
			// Gespeicherte Blasen wiederherstellen
			restoreBubblesFromSave();
		} else {
			// Neue Anfangsblasen erzeugen
			const initialBubbles = Math.floor(gameState.gridSize * gameState.gridSize * 0.25);
			for (let i = 0; i < initialBubbles; i++) {
				addNewBubble();
			}
		}

		// Erster Spielstart
		if (!gameState.newGameStarted) {
			gameState.newGameStarted = true;
			loadStatsFromStorage();
			setCurrentChallenge();
			setTimeout(() => showTutorial(1), 500);
		}

		// Aktualisiere Spezialmodus-UI
		updateSpecialModeUI();

		// Stelle sicher, dass die Seite nach oben gescrollt ist, besonders wichtig f√ºr mobile Ger√§te
		window.scrollTo(0, 0);
	}

	function restoreBubblesFromSave() {
		try {
			const savedGame = localStorage.getItem('bubbleMergeSavedGame');
			if (savedGame) {
				const parsedGame = JSON.parse(savedGame);

				// Leere das Spielfeld von allen vorhandenen Blasen
				gameState.bubbles.forEach(bubble => {
					if (bubble.parentNode) {
						bubble.parentNode.removeChild(bubble);
					}
				});
				gameState.bubbles = [];

				// WICHTIG: Wir verwenden das Grid, das bereits in loadStatsFromStorage geladen wurde
				// und setzen es NICHT zur√ºck, um die Konsistenz zu wahren!

				if (parsedGame.bubbles && Array.isArray(parsedGame.bubbles)) {
					console.log(`Versuche ${parsedGame.bubbles.length} Blasen wiederherzustellen`);

					// Erzeuge jede gespeicherte Blase und platziere sie
					parsedGame.bubbles.forEach(bubbleData => {
						const {level, row, col} = bubbleData;

						// Debug-Log
						console.log(`Wiederherstellung: Blase Level ${level} an Position [${row}, ${col}]`);

						// Sicherheitscheck f√ºr g√ºltige Positionen im aktuellen Spielfeld
						if (row >= 0 && row < gameState.gridSize && col >= 0 && col < gameState.gridSize) {
							// Erstelle die Blasenelemente
							const bubble = createBubbleElement(level, row, col);
							gameContainer.appendChild(bubble);
							gameState.bubbles.push(bubble);

							// Aktualisiere das Grid an dieser Stelle
							if (!gameState.grid[row]) {
								gameState.grid[row] = new Array(gameState.gridSize).fill(null);
							}
							gameState.grid[row][col] = level;
						} else {
							console.log(`Position [${row}, ${col}] au√üerhalb des g√ºltigen Bereichs`);
						}
					});

					// Verifiziere Grid-Konsistenz
					verifyGridConsistency();

					// √úberpr√ºfung nach Wiederherstellung
					console.log(`Wiederhergestellte Blasen: ${gameState.bubbles.length}`);

					// Wenn keine Blasen wiederhergestellt wurden, erstelle neue
					if (gameState.bubbles.length === 0) {
						console.log("Keine Blasen wiederhergestellt, erstelle neue Blasen");
						const initialBubbles = Math.floor(gameState.gridSize * gameState.gridSize * 0.25);
						for (let i = 0; i < initialBubbles; i++) {
							addNewBubble();
						}
					}

					return;
				}
			}

			// Fallback: F√ºge neue Blasen hinzu, wenn keine Speicherdaten gefunden wurden
			console.log("Keine Speicherdaten gefunden, erstelle neue Blasen");
			const initialBubbles = Math.floor(gameState.gridSize * gameState.gridSize * 0.25);
			for (let i = 0; i < initialBubbles; i++) {
				addNewBubble();
			}
		} catch (e) {
			console.error('Fehler bei der Wiederherstellung der Blasen:', e);

			// Fallback: F√ºge neue Blasen hinzu, wenn Wiederherstellung fehlgeschlagen ist
			const initialBubbles = Math.floor(gameState.gridSize * gameState.gridSize * 0.25);
			for (let i = 0; i < initialBubbles; i++) {
				addNewBubble();
			}
		}
	}

	function verifyGridConsistency() {
		console.log("Starte Grid-Konsistenzpr√ºfung...");

		// Stelle sicher, dass die Grid-Struktur existiert und die korrekten Dimensionen hat
		if (!gameState.grid || !Array.isArray(gameState.grid)) {
			console.log("Grid fehlt komplett, erstelle neu");
			gameState.grid = [];
		}

		// Stelle sicher, dass das Grid die richtige Anzahl an Zeilen hat
		while (gameState.grid.length < gameState.gridSize) {
			gameState.grid.push(new Array(gameState.gridSize).fill(null));
		}

		// Falls zu viele Zeilen, schneide sie ab
		if (gameState.grid.length > gameState.gridSize) {
			gameState.grid = gameState.grid.slice(0, gameState.gridSize);
		}

		// Stelle sicher, dass jede Zeile die richtige Anzahl an Spalten hat
		for (let i = 0; i < gameState.gridSize; i++) {
			if (!gameState.grid[i] || !Array.isArray(gameState.grid[i])) {
				gameState.grid[i] = new Array(gameState.gridSize).fill(null);
			} else {
				// Falls zu viele Spalten, schneide sie ab
				if (gameState.grid[i].length > gameState.gridSize) {
					gameState.grid[i] = gameState.grid[i].slice(0, gameState.gridSize);
				}
				// Falls zu wenige Spalten, f√ºge weitere hinzu
				while (gameState.grid[i].length < gameState.gridSize) {
					gameState.grid[i].push(null);
				}
			}
		}

		// Erstelle eine Liste aller Zellen, die laut Grid besetzt sind
		const occupiedCells = [];
		for (let row = 0; row < gameState.gridSize; row++) {
			for (let col = 0; col < gameState.gridSize; col++) {
				if (gameState.grid[row][col] !== null) {
					occupiedCells.push(`${row},${col}`);
				}
			}
		}

		// Erstelle eine Map aller Zellen, die eine sichtbare Blase haben
		const visualBubbles = {};
		gameState.bubbles.forEach(bubble => {
			const row = parseInt(bubble.dataset.row);
			const col = parseInt(bubble.dataset.col);
			const key = `${row},${col}`;
			visualBubbles[key] = bubble;
		});

		console.log(`Belegte Zellen im Grid: ${occupiedCells.length}, Sichtbare Blasen: ${Object.keys(visualBubbles).length}`);

		// Pr√ºfe auf Inkonsistenzen: Zellen mit Wert aber ohne Blase
		occupiedCells.forEach(cell => {
			if (!visualBubbles[cell]) {
				console.warn(`Inkonsistenz: Zelle ${cell} hat einen Wert im Grid, aber keine sichtbare Blase`);
				const [row, col] = cell.split(',').map(Number);

				// Erstelle eine Blase f√ºr diese Zelle
				const level = gameState.grid[row][col];
				const bubble = createBubbleElement(level, row, col);
				gameContainer.appendChild(bubble);
				gameState.bubbles.push(bubble);
				console.log(`Blase f√ºr Zelle ${cell} mit Level ${level} erstellt`);
			}
		});

		// Pr√ºfe auf Inkonsistenzen: Blasen ohne Grid-Wert
		Object.keys(visualBubbles).forEach(cell => {
			if (!occupiedCells.includes(cell)) {
				console.warn(`Inkonsistenz: Blase auf Zelle ${cell}, aber kein Wert im Grid`);
				const [row, col] = cell.split(',').map(Number);
				const bubble = visualBubbles[cell];

				// Aktualisiere das Grid mit dem Wert der Blase
				if (row >= 0 && row < gameState.gridSize && col >= 0 && col < gameState.gridSize) {
					gameState.grid[row][col] = parseInt(bubble.dataset.level);
					console.log(`Grid f√ºr Zelle ${cell} mit Level ${bubble.dataset.level} aktualisiert`);
				} else {
					// Die Blase ist au√üerhalb des g√ºltigen Grids, entferne sie
					console.warn(`Blase auf ung√ºltiger Position ${cell}, wird entfernt`);
					if (bubble.parentNode) {
						bubble.parentNode.removeChild(bubble);
					}
					gameState.bubbles = gameState.bubbles.filter(b => b !== bubble);
				}
			}
		});

		// Pr√ºfe auf ung√ºltige oder null-Eintr√§ge im bubbles-Array
		gameState.bubbles = gameState.bubbles.filter(bubble => {
			const isValid = bubble && bubble.parentNode &&
				!isNaN(parseInt(bubble.dataset.row)) &&
				!isNaN(parseInt(bubble.dataset.col)) &&
				!isNaN(parseInt(bubble.dataset.level));

			if (!isValid && bubble && bubble.parentNode) {
				bubble.parentNode.removeChild(bubble);
			}

			return isValid;
		});

		console.log("Grid-Konsistenzpr√ºfung abgeschlossen");
	}

	function showTutorial(step) {
		// Tutorials nur beim ersten Spielstart anzeigen
		if (gameState.tutorialStep > step) return;

		gameState.tutorialStep = step;
		tutorialsContainer.innerHTML = '';

		let tutorial;

		// Optimierte Positionierung f√ºr mobile Ger√§te
		const isMobile = window.innerWidth <= 600;

		switch (step) {
			case 1:
				// Erste Anleitung: Bewegen
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial bottom';
				tutorial.style.bottom = isMobile ? '60%' : '70%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '80%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Ziehe eine Blase, um sie zu bewegen.<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();
				});
				break;

			case 2:
				// Zweite Anleitung: Verschmelzen
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial top';
				tutorial.style.top = isMobile ? '60%' : '70%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '80%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Ziehe eine Blase direkt auf eine gleiche Blase, um sie zu verschmelzen!<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();
				});
				break;

			case 3:
				// Dritte Anleitung: Ketten
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial bottom';
				tutorial.style.top = isMobile ? '15%' : '20%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '85%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Super! Versuche Kettenreaktionen zu erzeugen f√ºr extra Bonuspunkte.<br>Jede Verschmelzung in einer Kette gibt mehr Punkte!<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();
				});
				break;
		}
	}

	function updateModeButtons() {
		modeButtons.forEach(button => {
			const mode = button.dataset.mode;

			// Normal- und Schwerkraft-Modus immer verf√ºgbar
			if (mode === 'normal' || mode === 'gravity') {
				button.disabled = false;
			}
			// Zeit-Modus
			else if (mode === 'timeAttack') {
				button.disabled = !gameState.stats.upgrades.includes('mode_timeAttack');

				if (!button.disabled) {
					// "Bald!" entfernen, wenn freigeschaltet
					button.innerHTML = `
                    <span class="mode-icon">‚è±Ô∏è</span>
                    Zeit-Modus
                `;
				}
			}
			// Farbmuster-Modus
			else if (mode === 'colorBlind') {
				button.disabled = !gameState.stats.upgrades.includes('mode_colorBlind');

				if (!button.disabled) {
					// "Bald!" entfernen, wenn freigeschaltet
					button.innerHTML = `
                    <span class="mode-icon">üé®</span>
                    Farbmuster
                `;
				}
			}

			// Button-Klasse basierend auf Status aktualisieren
			if (button.disabled) {
				button.classList.add('disabled');
			} else {
				button.classList.remove('disabled');

				// Auch Event-Listener hinzuf√ºgen, falls noch nicht vorhanden
				if (!button.hasClickListener) {
					button.addEventListener('click', () => {
						setGameMode(button.dataset.mode);
					});
					button.hasClickListener = true;
				}
			}
		});
	}

	function setupTimeAttackMode() {
		if (gameState.specialMode !== 'timeAttack') return;

		// Startzeit f√ºr Zeit-Modus (30 Sekunden)
		gameState.timeAttackTime = 30;

		// Timer-Element erstellen/aktualisieren
		let timerElement = document.getElementById('time-attack-timer');
		if (!timerElement) {
			timerElement = document.createElement('div');
			timerElement.id = 'time-attack-timer';
			timerElement.className = 'special-mode-indicator';
			timerElement.style.left = '10px';
			timerElement.style.right = 'auto';
			timerElement.style.fontSize = '22px';
			timerElement.style.fontWeight = 'bold';
			gameContainer.appendChild(timerElement);
		}

		// Timer aktualisieren
		updateTimeAttackTimer();

		// Timer starten
		gameState.timeAttackInterval = setInterval(updateTimeAttackTimer, 1000);
	}

	function updateTimeAttackTimer() {
		if (gameState.specialMode !== 'timeAttack') {
			if (gameState.timeAttackInterval) {
				clearInterval(gameState.timeAttackInterval);
			}
			return;
		}

		gameState.timeAttackTime--;

		// Timer-Anzeige aktualisieren
		const timerElement = document.getElementById('time-attack-timer');
		if (timerElement) {
			timerElement.textContent = `‚è±Ô∏è ${gameState.timeAttackTime}s`;

			// Rot blinken wenn wenig Zeit
			if (gameState.timeAttackTime <= 10) {
				timerElement.style.color = gameState.timeAttackTime % 2 === 0 ? '#ff4d4d' : 'white';
			} else {
				timerElement.style.color = 'white';
			}
		}

		// Game Over, wenn Zeit abgelaufen
		if (gameState.timeAttackTime <= 0) {
			if (gameState.timeAttackInterval) {
				clearInterval(gameState.timeAttackInterval);
			}
			gameOver();
		}
	}

	// Zeit-Bonus f√ºr erfolgreiche Verschmelzungen im Zeit-Modus
	function addTimeAttackBonus(level) {
		if (gameState.specialMode !== 'timeAttack') return;

		// Je h√∂her der Level, desto mehr Sekunden
		const seconds = Math.min(10, Math.floor(level * 1.5));
		gameState.timeAttackTime += seconds;

		// Bonus-Popup
		createScorePopup(`+${seconds}s`,
			gameContainer.offsetWidth / 2,
			gameContainer.offsetHeight / 2 - 40,
			true);
	}

	function updateAchievementProgress(categoryId, value, skipSave = false) {
		// Finde die Kategorie
		const category = ACHIEVEMENT_CATEGORIES.find(cat => cat.id === categoryId);
		if (!category) return;

		// Initialisiere das Kategorie-Objekt, falls es noch nicht existiert
		if (!gameState.stats.achievements[categoryId]) {
			gameState.stats.achievements[categoryId] = {
				value: 0,
				level: 0
			};
		}

		// Aktualisiere den H√∂chstwert in dieser Kategorie
		if (value > gameState.stats.achievements[categoryId].value) {
			gameState.stats.achievements[categoryId].value = value;

			// Berechne neues Level
			const newLevel = category.getLevel(value);
			const oldLevel = gameState.stats.achievements[categoryId].level || 0;

			// Debug-Info
			console.log(`Achievement ${categoryId}: Value=${value}, oldLevel=${oldLevel}, newLevel=${newLevel}`);

			// Wenn Level gestiegen ist, zeige Benachrichtigung
			if (newLevel > oldLevel) {
				// Belohnung f√ºr neues Achievement-Level
				const bonus = Math.pow(10, newLevel) * 5;

				// Punkte und Popup
				createScorePopup(`${category.name} Lvl ${newLevel}! +${formatNumber(bonus)}`,
					gameContainer.offsetWidth / 2,
					gameContainer.offsetHeight / 2 - 30,
					true);

				// Zeige Achievement-Benachrichtigung
				showAchievementNotification(categoryId, newLevel);

				// M√ºnzen als Belohnung
				gameState.stats.coins += bonus;
				coinsElement.textContent = formatNumber(gameState.stats.coins);
				statsCoinsElement.textContent = formatNumber(gameState.stats.coins);

				// Badge-Notification aktivieren
				statsButton.classList.add('active');

				// Achievement-Sound abspielen (falls vorhanden)
				playAchievementSound();
			}

			// Neues Level speichern
			gameState.stats.achievements[categoryId].level = newLevel;
		}

		// Speichere √Ñnderungen nur wenn nicht skipSave
		if (!skipSave) {
			saveStatsToStorage();
		}
	}

	function playAchievementSound() {
		// Diese Funktion k√∂nnte sp√§ter um einen tats√§chlichen Sound erweitert werden
		// Momentan ist es nur ein Platzhalter :-)
		console.log("Achievement-Sound w√ºrde jetzt abgespielt werden");
	}

	function updateAchievementProgress(categoryId, value, skipSave = false) {
		// Finde die Kategorie
		const category = ACHIEVEMENT_CATEGORIES.find(cat => cat.id === categoryId);
		if (!category) return;

		// Initialisiere das Kategorie-Objekt, falls es noch nicht existiert
		if (!gameState.stats.achievements[categoryId]) {
			gameState.stats.achievements[categoryId] = {
				value: 0,
				level: 0
			};
		}

		// Aktualisiere den H√∂chstwert in dieser Kategorie
		if (value > gameState.stats.achievements[categoryId].value) {
			gameState.stats.achievements[categoryId].value = value;

			// Berechne neues Level
			const newLevel = category.getLevel(value);
			const oldLevel = gameState.stats.achievements[categoryId].level || 0;

			// Debug-Info
			console.log(`Achievement ${categoryId}: Value=${value}, oldLevel=${oldLevel}, newLevel=${newLevel}`);

			// Wenn Level gestiegen ist, zeige Benachrichtigung
			if (newLevel > oldLevel) {
				// Belohnung f√ºr neues Achievement-Level
				const bonus = Math.pow(10, newLevel) * 5;

				// Punkte und Popup
				createScorePopup(`${category.name} Lvl ${newLevel}! +${formatNumber(bonus)}`,
					gameContainer.offsetWidth / 2,
					gameContainer.offsetHeight / 2 - 30,
					true);

				// Zeige Achievement-Benachrichtigung
				showAchievementNotification(categoryId, newLevel);

				// M√ºnzen als Belohnung
				gameState.stats.coins += bonus;
				coinsElement.textContent = formatNumber(gameState.stats.coins);
				statsCoinsElement.textContent = formatNumber(gameState.stats.coins);

				// Badge-Notification aktivieren
				statsButton.classList.add('active');

				// Achievement-Sound abspielen (falls vorhanden)
				playAchievementSound();
			}

			// Neues Level speichern
			gameState.stats.achievements[categoryId].level = newLevel;
		}

		// Speichere √Ñnderungen nur wenn nicht skipSave
		if (!skipSave) {
			saveStatsToStorage();
		}
	}

	function showChallengeProgressNotification(challenge, progress) {
		// Wenn der Fortschritt unter 25% ist, keine Benachrichtigung
		if (progress < 25) return;

		// Bestimme die Meldung basierend auf dem Fortschritt
		let message;
		if (progress >= 90) {
			message = "Fast geschafft!";
		} else if (progress >= 75) {
			message = "Nur noch ein wenig!";
		} else if (progress >= 50) {
			message = "Schon halb fertig!";
		} else {
			message = "Du machst Fortschritte!";
		}

		// Erstelle die Benachrichtigung
		const notification = document.createElement('div');
		notification.className = 'challenge-progress-notification';
		notification.innerHTML = `
        <div class="notification-content">
            <div class="notification-title">Herausforderung: ${progress}%</div>
            <div class="notification-desc">${message} ${challenge.description}</div>
        </div>
        <div class="notification-progress">
            <div class="notification-progress-bar" style="width: ${progress}%"></div>
        </div>
    `;

		// Stil der Benachrichtigung
		notification.style.position = 'fixed';
		notification.style.top = '60px';
		notification.style.right = '20px';
		notification.style.backgroundColor = 'var(--accent-color)';
		notification.style.color = 'white';
		notification.style.padding = '10px 15px';
		notification.style.borderRadius = '8px';
		notification.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.2)';
		notification.style.zIndex = '2000';
		notification.style.opacity = '0';
		notification.style.transition = 'opacity 0.3s, transform 0.3s';
		notification.style.transform = 'translateX(20px)';
		notification.style.maxWidth = '300px';

		// Fortschrittsbalken-Stil
		const progressBar = notification.querySelector('.notification-progress');
		progressBar.style.height = '5px';
		progressBar.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
		progressBar.style.borderRadius = '2px';
		progressBar.style.marginTop = '8px';
		progressBar.style.overflow = 'hidden';

		const progressBarInner = notification.querySelector('.notification-progress-bar');
		progressBarInner.style.height = '100%';
		progressBarInner.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
		progressBarInner.style.transition = 'width 0.5s';

		// Zum DOM hinzuf√ºgen
		document.body.appendChild(notification);

		// Animation starten
		setTimeout(() => {
			notification.style.opacity = '1';
			notification.style.transform = 'translateX(0)';
		}, 100);

		// Nach einiger Zeit ausblenden
		setTimeout(() => {
			notification.style.opacity = '0';
			notification.style.transform = 'translateX(20px)';

			// Und entfernen
			setTimeout(() => {
				if (notification.parentNode) {
					notification.parentNode.removeChild(notification);
				}
			}, 300);
		}, 3500);
	}

	function updateAchievementsUI() {
		achievementsContainer.innerHTML = '';

		// Erstelle f√ºr jede Kategorie einen Container mit Fortschrittsanzeige
		ACHIEVEMENT_CATEGORIES.forEach(category => {
			const categoryData = gameState.stats.achievements[category.id] || {value: 0, level: 0};
			const currentValue = categoryData.value || 0;
			const currentLevel = categoryData.level || 0;

			// Berechne n√§chstes Ziel
			const nextTarget = category.getNextTarget(currentLevel);

			// Berechne Fortschritt zum n√§chsten Ziel
			const progress = category.getProgress(currentValue, nextTarget);

			// Erstelle Kategorie-Container
			const categoryContainer = document.createElement('div');
			categoryContainer.className = 'achievement-category';

			// Debug-Info
			console.log(`Achievement ${category.id}: Wert=${currentValue}, Level=${currentLevel}, Ziel=${nextTarget}, Fortschritt=${progress.toFixed(1)}%`);

			// Kategorie-Titel mit Level
			categoryContainer.innerHTML = `
            <div class="achievement-category-title">
                ${category.icon} ${category.name}
                <span class="achievement-level">Level ${currentLevel}</span>
            </div>
            <div class="achievement-badge">
                <div class="achievement-icon">${category.icon}</div>
                <div class="achievement-info">
                    <div class="achievement-title">Aktueller Wert: ${formatNumber(currentValue)}</div>
                    <div class="achievement-desc">N√§chstes Ziel: ${formatNumber(nextTarget)}</div>
                    <div class="achievement-progress">
                        <div class="achievement-progress-bar" style="width: ${progress}%"></div>
                    </div>
                </div>
            </div>
        `;

			achievementsContainer.appendChild(categoryContainer);
		});
	}

	// VER√ÑNDERT: Verbesserte Version von checkChallengeProgress f√ºr erreichbarere Ziele
	function checkChallengeProgress(type, value) {
		if (!gameState.challenge || gameState.challenge.type !== type) return;

		// Debug-Info
		console.log(`Challenge-Check: Typ=${type}, Wert=${value}, Ziel=${gameState.challenge.target}`);

		// Spezialfall f√ºr Wert-Challenges (Blasen-Level): Werte umrechnen
		if (type === 'value') {
			// Der aktuelle Wert muss das tats√§chliche Blasen-Wert sein (2^level)
			// Wenn wir bereits das Ziel erreicht haben, nichts tun
			if (gameState.stats.challengeProgress >= gameState.challenge.target) return;

			// Update Fortschritt f√ºr Wert-Challenges
			gameState.stats.challengeProgress = Math.max(value, gameState.stats.challengeProgress);
		}
		// Spezialfall f√ºr Kettenreaktionen: auch kleinere Werte akzeptieren f√ºr Fortschritt
		else if (type === 'chain' && CHALLENGES[gameState.stats.currentChallenge % CHALLENGES.length].target > 3) {
			// F√ºr 4er und 5er Ketten: jede 3er Kette gibt auch Fortschritt (langsamer)
			if (value >= 3 && value < CHALLENGES[gameState.stats.currentChallenge % CHALLENGES.length].target) {
				const oldProgress = gameState.stats.challengeProgress;
				// Fortschritt um 1 erh√∂hen, aber nicht h√∂her als Ziel-1
				const effectiveValue = Math.min(oldProgress + 1, CHALLENGES[gameState.stats.currentChallenge % CHALLENGES.length].target - 1);

				// Feedback, dass die Challenge voranschreitet
				if (effectiveValue > oldProgress) {
					const progressPercent = Math.floor((effectiveValue / CHALLENGES[gameState.stats.currentChallenge % CHALLENGES.length].target) * 100);
					createScorePopup(`Challenge: ${progressPercent}%`,
						gameContainer.offsetWidth / 2,
						gameContainer.offsetHeight / 2 - 60,
						true);

					// Update Fortschritt
					gameState.stats.challengeProgress = effectiveValue;
				}

				// UI aktualisieren und speichern
				updateChallengeUI();
				saveStatsToStorage();
				return;
			}
		}

		// F√ºr Score-Challenges und direkte Kettentreffer: direkt den Wert nehmen
		if (type === 'score' || (type === 'chain' && value >= gameState.challenge.target)) {
			gameState.stats.challengeProgress = Math.max(value, gameState.stats.challengeProgress);
		}

		// Pr√ºfe auf Challenge-Abschluss
		if (gameState.stats.challengeProgress >= gameState.challenge.target) {
			// Belohnung gew√§hren
			// Verwende skipChallengeCheck=true, um die Endlosrekursion zu vermeiden
			updateScore(gameState.challenge.reward, true, true);

			createScorePopup(`Herausforderung geschafft! +${formatNumber(gameState.challenge.reward)}`,
				gameContainer.offsetWidth / 2, gameContainer.offsetHeight / 2, true);

			// Coins als zus√§tzliche Belohnung
			gameState.stats.coins += Math.floor(gameState.challenge.reward * 0.05);
			coinsElement.textContent = formatNumber(gameState.stats.coins);
			statsCoinsElement.textContent = formatNumber(gameState.stats.coins);

			// N√§chste Challenge
			gameState.stats.currentChallenge++;
			setCurrentChallenge();

			// Badge-Notification aktivieren
			statsButton.classList.add('active');

			// Zeige Challenge-Benachrichtigung
			showChallengeCompletedNotification(gameState.challenge);
		} else {
			// Fortschritt aktualisieren
			updateChallengeUI();
		}

		// Speichern
		saveStatsToStorage();
	}

	function showChallengeCompletedNotification(challenge) {
		// Erstelle eine Benachrichtigung
		const notification = document.createElement('div');
		notification.className = 'challenge-notification';
		notification.innerHTML = `
            <div class="challenge-notification-icon">üèÜ</div>
            <div class="challenge-notification-content">
                <div class="challenge-notification-title">Herausforderung abgeschlossen!</div>
                <div class="challenge-notification-desc">${challenge.description}</div>
                <div class="challenge-notification-reward">+${formatNumber(challenge.reward)} Punkte</div>
            </div>
        `;

		// Stil der Benachrichtigung
		notification.style.position = 'fixed';
		notification.style.bottom = '20px';
		notification.style.left = '50%';
		notification.style.transform = 'translateX(-50%)';
		notification.style.backgroundColor = 'var(--chain-highlight)';
		notification.style.color = 'black';
		notification.style.padding = '10px 20px';
		notification.style.borderRadius = '10px';
		notification.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
		notification.style.display = 'flex';
		notification.style.alignItems = 'center';
		notification.style.zIndex = '2000';
		notification.style.opacity = '0';
		notification.style.transition = 'opacity 0.3s, transform 0.3s';
		notification.style.transform = 'translateX(-50%) translateY(20px)';

		// Icon-Stil
		const iconDiv = notification.querySelector('.challenge-notification-icon');
		iconDiv.style.marginRight = '15px';
		iconDiv.style.fontSize = '28px';
		iconDiv.style.width = '45px';
		iconDiv.style.height = '45px';
		iconDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
		iconDiv.style.borderRadius = '50%';
		iconDiv.style.display = 'flex';
		iconDiv.style.alignItems = 'center';
		iconDiv.style.justifyContent = 'center';

		// Titel-Stil
		const titleDiv = notification.querySelector('.challenge-notification-title');
		titleDiv.style.fontWeight = 'bold';
		titleDiv.style.marginBottom = '3px';
		titleDiv.style.fontSize = '16px';

		// Belohnung-Stil
		const rewardDiv = notification.querySelector('.challenge-notification-reward');
		rewardDiv.style.marginTop = '5px';
		rewardDiv.style.fontWeight = 'bold';
		rewardDiv.style.color = '#d97706'; // Dunkleres Gold

		// Zum DOM hinzuf√ºgen
		document.body.appendChild(notification);

		// Animation starten
		setTimeout(() => {
			notification.style.opacity = '1';
			notification.style.transform = 'translateX(-50%) translateY(0)';
		}, 100);

		// Nach einiger Zeit ausblenden
		setTimeout(() => {
			notification.style.opacity = '0';
			notification.style.transform = 'translateX(-50%) translateY(20px)';

			// Und entfernen
			setTimeout(() => {
				if (notification.parentNode) {
					notification.parentNode.removeChild(notification);
				}
			}, 300);
		}, 5000);
	}

	function setCurrentChallenge() {
		// N√§chste Challenge setzen
		const challengeIndex = gameState.stats.currentChallenge % CHALLENGES.length;
		gameState.challenge = CHALLENGES[challengeIndex];
		gameState.stats.challengeProgress = 0;

		// UI aktualisieren
		updateChallengeUI();

		// Info-Button hinzuf√ºgen, um zu erkl√§ren, wie man die Challenge abschlie√üt
		const challengeContainer = document.querySelector('.challenge-container h3');
		if (challengeContainer) {
			// Entferne bestehenden Button falls vorhanden
			const existingButton = document.querySelector('.challenge-info-button');
			if (existingButton) existingButton.remove();

			// Entferne bestehenden Tooltip falls vorhanden
			const existingTooltip = document.querySelector('.challenge-tooltip');
			if (existingTooltip) existingTooltip.remove();

			// F√ºge den Info-Button hinzu
			const infoButton = document.createElement('button');
			infoButton.className = 'challenge-info-button';
			infoButton.innerHTML = '‚ìò';
			challengeContainer.appendChild(infoButton);

			// F√ºge den Tooltip hinzu
			const tooltip = document.createElement('div');
			tooltip.className = 'challenge-tooltip';

			// Unterschiedliche Tipps basierend auf dem Challenge-Typ
			if (gameState.challenge.type === 'chain') {
				tooltip.textContent = 'Verschmelze Blasen so, dass sie Kettenreaktionen ausl√∂sen. Je mehr Verschmelzungen in einer Kette, desto besser!';
			} else if (gameState.challenge.type === 'value') {
				tooltip.textContent = 'Verschmelze gleichwertige Blasen, um h√∂here Werte zu erzielen. Je mehr Verschmelzungen, desto gr√∂√üer wird die Blase!';
			} else if (gameState.challenge.type === 'score') {
				tooltip.textContent = 'Sammle Punkte durch Verschmelzungen. Kettenreaktionen geben Bonuspunkte!';
			}

			challengeContainer.appendChild(tooltip);
		}

		// Zeige eine Benachrichtigung √ºber die neue Herausforderung
		showNewChallengeNotification(gameState.challenge);
	}

	function showNewChallengeNotification(challenge) {
		// Wenn es die erste Challenge ist, keine Benachrichtigung
		if (gameState.stats.currentChallenge === 0 && gameState.stats.challengeProgress === 0) return;

		// Erstelle die Benachrichtigung
		const notification = document.createElement('div');
		notification.className = 'new-challenge-notification';
		notification.innerHTML = `
        <div class="notification-icon">üéØ</div>
        <div class="notification-content">
            <div class="notification-title">Neue Herausforderung!</div>
            <div class="notification-desc">${challenge.description}</div>
            <div class="notification-reward">Belohnung: +${formatNumber(challenge.reward)} Punkte</div>
        </div>
    `;

		// Stil der Benachrichtigung
		notification.style.position = 'fixed';
		notification.style.top = '20%';
		notification.style.left = '50%';
		notification.style.transform = 'translateX(-50%) scale(0.9)';
		notification.style.backgroundColor = 'var(--accent-color)';
		notification.style.color = 'white';
		notification.style.padding = '15px 20px';
		notification.style.borderRadius = '10px';
		notification.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.3)';
		notification.style.display = 'flex';
		notification.style.alignItems = 'center';
		notification.style.zIndex = '2000';
		notification.style.transition = 'opacity 0.4s, transform 0.4s';
		notification.style.opacity = '0';
		notification.style.maxWidth = '85%';

		// Icon-Stil
		const iconDiv = notification.querySelector('.notification-icon');
		iconDiv.style.fontSize = '30px';
		iconDiv.style.marginRight = '15px';
		iconDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
		iconDiv.style.width = '50px';
		iconDiv.style.height = '50px';
		iconDiv.style.borderRadius = '50%';
		iconDiv.style.display = 'flex';
		iconDiv.style.alignItems = 'center';
		iconDiv.style.justifyContent = 'center';

		// Titel-Stil
		const titleDiv = notification.querySelector('.notification-title');
		titleDiv.style.fontWeight = 'bold';
		titleDiv.style.fontSize = '18px';
		titleDiv.style.marginBottom = '5px';

		// Belohnung-Stil
		const rewardDiv = notification.querySelector('.notification-reward');
		rewardDiv.style.marginTop = '8px';
		rewardDiv.style.fontWeight = 'bold';
		rewardDiv.style.color = 'var(--chain-highlight)';

		// Zum DOM hinzuf√ºgen
		document.body.appendChild(notification);

		// Animation starten
		setTimeout(() => {
			notification.style.opacity = '1';
			notification.style.transform = 'translateX(-50%) scale(1)';
		}, 100);

		// Nach einiger Zeit ausblenden
		setTimeout(() => {
			notification.style.opacity = '0';
			notification.style.transform = 'translateX(-50%) scale(0.9)';

			// Und entfernen
			setTimeout(() => {
				if (notification.parentNode) {
					notification.parentNode.removeChild(notification);
				}
			}, 400);
		}, 5000);
	}

	function updateChallengeUI() {
		if (!gameState.challenge) return;

		// Beschreibung
		challengeDescription.textContent = gameState.challenge.description;

		// Fortschrittstext
		challengeProgressText.textContent = `${gameState.stats.challengeProgress}/${gameState.challenge.target}`;

		// Fortschrittsbalken
		const progress = Math.min(
			(gameState.stats.challengeProgress / gameState.challenge.target) * 100,
			100
		);

		console.log(`Challenge-UI: Fortschritt=${gameState.stats.challengeProgress}, Ziel=${gameState.challenge.target}, Prozent=${progress}%`);

		challengeProgressBar.style.width = `${progress}%`;

		// Belohnung
		challengeReward.textContent = `+${formatNumber(gameState.challenge.reward)} Punkte`;
	}

	// Upgrade-Funktionen
	function updateUpgradesUI() {
		upgradesContainer.innerHTML = '';

		console.log("Verf√ºgbare M√ºnzen:", gameState.stats.coins); // Debug-Info

		// Alle verf√ºgbaren Upgrades anzeigen
		UPGRADES.forEach(upgrade => {
			const isOwned = gameState.stats.upgrades.includes(upgrade.id);
			const canAfford = gameState.stats.coins >= upgrade.cost;

			// Pr√ºfe Abh√§ngigkeiten
			let dependenciesMet = true;
			for (const req of upgrade.requires) {
				if (!gameState.stats.upgrades.includes(req)) {
					dependenciesMet = false;
					break;
				}
			}

			const upgradeItem = document.createElement('div');
			upgradeItem.className = 'upgrade-item';

			// Das Hauptproblem ist hier die Button-Disabled-Logik
			const isDisabled = isOwned || (!canAfford || !dependenciesMet);

			upgradeItem.innerHTML = `
            <div class="upgrade-info">
                <div class="upgrade-title">${upgrade.title}</div>
                <div class="upgrade-desc">${upgrade.description}</div>
            </div>
            <button class="upgrade-button" ${isDisabled ? 'disabled' : ''} data-upgrade="${upgrade.id}">
                ${isOwned ? 'Freigeschaltet' : `Kaufen <span class="upgrade-cost">${formatNumber(upgrade.cost)} M√ºnzen</span>`}
            </button>
        `;

			upgradesContainer.appendChild(upgradeItem);

			// Debug-Info
			console.log(`Upgrade ${upgrade.id}: besessen=${isOwned}, genug M√ºnzen=${canAfford}, Voraussetzungen erf√ºllt=${dependenciesMet}, deaktiviert=${isDisabled}`);

			if (!isOwned) {
				const button = upgradeItem.querySelector('.upgrade-button');

				// Manuelles Styling und Event-Listener-Hinzuf√ºgen
				if (canAfford && dependenciesMet) {
					button.style.opacity = '1';
					button.style.cursor = 'pointer';
					button.disabled = false;

					button.addEventListener('click', () => {
						purchaseUpgrade(upgrade.id);
					});
				} else {
					button.style.opacity = '0.5';
					button.style.cursor = 'not-allowed';
					button.disabled = true;
				}
			}
		});
	}

	function purchaseUpgrade(upgradeId) {
		// Finde das Upgrade
		const upgrade = UPGRADES.find(u => u.id === upgradeId);
		if (!upgrade) return;

		// Pr√ºfe, ob wir genug M√ºnzen haben
		if (gameState.stats.coins < upgrade.cost) return;

		// Pr√ºfe, ob alle abh√§ngigen Upgrades freigeschaltet sind
		for (const req of upgrade.requires) {
			if (!gameState.stats.upgrades.includes(req)) {
				return;
			}
		}

		// Kaufen
		gameState.stats.coins -= upgrade.cost;
		gameState.stats.upgrades.push(upgradeId);

		// Aktualisiere M√ºnzen-Anzeige
		coinsElement.textContent = formatNumber(gameState.stats.coins);
		statsCoinsElement.textContent = formatNumber(gameState.stats.coins);

		// Spezielle Upgrades anwenden
		if (upgradeId.startsWith('grid_')) {
			const oldGridSize = gameState.stats.gridSize;
			const newGridSize = upgrade.gridSize;

			// Spielfeldgr√∂√üe aktualisieren
			gameState.stats.unlockedGridSize = newGridSize;
			gameState.stats.gridSize = newGridSize;
			gameState.gridSize = newGridSize;
			statsGridSizeElement.textContent = `${newGridSize}x${newGridSize}`;

			// Grid auf neue Gr√∂√üe erweitern und bestehende Werte behalten
			const oldGrid = gameState.grid;
			const newGrid = [];

			// Neues gr√∂√üeres Grid erstellen
			for (let i = 0; i < newGridSize; i++) {
				newGrid[i] = new Array(newGridSize).fill(null);

				// Bestehende Werte kopieren, wenn innerhalb der alten Grenzen
				if (i < oldGridSize) {
					for (let j = 0; j < oldGridSize; j++) {
						if (oldGrid[i] && oldGrid[i][j] !== undefined) {
							newGrid[i][j] = oldGrid[i][j];
						}
					}
				}
			}

			// Neues Grid anwenden
			gameState.grid = newGrid;

			// Grid-Overlay aktualisieren
			createGridOverlay();

			// Blasen-Positionen aktualisieren (Gr√∂√üe k√∂nnte sich ge√§ndert haben)
			gameState.bubbles.forEach(bubble => {
				const row = parseInt(bubble.dataset.row);
				const col = parseInt(bubble.dataset.col);

				// Position aktualisieren
				const pos = getBubblePosition(row, col);
				const size = calculateBubbleSize();

				bubble.style.width = `${size}px`;
				bubble.style.height = `${size}px`;
				bubble.style.left = `${pos.x}px`;
				bubble.style.top = `${pos.y}px`;
			});

			// UI aktualisieren
			statsModal.classList.remove('active');
		}

		// UI aktualisieren
		updateUpgradesUI();

		// In LocalStorage speichern
		saveStatsToStorage();
	}

	function updateStatsUI() {
		statsHighscoreElement.textContent = formatNumber(gameState.score);
		statsHighestBubbleElement.textContent = `${gameState.maxLevel} (${formatNumber(gameState.maxValue)})`;
		statsLongestChainElement.textContent = gameState.stats.longestChain;
		statsGamesPlayedElement.textContent = gameState.stats.gamesPlayed;
		statsGridSizeElement.textContent = `${gameState.stats.gridSize}x${gameState.stats.gridSize}`;
		statsCoinsElement.textContent = formatNumber(gameState.stats.coins);
		statsCurrentScoreElement.textContent = formatNumber(gameState.score);

		updateAchievementsUI();
		updateChallengeUI();
		updateUpgradesUI();
	}

	// Spielmodus-Funktionen
	function setGameMode(mode) {
		// Alten Modus speichern
		const oldMode = gameState.specialMode;

		// Aktuelles Spiel speichern, bevor Modus gewechselt wird
		if (!gameState.gameOver && gameState.moveMade) {
			saveGameToStorage();
		}

		// Modus setzen
		gameState.specialMode = mode;

		// Schwerkraft-Flag setzen
		gameState.gravityEnabled = (mode === 'gravity');

		// Spezielle Modi-Einstellungen
		if (mode === 'timeAttack') {
			setupTimeAttackMode();
		} else if (gameState.timeAttackInterval) {
			clearInterval(gameState.timeAttackInterval);
		}

		// UI-Elemente aktualisieren
		activeModeDescription.innerHTML = MODE_DESCRIPTIONS[mode];

		// Modus-Banner anzeigen/verstecken
		if (mode !== 'normal') {
			specialModeBanner.textContent = mode === 'gravity' ? 'Schwerkraft-Modus: Blasen fallen nach unten' :
				mode === 'timeAttack' ? 'Zeit-Modus: Reagiere schnell!' :
					'Farbmuster-Modus: Achte auf die Muster';
			specialModeBanner.style.display = 'block';
		} else {
			specialModeBanner.style.display = 'none';
		}

		// Modus-Buttons aktualisieren
		document.querySelectorAll('.mode-button').forEach(btn => {
			if (btn.dataset.mode === mode) {
				btn.classList.add('active');
			} else {
				btn.classList.remove('active');
			}
		});

		// Aktualisiere den gespeicherten Spielstand f√ºr den neuen Modus
		try {
			const savedGame = localStorage.getItem('bubbleMergeSavedGame');
			if (savedGame) {
				const parsedGame = JSON.parse(savedGame);
				parsedGame.specialMode = mode;
				parsedGame.gravityEnabled = (mode === 'gravity');
				localStorage.setItem('bubbleMergeSavedGame', JSON.stringify(parsedGame));
				console.log(`Spielmodus auf ${mode} aktualisiert`);
			}
		} catch (e) {
			console.error('Fehler beim Aktualisieren des Spielmodus:', e);
		}

		// Dialog schlie√üen
		statsModal.classList.remove('active');

		// Wenn der Modus ge√§ndert wurde und ein Spiel l√§uft, wende die neuen Regeln an
		if (oldMode !== mode && !gameState.gameOver && gameState.moveMade) {
			// Spezial-Mode-Indikator aktualisieren
			updateSpecialModeUI();

			// Wenn Schwerkraft aktiviert wurde, wende sie einmal an
			if (mode === 'gravity' && oldMode !== 'gravity') {
				setTimeout(() => {
					applyGravity();
				}, 500);
			}
		} else {
			// Nur wenn kein Spiel l√§uft oder der Spieler explizit neu starten m√∂chte, neues Spiel starten
			initNewGame();
		}
	}

	function updateSpecialModeUI() {
		// UI-Elemente f√ºr Spezialmodus aktualisieren
		if (gameState.specialMode !== 'normal') {
			specialModeBanner.textContent = gameState.specialMode === 'gravity' ?
				'Schwerkraft-Modus: Blasen fallen nach unten' :
				gameState.specialMode === 'timeAttack' ?
					'Zeit-Modus: Reagiere schnell!' :
					'Farbmuster-Modus: Achte auf die Muster';
			specialModeBanner.style.display = 'block';

			// Auch den Modus-Indikator im Spielfeld aktualisieren
			if (specialModeIndicator) {
				specialModeIndicator.innerHTML = gameState.specialMode === 'gravity' ?
					'üîÑ Schwerkraft' :
					gameState.specialMode === 'timeAttack' ?
						'‚è±Ô∏è Zeit' : 'üé® Muster';
				specialModeIndicator.style.display = 'block';
			}
		} else {
			specialModeBanner.style.display = 'none';
			if (specialModeIndicator) {
				specialModeIndicator.style.display = 'none';
			}
		}

		// Modus-Buttons aktualisieren
		document.querySelectorAll('.mode-button').forEach(btn => {
			if (btn.dataset.mode === gameState.specialMode) {
				btn.classList.add('active');
			} else {
				btn.classList.remove('active');
			}
		});

		// Modus-Beschreibung aktualisieren
		if (activeModeDescription) {
			activeModeDescription.innerHTML = MODE_DESCRIPTIONS[gameState.specialMode] ||
				MODE_DESCRIPTIONS['normal'];
		}
	}

	// Local Storage Funktionen
	function saveStatsToStorage() {
		try {
			// Statistiken speichern
			localStorage.setItem('bubbleMergeStats', JSON.stringify(gameState.stats));
			console.log("Statistiken gespeichert, l√§ngste Kette:", gameState.stats.longestChain, "M√ºnzen:", gameState.stats.coins);

			// Spielzustand speichern
			saveGameToStorage();
		} catch (e) {
			console.error('Fehler beim Speichern der Statistiken:', e);
		}
	}

	function saveGameToStorage() {
		try {
			if (!gameState.gameOver && gameState.moveMade) {
				// Aktuelles Spielfeld speichern
				const gameStateToSave = {
					grid: gameState.grid,
					bubbles: gameState.bubbles.map(bubble => ({
						level: parseInt(bubble.dataset.level),
						row: parseInt(bubble.dataset.row),
						col: parseInt(bubble.dataset.col),
						value: parseInt(bubble.dataset.value)
					})),
					score: gameState.score,
					level: gameState.level,
					maxLevel: gameState.maxLevel,
					maxValue: gameState.maxValue,
					currentGoal: gameState.currentGoal,
					goalProgress: gameState.goalProgress,
					specialMode: gameState.specialMode,
					gravityEnabled: gameState.gravityEnabled,
					nextBubble: gameState.nextBubble,
					chainCount: gameState.chainCount,
					longestChain: gameState.longestChain,
					moves: gameState.moves,
					gridSize: gameState.gridSize
				};

				localStorage.setItem('bubbleMergeSavedGame', JSON.stringify(gameStateToSave));
				console.log("Spielzustand gespeichert");
				return true;
			}
		} catch (e) {
			console.error('Fehler beim Speichern des Spielzustands:', e);
		}
		return false;
	}

	function loadStatsFromStorage() {
		try {
			// Zuerst die Spielstatistiken laden
			const storedStats = localStorage.getItem('bubbleMergeStats');
			if (storedStats) {
				const parsedStats = JSON.parse(storedStats);

				// Basis-Statistiken mit sicheren Standardwerten
				gameState.stats = {
					highscore: parsedStats.highscore || 0,
					highestLevel: parsedStats.highestLevel || 1,
					highestValue: parsedStats.highestValue || 2,
					longestChain: parsedStats.longestChain || 0,
					gamesPlayed: parsedStats.gamesPlayed || 0,
					achievements: parsedStats.achievements || {},
					currentChallenge: parsedStats.currentChallenge || 0,
					challengeProgress: parsedStats.challengeProgress || 0,
					gridSize: parsedStats.gridSize || 6,
					unlockedGridSize: parsedStats.unlockedGridSize || 6,
					coins: parsedStats.coins || 0,
					upgrades: parsedStats.upgrades || []
				};

				// Stellen sicher, dass die Grid-Gr√∂√üe gesetzt ist
				gameState.gridSize = gameState.stats.gridSize || 6;

				// Migrieren der alten achievements-Array-Version zur neuen objektbasierten Version
				if (Array.isArray(gameState.stats.achievements)) {
					// Migration code unchanged...
				}

				console.log("Spielstatistiken erfolgreich geladen, l√§ngste Kette:", gameState.stats.longestChain, "M√ºnzen:", gameState.stats.coins);
			} else {
				// Default stats unchanged...
			}

			// Dann den aktuellen Spielstand laden (separat)
			const savedGame = localStorage.getItem('bubbleMergeSavedGame');
			if (savedGame) {
				const parsedGame = JSON.parse(savedGame);
				console.log("Geladene Spieldaten:", parsedGame);

				// Pr√ºfen, ob ein g√ºltiger Spielstand vorliegt
				if (parsedGame.grid && parsedGame.bubbles && parsedGame.bubbles.length > 0) {
					// Setze zun√§chst die korrekte Spielfeldgr√∂√üe
					gameState.gridSize = parsedGame.gridSize || gameState.stats.gridSize;

					// Initialisiere eine korrekte Grid-Struktur
					gameState.grid = [];
					for (let i = 0; i < gameState.gridSize; i++) {
						gameState.grid[i] = new Array(gameState.gridSize).fill(null);
					}

					// Kopiere die gespeicherten Grid-Daten in unser korrekt strukturiertes Grid
					if (Array.isArray(parsedGame.grid)) {
						for (let i = 0; i < Math.min(parsedGame.grid.length, gameState.gridSize); i++) {
							if (Array.isArray(parsedGame.grid[i])) {
								for (let j = 0; j < Math.min(parsedGame.grid[i].length, gameState.gridSize); j++) {
									gameState.grid[i][j] = parsedGame.grid[i][j];
								}
							}
						}
					}

					// Andere Spielzustandswerte wiederherstellen
					gameState.score = parsedGame.score || 0;
					gameState.level = parsedGame.level || 1;
					gameState.maxLevel = parsedGame.maxLevel || 1;
					gameState.maxValue = parsedGame.maxValue || 2;
					gameState.currentGoal = parsedGame.currentGoal || 8;
					gameState.goalProgress = parsedGame.goalProgress || 0;
					gameState.hasSavedGame = true;
					gameState.specialMode = parsedGame.specialMode || 'normal';
					gameState.gravityEnabled = parsedGame.gravityEnabled || false;
					gameState.nextBubble = parsedGame.nextBubble || createRandomBubble();
					gameState.chainCount = parsedGame.chainCount || 0;
					gameState.longestChain = parsedGame.longestChain || 0;
					gameState.moves = parsedGame.moves || 0;

					console.log("Spielzustand erfolgreich geladen");
				} else {
					console.log("Ung√ºltiger gespeicherter Spielzustand");
					gameState.hasSavedGame = false;
					initializeNewGrid();
				}
			} else {
				console.log("Kein gespeicherter Spielzustand gefunden");
				gameState.hasSavedGame = false;
				initializeNewGrid();
			}
		} catch (e) {
			console.error('Fehler beim Laden der Statistiken:', e);
			// Bei Fehler: Standardwerte
			gameState.hasSavedGame = false;
			initializeNewGrid();
		}
	}

	// Hilfsfunktion zur Initialisierung eines frischen Grids
	function initializeNewGrid() {
		gameState.grid = [];
		for (let i = 0; i < gameState.gridSize; i++) {
			gameState.grid[i] = new Array(gameState.gridSize).fill(null);
		}
	}

	function resetStats() {
		if (confirm(translate({de: 'M√∂chtest du wirklich alle Statistiken zur√ºcksetzen? Dies kann nicht r√ºckg√§ngig gemacht werden.'}))) {
			// Komplett neues Stats-Objekt erstellen
			gameState.stats = {
				highscore: 0,
				highestLevel: 1,
				highestValue: 2,
				longestChain: 0,
				gamesPlayed: 0,
				achievements: {},
				currentChallenge: 0,
				challengeProgress: 0,
				gridSize: 6,
				unlockedGridSize: 6,
				coins: 0,
				upgrades: []
			};

			// Aktuelles Spiel l√∂schen (wichtig!)
			localStorage.removeItem('bubbleMergeSavedGame');

			// Stats speichern
			saveStatsToStorage();
			updateStatsUI();
			setCurrentChallenge();

			// Explizit neues Spiel erzwingen
			gameState.hasSavedGame = false;
			gameState.gridSize = 6;

			// Spiel komplett neu starten
			initNewGame(true); // Parameter true bedeutet: forciere neues Spiel
		}
	}

	// Event-Listener
	themeToggle.addEventListener('click', () => {
		const isDark = document.body.getAttribute('data-theme') === 'dark';

		if (isDark) {
			document.body.removeAttribute('data-theme');
			moonIcon.style.display = 'block';
			sunIcon.style.display = 'none';
		} else {
			document.body.setAttribute('data-theme', 'dark');
			moonIcon.style.display = 'none';
			sunIcon.style.display = 'block';
		}
	});

	restartButton.addEventListener('click', () => {
		initNewGame();
	});

	statsButton.addEventListener('click', () => {
		updateStatsUI();
		statsModal.classList.add('active');
		statsButton.classList.remove('active'); // Notification zur√ºcksetzen
	});

	closeStatsButton.addEventListener('click', () => {
		statsModal.classList.remove('active');
	});

	resetStatsButton.addEventListener('click', resetStats);

	playAgainButton.addEventListener('click', () => {
		gameOverModal.classList.remove('active');
		initNewGame();
	});

	shareButton.addEventListener('click', () => {
		const text = translate({
			de: `Ich habe ${formatNumber(gameState.score)} Punkte in Bubble Merge erreicht, mit einer Blase vom Level ${gameState.maxLevel} (${formatNumber(gameState.maxValue)}) und einer Kette von ${gameState.longestChain} Verschmelzungen!`
		});

		// Versuche Web Share API wenn verf√ºgbar
		if (navigator.share) {
			navigator.share({
				title: 'Bubble Merge',
				text: text
			}).catch(err => {
				// Fallback: In Zwischenablage kopieren
				navigator.clipboard.writeText(text)
					.then(() => alert(translate({de: 'Ergebnis in die Zwischenablage kopiert!'})))
					.catch(() => alert(translate({de: 'Konnte nicht geteilt werden. Bitte manuell kopieren.'})));
			});
		} else {
			// Fallback: In Zwischenablage kopieren
			navigator.clipboard.writeText(text)
				.then(() => alert(translate({de: 'Ergebnis in die Zwischenablage kopiert!'})))
				.catch(() => alert(translate({de: 'Konnte nicht geteilt werden. Bitte manuell kopieren.'})));
		}
	});

	startGameButton.addEventListener('click', () => {
		tutorialModal.classList.remove('active');
		initNewGame();
	});

	// Tab-Wechsel-Logik
	tabButtons.forEach(button => {
		button.addEventListener('click', () => {
			// Aktiven Tab in Button-Gruppe markieren
			tabButtons.forEach(btn => btn.classList.remove('active'));
			button.classList.add('active');

			// Entsprechenden Tab-Inhalt anzeigen
			const tabId = button.dataset.tab;
			tabContents.forEach(content => {
				content.classList.remove('active');
			});
			document.getElementById(`${tabId}-tab`).classList.add('active');
		});
	});

	// Spielmodus-Buttons
	modeButtons.forEach(button => {
		if (!button.disabled) {
			button.addEventListener('click', () => {
				setGameMode(button.dataset.mode);
			});
		}
	});

	// Window Resize Handler
	window.addEventListener('resize', () => {
		createGridOverlay();

		if (gameState.bubbles.length > 0) {
			// Positionen aller Blasen neu berechnen
			gameState.bubbles.forEach(bubble => {
				const row = parseInt(bubble.dataset.row);
				const col = parseInt(bubble.dataset.col);
				const pos = getBubblePosition(row, col);

				const size = calculateBubbleSize();
				bubble.style.width = `${size}px`;
				bubble.style.height = `${size}px`;
				bubble.style.left = `${pos.x}px`;
				bubble.style.top = `${pos.y}px`;
			});
		}
	});

	// Spielzeit-Tracking
	setInterval(() => {
		if (gameState.startTime && !gameState.gameOver) {
			const now = new Date();
			gameState.playTime = Math.floor((now - gameState.startTime) / 1000);
		}
	}, 1000);

	// Bevorzugtes Farbschema
	if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
		document.body.setAttribute('data-theme', 'dark');
		moonIcon.style.display = 'none';
		sunIcon.style.display = 'block';
	}

	// Spiel starten
	setTimeout(() => {
		tutorialModal.classList.add('active');
	}, 500);

	// Auto-Save alle 30 Sekunden
	setInterval(() => {
		if (!gameState.gameOver && gameState.moveMade) {
			saveStatsToStorage();
		}
	}, 30000);

	function setupModalScrolling() {
		// Liste aller Modal-Contents
		const modalContents = document.querySelectorAll('.modal-content');

		// F√ºr jedes Modal-Content optimieren wir das Scrolling
		modalContents.forEach(modalContent => {
			// Verbesserte Touch-Event-Behandlung
			modalContent.addEventListener('touchstart', (e) => {
				// Erlaube das Scrollen im Modal-Content
				if (modalContent.scrollHeight > modalContent.clientHeight) {
					// Keine Notwendigkeit, das Event zu stoppen - wir wollen das nat√ºrliche Scrolling
				}
			}, {passive: true});

			modalContent.addEventListener('touchmove', (e) => {
				// Verhindere nur dann Propagation, wenn wir am Anfang oder Ende der Scrollposition sind
				const isAtTop = modalContent.scrollTop <= 0;
				const isAtBottom = modalContent.scrollHeight - modalContent.scrollTop <= modalContent.clientHeight + 1;

				// Wenn wir am oberen Rand sind und nach unten scrollen oder
				// am unteren Rand und nach oben scrollen, stoppe nicht
				if ((isAtTop && e.touches[0].clientY < e.touches[0].clientY) ||
					(isAtBottom && e.touches[0].clientY > e.touches[0].clientY)) {
					return;
				}

				// Andernfalls verhindern wir die Propagation, damit das Modal-Fenster nicht verschoben wird
				e.stopPropagation();
			}, {passive: false});
		});

		// Sicherstellen, dass Modals bei √ñffnung an den Anfang scrollen
		const modals = document.querySelectorAll('.modal');
		modals.forEach(modal => {
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.attributeName === 'class' &&
						modal.classList.contains('active')) {
						const content = modal.querySelector('.modal-content');
						if (content) content.scrollTop = 0;
					}
				});
			});

			observer.observe(modal, {attributes: true});
		});
	}

	function setupScrollableTabs() {
		// Scrollbare Tab-Navigation f√ºr alle Tab-Container
		const tabContainers = document.querySelectorAll('.tab-container');

		tabContainers.forEach(container => {
			const tabButtons = container.querySelector('.tab-buttons');

			if (tabButtons) {
				// Wenn der Tab-Container breit genug ist, automatisch den aktiven Tab in den Fokus bringen
				function scrollToActiveTab() {
					const activeTab = tabButtons.querySelector('.tab-button.active');
					if (activeTab) {
						// Finde die Position, um den Tab zu zentrieren
						const containerWidth = tabButtons.offsetWidth;
						const tabWidth = activeTab.offsetWidth;
						const tabLeft = activeTab.offsetLeft;

						// Berechne die Scroll-Position, die den Tab zentrieren w√ºrde
						const scrollPosition = tabLeft - (containerWidth / 2) + (tabWidth / 2);

						// Scrolle sanft zu dieser Position
						tabButtons.scrollTo({
							left: Math.max(0, scrollPosition),
							behavior: 'smooth'
						});
					}
				}

				// Scroll zum aktiven Tab bei Initialisierung
				setTimeout(scrollToActiveTab, 100);

				// Scroll zum aktiven Tab beim Klicken
				tabButtons.querySelectorAll('.tab-button').forEach(button => {
					button.addEventListener('click', () => {
						setTimeout(scrollToActiveTab, 10);
					});
				});
			}
		});
	}

	// VER√ÑNDERT: Funktion f√ºr Scroll-to-Top Button in Modals
	function addScrollToTopButtons() {
		const modalContents = document.querySelectorAll('.modal-content');

		modalContents.forEach(content => {
			// Pr√ºfe, ob der Inhalt scrollbar ist
			if (content.scrollHeight > content.clientHeight + 100) { // 100px Puffer
				const topButton = document.createElement('button');
				topButton.className = 'scroll-top-button';
				topButton.innerHTML = '‚Üë Nach oben';
				topButton.style.position = 'fixed';
				topButton.style.bottom = '80px';
				topButton.style.right = '20px';
				topButton.style.zIndex = '1000';
				topButton.style.display = 'none';
				topButton.style.padding = '8px 12px';
				topButton.style.backgroundColor = 'var(--accent-color)';
				topButton.style.color = 'white';
				topButton.style.border = 'none';
				topButton.style.borderRadius = '20px';
				topButton.style.cursor = 'pointer';

				content.appendChild(topButton);

				content.addEventListener('scroll', () => {
					if (content.scrollTop > 300) {
						topButton.style.display = 'block';
					} else {
						topButton.style.display = 'none';
					}
				});

				topButton.addEventListener('click', () => {
					content.scrollTo({top: 0, behavior: 'smooth'});
				});
			}
		});
	}

	// VER√ÑNDERT: Hilfsfunktion f√ºr Tipps zu Kettenreaktionen
	function showChainReactionTip() {
		// Nur zeigen, wenn der Spieler noch keine lange Kette hatte
		if (gameState.stats.longestChain < 3 && gameState.moves > 5 && Math.random() < 0.3) {
			const tip = document.createElement('div');
			tip.className = 'tutorial bottom';
			tip.style.bottom = '20%';
			tip.style.left = '50%';
			tip.style.transform = 'translateX(-50%)';
			tip.innerHTML = translate({
				de: 'Tipp: Versuche Blasen so zu platzieren, dass gleichartige Blasen nebeneinander liegen. So entstehen Kettenreaktionen!<br><button>Verstanden</button>'
			});
			tutorialsContainer.appendChild(tip);

			tip.querySelector('button').addEventListener('click', () => {
				tip.remove();
			});

			// Automatisch nach einiger Zeit ausblenden
			setTimeout(() => {
				if (tip.parentNode) {
					tip.remove();
				}
			}, 8000);
		}
	}

	// VER√ÑNDERT: Funktion aufrufen, nachdem der Spieler ein paar Z√ºge gemacht hat
	function setupChainReactionTips() {
		// Nach dem 5. Zug Tipps anzeigen, wenn n√∂tig
		if (gameState.moves === 5) {
			setTimeout(showChainReactionTip, 1000);
		}
	}

	// VER√ÑNDERT: Verbesserte Bubble-Resize-Handler f√ºr bessere Responsivit√§t
	function updateAllBubbleSizes() {
		const newBubbleSize = calculateBubbleSize();

		gameState.bubbles.forEach(bubble => {
			bubble.style.width = `${newBubbleSize}px`;
			bubble.style.height = `${newBubbleSize}px`;

			// Auch die Position aktualisieren
			const row = parseInt(bubble.dataset.row);
			const col = parseInt(bubble.dataset.col);
			const pos = getBubblePosition(row, col);

			bubble.style.left = `${pos.x}px`;
			bubble.style.top = `${pos.y}px`;
		});

		// Auch die N√§chste und Ziel-Bubbles aktualisieren
		updateNextAndGoalDisplays();
	}

	function updateNextAndGoalDisplays() {
		// Gr√∂√üe basierend auf Bildschirmgr√∂√üe
		const size = window.innerWidth <= 360 ? 35 :
			window.innerWidth <= 600 ? 45 : 60;

		// N√§chste Blase
		const nextBubbles = nextBubbleContainer.querySelectorAll('.bubble');
		nextBubbles.forEach(bubble => {
			bubble.style.width = `${size}px`;
			bubble.style.height = `${size}px`;
		});

		// Ziel-Blase
		const goalBubbles = goalBubbleContainer.querySelectorAll('.bubble');
		goalBubbles.forEach(bubble => {
			bubble.style.width = `${size}px`;
			bubble.style.height = `${size}px`;
		});
	}

	// VER√ÑNDERT: Verbesserte Hinweisfunktion f√ºr neue Spieler
	function showTutorial(step) {
		// Tutorials nur beim ersten Spielstart anzeigen
		if (gameState.tutorialStep > step) return;

		gameState.tutorialStep = step;
		tutorialsContainer.innerHTML = '';

		let tutorial;

		// Optimierte Positionierung f√ºr mobile Ger√§te
		const isMobile = window.innerWidth <= 600;

		switch (step) {
			case 1:
				// Erste Anleitung: Bewegen
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial bottom';
				tutorial.style.bottom = isMobile ? '60%' : '70%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '80%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Ziehe eine Blase, um sie zu bewegen.<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();
				});
				break;

			case 2:
				// Zweite Anleitung: Verschmelzen
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial top';
				tutorial.style.top = isMobile ? '60%' : '70%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '80%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Ziehe eine Blase direkt auf eine gleiche Blase, um sie zu verschmelzen!<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();
				});
				break;

			case 3:
				// Dritte Anleitung: Ketten
				tutorial = document.createElement('div');
				tutorial.className = 'tutorial bottom';
				tutorial.style.top = isMobile ? '15%' : '20%';
				tutorial.style.left = '50%';
				tutorial.style.transform = 'translateX(-50%)';
				tutorial.style.maxWidth = isMobile ? '85%' : '60%';
				tutorial.innerHTML = translate({
					de: 'Super! Versuche Kettenreaktionen zu erzeugen f√ºr extra Bonuspunkte.<br>Jede Verschmelzung in einer Kette gibt mehr Punkte!<br><button>Verstanden</button>'
				});
				tutorialsContainer.appendChild(tutorial);

				tutorial.querySelector('button').addEventListener('click', () => {
					tutorial.remove();

					// Zeige zus√§tzliche Erkl√§rung zur Schwerkraft im Gravity-Modus
					if (gameState.gravityEnabled) {
						setTimeout(() => {
							const gravityTip = document.createElement('div');
							gravityTip.className = 'tutorial top';
							gravityTip.style.top = '40%';
							gravityTip.style.left = '50%';
							gravityTip.style.transform = 'translateX(-50%)';
							gravityTip.style.maxWidth = isMobile ? '85%' : '60%';
							gravityTip.innerHTML = translate({
								de: 'Im Schwerkraft-Modus fallen Blasen nach unten, wenn darunter freie Pl√§tze sind. Das kann zus√§tzliche Kettenreaktionen ausl√∂sen!<br><button>Verstanden</button>'
							});
							tutorialsContainer.appendChild(gravityTip);

							gravityTip.querySelector('button').addEventListener('click', () => {
								gravityTip.remove();
							});
						}, 500);
					}
				});
				break;
		}

		// Entferne Tutorial automatisch nach 15 Sekunden, falls der Benutzer es ignoriert
		setTimeout(() => {
			if (tutorial && tutorial.parentNode) {
				tutorial.remove();
			}
		}, 15000);
	}

	// Alle Funktionen nach dem DOM-Laden ausf√ºhren
	window.addEventListener('DOMContentLoaded', function () {
		loadStatsFromStorage();
		setupModalScrolling();
		setupScrollableTabs();
		addScrollToTopButtons();
		updateModeButtons();
	});

	// Event-Listener f√ºr die Resize-Funktion
	window.addEventListener('resize', () => {
		createGridOverlay();
		updateAllBubbleSizes();
	});
</script>
</body>
</html>
