<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bubble Merge</title>
    <style>
        :root {
            --primary-color: #4a9df3;
            --secondary-color: #f3ca4a;
            --background-light: #f5f5f5;
            --background-dark: #2a2a2a;
            --text-light: #2a2a2a;
            --text-dark: #f5f5f5;
            --grid-gap: 8px;
            --grid-size: 5;
            --cell-size: 60px;
        }

        * {
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
            min-height: 100vh;
            user-select: none;
        }

        body.dark-mode {
            background-color: var(--background-dark);
            color: var(--text-dark);
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
        }

        .game-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-size: 16px;
        }

        .btn:hover {
            background-color: #3a8de3;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-icon {
            width: 20px;
            height: 20px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            padding: 0 20px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-weight: bold;
        }

        .grid-container {
            position: relative;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--grid-gap);
            position: relative;
        }

        .cell {
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: background-color 0.2s;
        }

        .cell.highlight {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .bubble {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 -4px 0 rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 5%;
            left: 5%;
        }

        .bubble:active {
            transform: scale(0.95);
        }

        .bubble.dragging {
            opacity: 0.8;
            z-index: 100;
        }

        .bubble.selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 3px #fff, 0 0 0 5px #4a9df3;
        }

        .bubble.merge-target {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .bubble.merging {
            animation: merge 0.5s forwards;
        }

        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .bubble.level-1 { 
            background: radial-gradient(circle at 30% 30%, #FF7676, #FF5252); 
        }
        .bubble.level-2 { 
            background: radial-gradient(circle at 30% 30%, #FFBB4D, #FF9800); 
        }
        .bubble.level-3 { 
            background: radial-gradient(circle at 30% 30%, #FFF176, #FFEB3B); 
        }
        .bubble.level-4 { 
            background: radial-gradient(circle at 30% 30%, #81C784, #4CAF50); 
        }
        .bubble.level-5 { 
            background: radial-gradient(circle at 30% 30%, #64B5F6, #2196F3); 
        }
        .bubble.level-6 { 
            background: radial-gradient(circle at 30% 30%, #9575CD, #673AB7); 
        }
        .bubble.level-7 { 
            background: radial-gradient(circle at 30% 30%, #F48FB1, #E91E63); 
        }
        .bubble.level-8 { 
            background: radial-gradient(circle at 30% 30%, #4DD0E1, #00BCD4); 
        }
        .bubble.level-9 { 
            background: radial-gradient(circle at 30% 30%, #A1887F, #795548); 
        }
        .bubble.level-10 { 
            background: radial-gradient(circle at 30% 30%, #90A4AE, #607D8B); 
        }
        .bubble.level-11 { 
            background: radial-gradient(circle at 30% 30%, #EF5350, #F44336); 
        }
        .bubble.level-12 { 
            background: radial-gradient(circle at 30% 30%, #26A69A, #009688); 
        }

        .bubble.patrick {
            background: linear-gradient(135deg, #FF9800, #F44336);
        }

        .bubble.rott {
            background: linear-gradient(135deg, #4CAF50, #2196F3);
        }

        .next-bubbles {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            align-items: center;
        }

        .next-label {
            margin-right: 10px;
            font-weight: bold;
        }

        .next-bubble-container {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .next-bubble {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.2);
        }

        .tutorial {
            margin: 15px 0;
            padding: 10px 15px;
            background-color: rgba(74, 157, 243, 0.2);
            border-radius: 8px;
            text-align: center;
            max-width: 90%;
            font-weight: bold;
            border: 1px solid rgba(74, 157, 243, 0.5);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: var(--background-light);
            color: var(--text-light);
            padding: 20px;
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        body.dark-mode .modal-content {
            background-color: var(--background-dark);
            color: var(--text-dark);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: bold;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: inherit;
        }

        .achievements-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .achievement {
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }

        .achievement.unlocked {
            background-color: rgba(76, 175, 80, 0.2);
        }

        .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: 14px;
            color: rgba(0, 0, 0, 0.7);
        }

        body.dark-mode .achievement-description {
            color: rgba(255, 255, 255, 0.7);
        }

        .combo-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 50;
        }

        .combo-indicator.active {
            opacity: 1;
            transform: translate(-50%, -100%) scale(1.5);
        }

        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            z-index: 900;
        }

        .notification.active {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .game-over-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            border-radius: 8px;
            z-index: 200;
        }

        .game-over-container.active {
            opacity: 1;
            pointer-events: auto;
        }

        .game-over-text {
            font-size: 36px;
            color: white;
            margin-bottom: 20px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .final-score {
            font-size: 24px;
            color: white;
            margin-bottom: 20px;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        /* Particle effect styles */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 40;
        }

        /* Hint system */
        .hint-bubble {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 255, 0, 0.5);
            pointer-events: none;
            z-index: 25;
            animation: hintPulse 1.5s infinite;
        }

        @keyframes hintPulse {
            0% { transform: scale(0.8); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.7; }
        }

        /* Responsive design */
        @media (max-width: 600px) {
            :root {
                --cell-size: 50px;
            }
            
            .game-title {
                font-size: 20px;
            }
            
            .stats {
                font-size: 16px;
                gap: 10px;
            }
            
            .action-buttons {
                flex-direction: column;
                gap: 8px;
            }
            
            .btn {
                padding: 10px;
                margin: 0;
                width: 100%;
                max-width: 250px;
            }
        }

        @media (max-width: 450px) {
            :root {
                --cell-size: 42px;
                --grid-gap: 6px;
            }
            
            .bubble {
                font-size: 16px;
            }
            
            .controls {
                gap: 5px;
            }
            
            .btn-icon {
                width: 16px;
                height: 16px;
            }
            
            .next-bubble {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            
            .next-bubble-container {
                width: 35px;
                height: 35px;
            }
        }

        @media (max-width: 380px) {
            :root {
                --cell-size: 35px;
                --grid-gap: 4px;
            }
            
            .header {
                padding: 8px 10px;
            }
            
            .game-title {
                font-size: 18px;
            }
            
            .controls .btn {
                padding: 6px 8px;
            }
            
            .stats {
                font-size: 14px;
                gap: 8px;
            }
        }
        
        /* Zus√§tzliches Media Query f√ºr sehr kleine Ger√§te */
        @media (max-width: 320px) {
            :root {
                --cell-size: 30px;
                --grid-gap: 3px;
            }
            
            .bubble {
                font-size: 14px;
            }
            
            .next-bubble {
                width: 25px;
                height: 25px;
                font-size: 12px;
            }
            
            .next-bubble-container {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="game-title">Bubble Merge</h1>
        <div class="controls">
            <button id="theme-toggle" class="btn">
                <span class="btn-icon">‚òÄÔ∏è</span>
            </button>
            <button id="mute-toggle" class="btn">
                <span class="btn-icon">üîä</span>
            </button>
            <button id="achievements-btn" class="btn">üèÜ</button>
            <button id="help-btn" class="btn">‚ùì</button>
            <button id="restart-btn" class="btn">üîÑ</button>
        </div>
    </div>

    <div class="game-container">
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Punkte</div>
                <div id="score" class="stat-value">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">H√∂chste Blase</div>
                <div id="highest-bubble" class="stat-value">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Beste Combo</div>
                <div id="best-combo" class="stat-value">0</div>
            </div>
        </div>

        <div id="tutorial" class="tutorial">
            Tippe eine Blase an und dann eine freie Zelle, um sie zu bewegen.
            <br>Verbinde gleiche Blasen, um sie zu einer h√∂heren Stufe zu verschmelzen!
        </div>

        <div class="grid-container">
            <div id="grid" class="grid"></div>
            <div id="combo-indicator" class="combo-indicator"></div>
            <div id="game-over" class="game-over-container">
                <div class="game-over-text">Game Over!</div>
                <div id="final-score" class="final-score">Punkte: 0</div>
                <button id="restart-game" class="btn">Neu starten</button>
            </div>
        </div>
        
        <div class="next-bubbles">
            <div class="next-label">N√§chste:</div>
            <div class="next-bubble-container">
                <div id="next-bubble-1" class="next-bubble level-1">1</div>
            </div>
            <div class="next-bubble-container">
                <div id="next-bubble-2" class="next-bubble level-1">1</div>
            </div>
            <div class="next-bubble-container">
                <div id="next-bubble-3" class="next-bubble level-1">1</div>
            </div>
        </div>

        <div class="action-buttons">
            <button id="place-bubble" class="btn">Neue Blasen (x1-3)</button>
            <button id="shuffle-board" class="btn">Blasen neu mischen</button>
            <button id="hint-btn" class="btn">Tipp</button>
        </div>
    </div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Spielanleitung</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Spielprinzip:</h3>
                <p>Fusioniere gleichfarbige Blasen mit derselben Zahl, um Blasen h√∂herer Stufen zu erzeugen.</p>
                
                <h3>Steuerung:</h3>
                <ul>
                    <li>Tippe auf eine Blase, um sie auszuw√§hlen.</li>
                    <li>Tippe auf ein leeres Feld, um sie dorthin zu bewegen.</li>
                    <li>Tippe auf eine gleichwertige Blase, um beide zu fusionieren.</li>
                    <li>Finde Gruppen von 3+ gleichwertigen Blasen, um sie alle auf einmal zu verschmelzen!</li>
                    <li>Nach jedem Zug erscheint automatisch eine neue Blase.</li>
                    <li>Dr√ºcke auf "Neue Blasen", um zus√§tzliche Blasen ins Spiel zu bringen.</li>
                    <li>Alle 3 Z√ºge erscheint eine Bonusblase!</li>
                    <li>Nach gr√∂√üeren Kettenreaktionen werden automatisch neue Blasen hinzugef√ºgt.</li>
                    <li>Dr√ºcke auf "Blasen neu mischen", wenn du keine Z√ºge mehr hast (kostet Punkte!).</li>
                    <li>Dr√ºcke auf "Tipp", um einen m√∂glichen Zug angezeigt zu bekommen.</li>
                </ul>

                <h3>Spezialblasen:</h3>
                <ul>
                    <li>Patrick (P): Spezialblase, kann mit Rott fusioniert werden.</li>
                    <li>Rott (R): Spezialblase, kann mit Patrick fusioniert werden.</li>
                    <li>Wenn Patrick und Rott fusioniert werden, entsteht eine Level-3-Blase!</li>
                </ul>

                <h3>Tipps:</h3>
                <ul>
                    <li>Plane voraus! Schaue auf die n√§chsten Blasen.</li>
                    <li>Versuche, Combos zu erzeugen, indem du Kettenfusionen ausl√∂st.</li>
                    <li>Halte genug freie Felder f√ºr neue Blasen.</li>
                    <li>Nutze die "Tipp"-Funktion, wenn du nicht weiterkommst.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="achievements-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Errungenschaften</h2>
                <button class="close-modal">&times;</button>
            </div>
            <div id="achievements-list" class="achievements-list"></div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // Spiel-Konstanten
        const GRID_SIZE = 5;
        const MAX_LEVEL = 12;
        const SPECIAL_BUBBLE_CHANCE = 0.07;
        const INITIAL_BUBBLES = 8; // Reduziert von 10 f√ºr besseren Start
        const CHAIN_REACTION_DELAY = 250; // Etwas verl√§ngert f√ºr bessere Sichtbarkeit
        const SHUFFLE_COST = 50;
        const HINT_COST = 20;
        const ADD_BUBBLE_INTERVAL = 3; // F√ºge alle 3 Z√ºge eine Bonusblase hinzu
        const MIN_BUBBLES_AFTER_CHAIN = 6; // Mindestanzahl von Blasen nach einer Kettenreaktion
        const FORCE_MATCHING_BUBBLE_CHANCE = 0.4; // 40% Chance, dass eine hinzugef√ºgte Blase zu einer vorhandenen passt
        const GROUP_MERGE_MIN_COUNT = 3; // Mindestanzahl f√ºr Gruppen-Verschmelzung

        // Spielzustand
        let state = {
            grid: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null)),
            score: 0,
            highestBubble: 1,
            combo: 0,
            bestCombo: 0,
            nextBubbles: [1, 1, 1],
            gameOver: false,
            selectedBubble: null,
            moveCount: 0,
            placingMode: false,
            achievements: [
                { id: 'level5', title: 'Aufsteiger', description: 'Erreiche eine Level 5 Blase', unlocked: false, reward: 500 },
                { id: 'level8', title: 'Bubble-Meister', description: 'Erreiche eine Level 8 Blase', unlocked: false, reward: 1000 },
                { id: 'level10', title: 'Bubble-K√∂nig', description: 'Erreiche eine Level 10 Blase', unlocked: false, reward: 2000 },
                { id: 'combo5', title: 'Combo-Starter', description: 'Erreiche eine 5er-Combo', unlocked: false, reward: 300 },
                { id: 'combo10', title: 'Combo-Profi', description: 'Erreiche eine 10er-Combo', unlocked: false, reward: 800 },
                { id: 'score1000', title: '1000 Punkte', description: 'Erreiche 1000 Punkte', unlocked: false, reward: 100 },
                { id: 'score5000', title: '5000 Punkte', description: 'Erreiche 5000 Punkte', unlocked: false, reward: 500 },
                { id: 'score10000', title: '10000 Punkte', description: 'Erreiche 10000 Punkte', unlocked: false, reward: 1000 },
                { id: 'special', title: 'Spezialblase', description: 'Finde eine Spezialblase', unlocked: false, reward: 200 },
                { id: 'special5', title: 'Spezialist', description: 'Finde 5 Spezialblasen', unlocked: false, reward: 500 },
                { id: 'filled', title: 'Vollst√§ndig', description: 'F√ºlle das gesamte Spielfeld', unlocked: false, reward: 1000 },
                { id: 'cleared', title: 'Aufger√§umt', description: 'Entferne alle Blasen vom Spielfeld', unlocked: false, reward: 2000 }
            ],
            specialBubblesFound: 0,
            muted: false,
            darkMode: false,
            tutorialSeen: false,
            hintActive: false
        };

        // DOM-Elemente
        const gridElement = document.getElementById('grid');
        const scoreElement = document.getElementById('score');
        const highestBubbleElement = document.getElementById('highest-bubble');
        const bestComboElement = document.getElementById('best-combo');
        const comboIndicatorElement = document.getElementById('combo-indicator');
        const nextBubbleElements = [
            document.getElementById('next-bubble-1'),
            document.getElementById('next-bubble-2'),
            document.getElementById('next-bubble-3')
        ];
        const gameOverElement = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-btn');
        const restartGameButton = document.getElementById('restart-game');
        const achievementsButton = document.getElementById('achievements-btn');
        const achievementsModal = document.getElementById('achievements-modal');
        const achievementsList = document.getElementById('achievements-list');
        const helpButton = document.getElementById('help-btn');
        const helpModal = document.getElementById('help-modal');
        const closeModalButtons = document.querySelectorAll('.close-modal');
        const notificationElement = document.getElementById('notification');
        const themeToggleButton = document.getElementById('theme-toggle');
        const muteToggleButton = document.getElementById('mute-toggle');
        const placeBubbleButton = document.getElementById('place-bubble');
        const shuffleBoardButton = document.getElementById('shuffle-board');
        const hintButton = document.getElementById('hint-btn');
        const tutorialElement = document.getElementById('tutorial');

        // Speichern und Laden
        function saveGame() {
            try {
                const saveData = JSON.stringify({
                    grid: state.grid,
                    score: state.score,
                    highestBubble: state.highestBubble,
                    bestCombo: state.bestCombo,
                    nextBubbles: state.nextBubbles,
                    achievements: state.achievements,
                    specialBubblesFound: state.specialBubblesFound,
                    muted: state.muted,
                    darkMode: state.darkMode,
                    tutorialSeen: state.tutorialSeen,
                    moveCount: state.moveCount
                });
                
                try {
                    localStorage.setItem('bubbleMergeGame', saveData);
                } catch (e) {
                    // Fallback mit Cookies, wenn localStorage nicht verf√ºgbar ist
                    const expiryDate = new Date();
                    expiryDate.setDate(expiryDate.getDate() + 30);
                    document.cookie = `bubbleMergeGame=${encodeURIComponent(saveData)}; expires=${expiryDate.toUTCString()}; path=/`;
                }
            } catch (error) {
                console.error('Speichern fehlgeschlagen:', error);
            }
        }

        function loadGame() {
            try {
                let saveData;
                
                try {
                    saveData = localStorage.getItem('bubbleMergeGame');
                } catch (e) {
                    // Fallback auf Cookies
                    const cookies = document.cookie.split(';');
                    for (const cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'bubbleMergeGame') {
                            saveData = decodeURIComponent(value);
                            break;
                        }
                    }
                }
                
                if (saveData) {
                    const parsedData = JSON.parse(saveData);
                    state.grid = parsedData.grid;
                    state.score = parsedData.score;
                    state.highestBubble = parsedData.highestBubble;
                    state.bestCombo = parsedData.bestCombo;
                    state.nextBubbles = parsedData.nextBubbles;
                    state.achievements = parsedData.achievements;
                    state.specialBubblesFound = parsedData.specialBubblesFound || 0;
                    state.muted = parsedData.muted || false;
                    state.darkMode = parsedData.darkMode || false;
                    state.tutorialSeen = parsedData.tutorialSeen || false;
                    state.moveCount = parsedData.moveCount || 0;
                    
                    updateStats();
                    renderGrid();
                    updateNextBubbles();
                    applyTheme();
                    updateMuteButton();
                    
                    if (state.tutorialSeen) {
                        tutorialElement.style.display = 'none';
                    }
                    
                    return true;
                }
            } catch (error) {
                console.error('Laden fehlgeschlagen:', error);
            }
            
            return false;
        }

        // Spiel initialisieren
        function initGame() {
            // Grid erstellen
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    gridElement.appendChild(cell);
                }
            }
            
            // Event-Listener
            restartButton.addEventListener('click', confirmRestart);
            restartGameButton.addEventListener('click', restartGame);
            
            achievementsButton.addEventListener('click', () => {
                renderAchievements();
                achievementsModal.classList.add('active');
            });
            
            helpButton.addEventListener('click', () => {
                helpModal.classList.add('active');
                state.tutorialSeen = true;
                tutorialElement.style.display = 'none';
                saveGame();
            });
            
            closeModalButtons.forEach(button => {
                button.addEventListener('click', () => {
                    achievementsModal.classList.remove('active');
                    helpModal.classList.remove('active');
                });
            });
            
            themeToggleButton.addEventListener('click', toggleTheme);
            muteToggleButton.addEventListener('click', toggleMute);
            placeBubbleButton.addEventListener('click', handlePlaceBubble);
            shuffleBoardButton.addEventListener('click', confirmShuffle);
            hintButton.addEventListener('click', showHint);
            
            // Laden oder neues Spiel starten
            if (!loadGame()) {
                startNewGame();
            }
            
            // Automatisches Speichern alle 30 Sekunden
            setInterval(saveGame, 30000);
        }

        function startNewGame() {
            // Grid zur√ºcksetzen
            state.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // Zuf√§llige Blasen platzieren
            for (let i = 0; i < INITIAL_BUBBLES; i++) {
                addRandomBubble();
            }
            
            // Spielzustand zur√ºcksetzen
            state.score = 0;
            state.highestBubble = 1;
            state.combo = 0;
            state.bestCombo = 0;
            state.gameOver = false;
            state.selectedBubble = null;
            state.moveCount = 0;
            state.placingMode = false;
            state.hintActive = false;
            state.nextBubbles = [
                getRandomBubbleLevel(1, 2),
                getRandomBubbleLevel(1, 2),
                getRandomBubbleLevel(1, 2)
            ];
            
            // UI aktualisieren
            updateStats();
            renderGrid();
            updateNextBubbles();
            gameOverElement.classList.remove('active');
            
            // Achievements bleiben erhalten
            saveGame();
        }

        function confirmRestart() {
            if (confirm('Wirklich neu starten? Der aktuelle Spielstand geht verloren.')) {
                restartGame();
            }
        }

        function restartGame() {
            startNewGame();
            showNotification('Neues Spiel gestartet!');
        }

        function confirmShuffle() {
            if (state.score < SHUFFLE_COST) {
                showNotification(`Du brauchst ${SHUFFLE_COST} Punkte zum Mischen!`);
                return;
            }
            
            if (confirm(`Blasen neu mischen? Dies kostet ${SHUFFLE_COST} Punkte.`)) {
                shuffleBoard();
            }
        }

        function shuffleBoard() {
            // Punkte abziehen
            state.score -= SHUFFLE_COST;
            
            // Alle Blasen sammeln
            const bubbles = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] !== null) {
                        bubbles.push(state.grid[y][x]);
                    }
                }
            }
            
            // Blasen mischen
            bubbles.sort(() => Math.random() - 0.5);
            
            // Grid leeren
            state.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // Gemischte Blasen platzieren
            let bubbleIndex = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (bubbleIndex < bubbles.length) {
                        state.grid[y][x] = bubbles[bubbleIndex];
                        bubbleIndex++;
                    }
                }
            }
            
            // UI aktualisieren
            updateStats();
            renderGrid();
            showNotification('Blasen neu gemischt!');
            
            // Speichern
            saveGame();
        }

        // Bubble-Handling
        function addRandomBubble() {
            const emptyCells = [];
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] === null) {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                let level;
                let special = null;
                
                // √úberpr√ºfen, ob wir eine passende Blase einf√ºgen sollten
                if (Math.random() < FORCE_MATCHING_BUBBLE_CHANCE) {
                    level = getMatchingBubbleLevel();
                } else {
                    level = getRandomBubbleLevel(1, Math.min(3, state.highestBubble));
                }
                
                // Spezielle Blasen (Patrick oder Rott)
                if (Math.random() < SPECIAL_BUBBLE_CHANCE) {
                    // Pr√ºfen, ob bereits eine spezielle Blase vorhanden ist
                    const hasPatrick = checkForSpecialBubble('patrick');
                    const hasRott = checkForSpecialBubble('rott');
                    
                    // Wenn eine vorhanden ist, die andere einf√ºgen, sonst zuf√§llig
                    if (hasPatrick && !hasRott) {
                        special = 'rott';
                    } else if (hasRott && !hasPatrick) {
                        special = 'patrick';
                    } else {
                        special = Math.random() < 0.5 ? 'patrick' : 'rott';
                    }
                    
                    if (!state.achievements.find(a => a.id === 'special').unlocked) {
                        unlockAchievement('special');
                    }
                    
                    state.specialBubblesFound++;
                    if (state.specialBubblesFound >= 5 && !state.achievements.find(a => a.id === 'special5').unlocked) {
                        unlockAchievement('special5');
                    }
                }
                
                state.grid[cell.y][cell.x] = { level, special };
                return true; // Erfolgreich hinzugef√ºgt
            }
            
            checkGameOver();
            return false; // Keine Zelle gefunden
        }
        
        // Pr√ºft, ob eine spezielle Blase bereits vorhanden ist
        function checkForSpecialBubble(specialType) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const bubble = state.grid[y][x];
                    if (bubble && bubble.special === specialType) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Findet einen passenden Bubble-Level basierend auf vorhandenen Blasen
        function getMatchingBubbleLevel() {
            // Alle vorhandenen Bubble-Level sammeln
            const existingLevels = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const bubble = state.grid[y][x];
                    if (bubble && !bubble.special) {
                        existingLevels.push(bubble.level);
                    }
                }
            }
            
            // Wenn keine Blasen vorhanden sind, Standardlevel zur√ºckgeben
            if (existingLevels.length === 0) {
                return getRandomBubbleLevel(1, Math.min(3, state.highestBubble));
            }
            
            // Zuf√§llig eine der vorhandenen Ebenen ausw√§hlen
            return existingLevels[Math.floor(Math.random() * existingLevels.length)];
        }
        
        // Stellt sicher, dass eine Mindestanzahl von Blasen auf dem Spielfeld ist
        function ensureMinimumBubbles() {
            // Z√§hle aktuelle Blasen
            let currentBubbles = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] !== null) {
                        currentBubbles++;
                    }
                }
            }
            
            // Wenn zu wenige, f√ºge neue hinzu
            if (currentBubbles < MIN_BUBBLES_AFTER_CHAIN) {
                const bubblesNeeded = MIN_BUBBLES_AFTER_CHAIN - currentBubbles;
                let bubblesAdded = 0;
                
                for (let i = 0; i < bubblesNeeded; i++) {
                    if (addRandomBubble()) {
                        bubblesAdded++;
                    } else {
                        break; // Keine freien Zellen mehr
                    }
                }
                
                if (bubblesAdded > 0) {
                    renderGrid();
                    showNotification(`${bubblesAdded} neue Blasen hinzugef√ºgt!`);
                }
            }
        }

        function getRandomBubbleLevel(min, max) {
            // Gewichtete Wahrscheinlichkeit, niedrigere Level sind wahrscheinlicher
            const weights = [];
            for (let i = min; i <= max; i++) {
                weights.push({ level: i, weight: Math.pow(0.6, i - min) });
            }
            
            const totalWeight = weights.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const item of weights) {
                if (random < item.weight) {
                    return item.level;
                }
                random -= item.weight;
            }
            
            return min;
        }

        function handleCellClick(x, y) {
            // Game Over Check
            if (state.gameOver) return;
            
            // Hint entfernen, wenn vorhanden
            removeHint();
            
            // Im Platzierungsmodus neue Blase platzieren
            if (state.placingMode) {
                if (state.grid[y][x] === null) {
                    placeNextBubble(x, y);
                    state.placingMode = false;
                    
                    // Hervorhebungen entfernen
                    const highlightedCells = document.querySelectorAll('.cell.highlight');
                    highlightedCells.forEach(cell => cell.classList.remove('highlight'));
                    
                    return;
                }
            }
            
            // Aktuelle Zelle
            const bubble = state.grid[y][x];
            
            // Fall 1: Keine Blase ausgew√§hlt und Zelle enth√§lt Blase -> Blase ausw√§hlen
            if (state.selectedBubble === null && bubble !== null) {
                selectBubble(x, y);
                return;
            }
            
            // Fall 2: Blase ausgew√§hlt und Klick auf leere Zelle -> Blase bewegen
            if (state.selectedBubble !== null && bubble === null) {
                const { x: selectedX, y: selectedY } = state.selectedBubble;
                
                // Pr√ºfen ob Nachbarfeld
                if (isAdjacent(selectedX, selectedY, x, y)) {
                    moveBubble(selectedX, selectedY, x, y);
                } else {
                    showNotification('Bewege Blasen nur auf Nachbarfelder!');
                }
                return;
            }
            
            // Fall 3: Blase ausgew√§hlt und Klick auf andere Blase -> pr√ºfen ob kombinierbar
            if (state.selectedBubble !== null && bubble !== null) {
                const { x: selectedX, y: selectedY } = state.selectedBubble;
                
                // Klick auf selbe Blase = deselektieren
                if (selectedX === x && selectedY === y) {
                    deselectBubble();
                    return;
                }
                
                // Pr√ºfen ob Nachbarfeld und kombinierbar
                if (isAdjacent(selectedX, selectedY, x, y) && canMerge(selectedX, selectedY, x, y)) {
                    mergeBubbles(selectedX, selectedY, x, y);
                } else if (isAdjacent(selectedX, selectedY, x, y)) {
                    showNotification('Diese Blasen k√∂nnen nicht kombiniert werden!');
                    deselectBubble();
                } else {
                    // Andere Blase ausw√§hlen
                    selectBubble(x, y);
                }
                return;
            }
        }

        function isAdjacent(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
        }

        function selectBubble(x, y) {
            // Vorherige Auswahl l√∂schen
            deselectBubble();
            
            const bubble = state.grid[y][x];
            if (!bubble) return;
            
            state.selectedBubble = { x, y };
            
            // Bubble-Element holen und markieren
            const bubbleElement = document.querySelector(`.bubble[data-x="${x}"][data-y="${y}"]`);
            if (bubbleElement) {
                bubbleElement.classList.add('selected');
                
                // M√∂gliche Zielfelder hervorheben
                highlightTargets(x, y);
                
                // Sound abspielen
                playSound('select');
                
                // Feedback f√ºr den Nutzer
                showNotification(`Blase ausgew√§hlt (Level ${bubble.level})`, 1000);
            }
        }

        function deselectBubble() {
            // Auswahl entfernen
            if (state.selectedBubble) {
                const { x, y } = state.selectedBubble;
                const bubbleElement = document.querySelector(`.bubble[data-x="${x}"][data-y="${y}"]`);
                if (bubbleElement) {
                    bubbleElement.classList.remove('selected');
                }
            }
            
            // Alle Hervorhebungen entfernen
            const highlightedCells = document.querySelectorAll('.cell.highlight');
            highlightedCells.forEach(cell => cell.classList.remove('highlight'));
            
            const mergeTargets = document.querySelectorAll('.bubble.merge-target');
            mergeTargets.forEach(bubble => bubble.classList.remove('merge-target'));
            
            state.selectedBubble = null;
        }

        function highlightTargets(x, y) {
            const bubble = state.grid[y][x];
            if (!bubble) return;
            
            // Alle Nachbarfelder durchgehen
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue; // Aktuelle Zelle √ºberspringen
                    
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    // Pr√ºfen ob im Grid
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                        const targetBubble = state.grid[newY][newX];
                        
                        // Leere Zelle = m√∂gliches Bewegungsziel
                        if (targetBubble === null) {
                            const cellElement = document.querySelector(`.cell[data-x="${newX}"][data-y="${newY}"]`);
                            if (cellElement) {
                                cellElement.classList.add('highlight');
                            }
                        } 
                        // Pr√ºfen, ob Blasen kombinierbar sind
                        else if (canMerge(x, y, newX, newY)) {
                            const bubbleElement = document.querySelector(`.bubble[data-x="${newX}"][data-y="${newY}"]`);
                            if (bubbleElement) {
                                bubbleElement.classList.add('merge-target');
                            }
                        }
                    }
                }
            }
        }

        function canMerge(x1, y1, x2, y2) {
            const bubble1 = state.grid[y1][x1];
            const bubble2 = state.grid[y2][x2];
            
            if (!bubble1 || !bubble2) return false;
            
            // √úberpr√ºfe Level als Zahlen, um Typenprobleme zu vermeiden
            const level1 = parseInt(bubble1.level);
            const level2 = parseInt(bubble2.level);
            
            // Gleiche Level oder spezielle Blasen-Kombination
            return (level1 === level2) || 
                   (bubble1.special && bubble2.special && bubble1.special !== bubble2.special);
        }

        function moveBubble(fromX, fromY, toX, toY) {
            // Pr√ºfen ob Quell- und Zielkoordinaten g√ºltig sind
            if (fromX < 0 || fromX >= GRID_SIZE || fromY < 0 || fromY >= GRID_SIZE ||
                toX < 0 || toX >= GRID_SIZE || toY < 0 || toY >= GRID_SIZE) {
                return false;
            }
            
            // Pr√ºfen ob Quellfeld eine Blase hat und Zielfeld leer ist
            if (state.grid[fromY][fromX] === null || state.grid[toY][toX] !== null) {
                return false;
            }
            
            // Blase bewegen
            state.grid[toY][toX] = state.grid[fromY][fromX];
            state.grid[fromY][fromX] = null;
            
            // Auswahl zur√ºcksetzen
            deselectBubble();
            
            // Grid neu rendern mit Animation
            animateMove(fromX, fromY, toX, toY);
            
            // Sound abspielen
            playSound('move');
            
            // Zugz√§hler erh√∂hen
            state.moveCount++;
            
            // Pr√ºfen, ob eine Bonusblase hinzugef√ºgt werden sollte
            if (state.moveCount % ADD_BUBBLE_INTERVAL === 0) {
                setTimeout(() => {
                    if (countEmptyCells() > 0) {
                        addRandomBubble();
                        showNotification("Bonusblase hinzugef√ºgt!");
                        renderGrid();
                    }
                }, CHAIN_REACTION_DELAY * 2);
            }
            
            // Kettenreaktion pr√ºfen
            setTimeout(() => {
                checkChainReaction(toX, toY);
                checkGameOver();
                saveGame();
            }, CHAIN_REACTION_DELAY);
            
            return true;
        }

        function animateMove(fromX, fromY, toX, toY) {
            // Position der Quell- und Zielzelle im DOM
            const sourceCell = document.querySelector(`.cell[data-x="${fromX}"][data-y="${fromY}"]`);
            const targetCell = document.querySelector(`.cell[data-x="${toX}"][data-y="${toY}"]`);
            
            if (!sourceCell || !targetCell) {
                renderGrid(); // Fallback
                return;
            }
            
            const sourceBubble = state.grid[toY][toX]; // Die Blase ist bereits im state umgezogen
            
            // Entfernen der alten Blase
            const oldBubbleElement = document.querySelector(`.bubble[data-x="${fromX}"][data-y="${fromY}"]`);
            if (oldBubbleElement) {
                oldBubbleElement.remove();
            }
            
            // Erstellen einer neuen animierten Blase
            const newBubbleElement = document.createElement('div');
            newBubbleElement.classList.add('bubble', `level-${sourceBubble.level}`);
            newBubbleElement.dataset.x = toX;
            newBubbleElement.dataset.y = toY;
            newBubbleElement.textContent = sourceBubble.level;
            
            if (sourceBubble.special) {
                newBubbleElement.classList.add(sourceBubble.special);
                newBubbleElement.textContent = sourceBubble.special === 'patrick' ? 'P' : 'R';
            }
            
            // Positionierung f√ºr Animation
            const sourceRect = sourceCell.getBoundingClientRect();
            const targetRect = targetCell.getBoundingClientRect();
            const gridRect = gridElement.getBoundingClientRect();
            
            const startX = sourceRect.left - gridRect.left + sourceRect.width / 2;
            const startY = sourceRect.top - gridRect.top + sourceRect.height / 2;
            const endX = targetRect.left - gridRect.left + targetRect.width / 2;
            const endY = targetRect.top - gridRect.top + targetRect.height / 2;
            
            // Animation
            newBubbleElement.style.transition = 'transform 0.2s ease-in-out';
            newBubbleElement.style.transform = `translate(${startX - endX}px, ${startY - endY}px)`;
            
            targetCell.appendChild(newBubbleElement);
            
            // Nach kurzer Zeit die Animation starten
            setTimeout(() => {
                newBubbleElement.style.transform = 'translate(0, 0)';
            }, 10);
            
            // Nach der Animation aufr√§umen
            setTimeout(() => {
                renderGrid();
            }, 250);
        }

        function mergeBubbles(fromX, fromY, toX, toY) {
            const sourceBubble = state.grid[fromY][fromX];
            const targetBubble = state.grid[toY][toX];
            
            if (!sourceBubble || !targetBubble) return false;
            
            // √úberpr√ºfe Levels als Zahlen
            const sourceLevel = parseInt(sourceBubble.level);
            const targetLevel = parseInt(targetBubble.level);
            
            // Pr√ºfen, ob Blasen kompatibel sind (gleiche Level oder spezielle Blasen)
            const canMerge = 
                (sourceLevel === targetLevel) || 
                (sourceBubble.special && targetBubble.special && sourceBubble.special !== targetBubble.special);
            
            if (!canMerge) return false;
            
            // Pr√ºfen auf Gruppenmerge (f√ºr mehrere Blasen gleichzeitig)
            if (sourceLevel === targetLevel && !sourceBubble.special && !targetBubble.special) {
                const mergeGroup = findConnectedBubbles(toX, toY, targetLevel);
                
                if (mergeGroup.length >= GROUP_MERGE_MIN_COUNT) {
                    return groupMerge(mergeGroup, fromX, fromY, toX, toY);
                }
            }
            
            // Punkte vergeben
            const mergePoints = Math.pow(2, sourceBubble.level) * 10;
            state.score += mergePoints;
            
            // Combo erh√∂hen
            state.combo++;
            if (state.combo > state.bestCombo) {
                state.bestCombo = state.combo;
                updateStats();
                
                // Combo-Achievements pr√ºfen
                if (state.bestCombo >= 5 && !state.achievements.find(a => a.id === 'combo5').unlocked) {
                    unlockAchievement('combo5');
                }
                if (state.bestCombo >= 10 && !state.achievements.find(a => a.id === 'combo10').unlocked) {
                    unlockAchievement('combo10');
                }
            }
            
            // Combo-Indikator anzeigen
            if (state.combo > 1) {
                showComboIndicator(state.combo);
            }
            
            // Neue Blase erstellen
            let newLevel = sourceBubble.level + 1;
            let newSpecial = null;
            
            // Spezielle Blasen-Interaktionen
            if (sourceBubble.special && targetBubble.special && sourceBubble.special !== targetBubble.special) {
                // Patrick + Rott = Level 3 Blase
                newLevel = 3;
                
                // Bonus-Punkte f√ºr spezielle Kombination
                const specialBonus = 100;
                state.score += specialBonus;
                showFloatingText(toX, toY, `+${specialBonus}`, '#FFD700');
            }
            
            // Level-Begrenzung
            if (newLevel > MAX_LEVEL) {
                newLevel = MAX_LEVEL;
                // Bonus f√ºr maximales Level
                const maxLevelBonus = 1000;
                state.score += maxLevelBonus;
                showFloatingText(toX, toY, `MAX! +${maxLevelBonus}`, '#FFD700');
            }
            
            // H√∂chste Blase aktualisieren
            if (newLevel > state.highestBubble) {
                state.highestBubble = newLevel;
                updateStats();
                
                // Level-Achievements pr√ºfen
                if (newLevel >= 5 && !state.achievements.find(a => a.id === 'level5').unlocked) {
                    unlockAchievement('level5');
                }
                if (newLevel >= 8 && !state.achievements.find(a => a.id === 'level8').unlocked) {
                    unlockAchievement('level8');
                }
                if (newLevel >= 10 && !state.achievements.find(a => a.id === 'level10').unlocked) {
                    unlockAchievement('level10');
                }
            }
            
            // Quellblase entfernen und Zielblase aktualisieren
            state.grid[fromY][fromX] = null;
            state.grid[toY][toX] = { level: newLevel, special: newSpecial };
            
            // Auswahl zur√ºcksetzen
            deselectBubble();
            
            // Punkte-Text anzeigen
            showFloatingText(toX, toY, `+${mergePoints}`, '#4CAF50');
            
            // Partikeleffekt hinzuf√ºgen
            createParticleEffect(toX, toY);
            
            // Grid neu rendern
            renderGrid();
            
            // Merging-Animation auf der Zielblase
            const targetElement = document.querySelector(`.bubble[data-x="${toX}"][data-y="${toY}"]`);
            if (targetElement) {
                targetElement.classList.add('merging');
                setTimeout(() => {
                    targetElement.classList.remove('merging');
                }, 500);
            }
            
            // Sound abspielen
            playSound('merge');
            
            // Kettenreaktion pr√ºfen
            setTimeout(() => {
                checkChainReaction(toX, toY);
                
                // Punkte-Achievements pr√ºfen
                if (state.score >= 1000 && !state.achievements.find(a => a.id === 'score1000').unlocked) {
                    unlockAchievement('score1000');
                }
                if (state.score >= 5000 && !state.achievements.find(a => a.id === 'score5000').unlocked) {
                    unlockAchievement('score5000');
                }
                if (state.score >= 10000 && !state.achievements.find(a => a.id === 'score10000').unlocked) {
                    unlockAchievement('score10000');
                }
                
                updateStats();
                checkGameOver();
                saveGame();
            }, CHAIN_REACTION_DELAY);
            
            return true;
        }
        
        // Findet alle verbundenen Blasen mit dem gleichen Level
        function findConnectedBubbles(startX, startY, level) {
            const visited = new Set(); // Speichert bereits besuchte Zellen in Format "x,y"
            const group = []; // Gruppe von verbundenen Blasen
            
            // Rekursive Funktion zur Suche verbundener Blasen
            function explore(x, y) {
                // Formatiere Koordinaten als String f√ºr Set
                const coords = `${x},${y}`;
                
                // Wenn bereits besucht oder au√üerhalb des Grids, abbrechen
                if (visited.has(coords) || x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
                    return;
                }
                
                // Als besucht markieren
                visited.add(coords);
                
                // √úberpr√ºfen, ob eine Blase mit passendem Level vorhanden ist
                const bubble = state.grid[y][x];
                if (!bubble || bubble.special || parseInt(bubble.level) !== level) {
                    return;
                }
                
                // Zu Gruppe hinzuf√ºgen
                group.push({ x, y });
                
                // Angrenzende Zellen pr√ºfen
                explore(x + 1, y);     // Rechts
                explore(x - 1, y);     // Links
                explore(x, y + 1);     // Unten
                explore(x, y - 1);     // Oben
                explore(x + 1, y + 1); // Unten rechts
                explore(x - 1, y + 1); // Unten links
                explore(x + 1, y - 1); // Oben rechts
                explore(x - 1, y - 1); // Oben links
            }
            
            // Start der Exploration
            explore(startX, startY);
            
            return group;
        }
        
        // Verschmelzt eine Gruppe von Blasen zu einer h√∂herwertigen Blase
        function groupMerge(group, fromX, fromY, toX, toY) {
            // Sicherstellen, dass die Startblase auch in der Gruppe ist
            const startIncluded = group.some(item => item.x === fromX && item.y === fromY);
            if (!startIncluded) {
                group.push({ x: fromX, y: fromY });
            }
            
            const level = state.grid[group[0].y][group[0].x].level;
            const bubbleCount = group.length;
            
            // Punkte basierend auf der Anzahl von Blasen berechnen
            const basePoints = Math.pow(2, level) * 10;
            const bonus = (bubbleCount - 2) * basePoints; // Bonus f√ºr zus√§tzliche Blasen
            const totalPoints = basePoints + bonus;
            
            state.score += totalPoints;
            
            // Combo-Bonus erh√∂hen
            state.combo += (bubbleCount - 2); // Zus√§tzliche Combo-Punkte pro Blase
            if (state.combo > state.bestCombo) {
                state.bestCombo = state.combo;
                updateStats();
                
                // Combo-Achievements pr√ºfen
                if (state.bestCombo >= 5 && !state.achievements.find(a => a.id === 'combo5').unlocked) {
                    unlockAchievement('combo5');
                }
                if (state.bestCombo >= 10 && !state.achievements.find(a => a.id === 'combo10').unlocked) {
                    unlockAchievement('combo10');
                }
            }
            
            // Combo-Indikator anzeigen
            if (state.combo > 1) {
                showComboIndicator(state.combo);
            }
            
            // Animiere alle Blasen, die an der Fusion beteiligt sind
            for (const bubble of group) {
                if (bubble.x !== toX || bubble.y !== toY) { // Zielzelle √ºberspringen
                    createParticleEffect(bubble.x, bubble.y);
                    
                    // Anzeigen der Punkte f√ºr jede beteiligte Blase
                    showFloatingText(bubble.x, bubble.y, `+${basePoints}`, '#4CAF50');
                    
                    // Blasen entfernen
                    state.grid[bubble.y][bubble.x] = null;
                }
            }
            
            // Neue Blase mit h√∂herem Level erstellen
            let newLevel = level + 1;
            
            // Level-Begrenzung
            if (newLevel > MAX_LEVEL) {
                newLevel = MAX_LEVEL;
                // Bonus f√ºr maximales Level
                const maxLevelBonus = 1000;
                state.score += maxLevelBonus;
                showFloatingText(toX, toY, `MAX! +${maxLevelBonus}`, '#FFD700');
            }
            
            // H√∂chste Blase aktualisieren
            if (newLevel > state.highestBubble) {
                state.highestBubble = newLevel;
                updateStats();
                
                // Level-Achievements pr√ºfen
                if (newLevel >= 5 && !state.achievements.find(a => a.id === 'level5').unlocked) {
                    unlockAchievement('level5');
                }
                if (newLevel >= 8 && !state.achievements.find(a => a.id === 'level8').unlocked) {
                    unlockAchievement('level8');
                }
                if (newLevel >= 10 && !state.achievements.find(a => a.id === 'level10').unlocked) {
                    unlockAchievement('level10');
                }
            }
            
            // Zielzelle mit der neuen Blase aktualisieren
            state.grid[toY][toX] = { level: newLevel, special: null };
            
            // Punkte-Text anzeigen
            showFloatingText(toX, toY, `Gruppe: +${totalPoints}`, '#FFD700');
            
            // Partikeleffekt f√ºr die Zielzelle
            createParticleEffect(toX, toY, true);
            
            // Grid neu rendern
            renderGrid();
            
            // Besondere Animation f√ºr Gruppenmerge
            const targetElement = document.querySelector(`.bubble[data-x="${toX}"][data-y="${toY}"]`);
            if (targetElement) {
                targetElement.classList.add('merging');
                setTimeout(() => {
                    targetElement.classList.remove('merging');
                }, 500);
            }
            
            // Sound abspielen
            playSound('groupMerge');
            
            // Auswahl zur√ºcksetzen
            deselectBubble();
            
            // Kettenreaktion pr√ºfen nach einer kleinen Verz√∂gerung
            setTimeout(() => {
                checkChainReaction(toX, toY);
                
                // Punkte-Achievements pr√ºfen
                if (state.score >= 1000 && !state.achievements.find(a => a.id === 'score1000').unlocked) {
                    unlockAchievement('score1000');
                }
                if (state.score >= 5000 && !state.achievements.find(a => a.id === 'score5000').unlocked) {
                    unlockAchievement('score5000');
                }
                if (state.score >= 10000 && !state.achievements.find(a => a.id === 'score10000').unlocked) {
                    unlockAchievement('score10000');
                }
                
                updateStats();
                checkGameOver();
                saveGame();
            }, CHAIN_REACTION_DELAY);
            
            return true;
        }

        function createParticleEffect(x, y, isGroupMerge = false) {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (!cell) return;
            
            const cellRect = cell.getBoundingClientRect();
            const centerX = cellRect.width / 2;
            const centerY = cellRect.height / 2;
            
            // Farbe basierend auf Bubble-Level
            const bubble = state.grid[y][x];
            let color;
            
            if (!bubble) {
                color = '#FFD700'; // Gold f√ºr leere Zellen bei Gruppenmerge
            } else if (bubble.level === 1) color = '#FF5252';
            else if (bubble.level === 2) color = '#FF9800';
            else if (bubble.level === 3) color = '#FFEB3B';
            else if (bubble.level === 4) color = '#4CAF50';
            else if (bubble.level === 5) color = '#2196F3';
            else if (bubble.level === 6) color = '#673AB7';
            else if (bubble.level === 7) color = '#E91E63';
            else if (bubble.level === 8) color = '#00BCD4';
            else if (bubble.level === 9) color = '#795548';
            else if (bubble.level === 10) color = '#607D8B';
            else if (bubble.level === 11) color = '#F44336';
            else color = '#009688';
            
            // Bei Gruppenmerge mehr und gr√∂√üere Partikel erzeugen
            const particleCount = isGroupMerge ? 30 : 15;
            const sizeBonus = isGroupMerge ? 2 : 0;
            const speedBonus = isGroupMerge ? 1.5 : 1;
            
            // Mehrere Partikel erstellen
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.backgroundColor = color;
                
                // Zuf√§llige Anfangsposition um den Mittelpunkt
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 5;
                const startX = centerX + Math.cos(angle) * distance;
                const startY = centerY + Math.sin(angle) * distance;
                
                // Zuf√§llige Geschwindigkeit und Richtung
                const speedX = (Math.random() - 0.5) * 3 * speedBonus;
                const speedY = (Math.random() - 0.5) * 3 * speedBonus;
                
                // Zuf√§llige Gr√∂√üe
                const size = (3 + Math.random() * 5) + sizeBonus;
                
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;
                
                cell.appendChild(particle);
                
                // Animation
                let posX = startX;
                let posY = startY;
                let opacity = 1;
                const gravity = 0.1;
                let velocityY = speedY;
                
                const animate = () => {
                    posX += speedX;
                    velocityY += gravity;
                    posY += velocityY;
                    opacity -= 0.02;
                    
                    if (opacity <= 0) {
                        particle.remove();
                        return;
                    }
                    
                    particle.style.opacity = opacity;
                    particle.style.left = `${posX}px`;
                    particle.style.top = `${posY}px`;
                    
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }
        }

        function checkChainReaction(x, y) {
            const bubble = state.grid[y][x];
            if (!bubble) return false;
            
            const directions = [
                { x: 0, y: -1 },  // Oben
                { x: 1, y: -1 },   // Oben rechts
                { x: 1, y: 0 },    // Rechts
                { x: 1, y: 1 },    // Unten rechts
                { x: 0, y: 1 },    // Unten
                { x: -1, y: 1 },   // Unten links
                { x: -1, y: 0 },   // Links
                { x: -1, y: -1 }   // Oben links
            ];
            
            let chainReactionOccurred = false;
            
            for (const dir of directions) {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                // Pr√ºfen, ob Koordinaten im Grid sind
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                    const neighborBubble = state.grid[newY][newX];
                    
                    if (neighborBubble && 
                        ((bubble.level === neighborBubble.level) || 
                         (bubble.special && neighborBubble.special && bubble.special !== neighborBubble.special))) {
                        
                        // Merge durchf√ºhren
                        if (mergeBubbles(newX, newY, x, y)) {
                            chainReactionOccurred = true;
                            
                            // Nur eine Kettenreaktion pro Durchlauf
                            break;
                        }
                    }
                }
            }
            
            if (chainReactionOccurred) {
                // Grid neu rendern
                renderGrid();
                updateStats();
                
                // Pr√ºfen, ob alle Blasen entfernt wurden
                const allCellsEmpty = state.grid.every(row => row.every(cell => cell === null));
                if (allCellsEmpty && !state.achievements.find(a => a.id === 'cleared').unlocked) {
                    unlockAchievement('cleared');
                    showNotification('Wow! Du hast alle Blasen entfernt!', 5000);
                    
                    // Nach komplettem Leeren neue Blasen hinzuf√ºgen
                    setTimeout(() => {
                        for (let i = 0; i < 3; i++) {
                            addRandomBubble();
                        }
                        renderGrid();
                        showNotification('Neue Blasen als Belohnung!');
                    }, CHAIN_REACTION_DELAY * 3);
                } else {
                    // Nach Kettenreaktion Blase-Check durchf√ºhren
                    setTimeout(() => {
                        ensureMinimumBubbles();
                    }, CHAIN_REACTION_DELAY * 2);
                }
                
                return true;
            }
            
            return false;
        }

        function handlePlaceBubble() {
            if (state.gameOver) return;
            
            // Anzahl der freien Felder z√§hlen
            const emptyCellCount = countEmptyCells();
            
            if (emptyCellCount === 0) {
                showNotification('Kein Platz f√ºr neue Blasen! Verschmelze erst einige Blasen.');
                return;
            }
            
            // Mehrere Blasen gleichzeitig platzieren, wenn viel Platz ist
            if (emptyCellCount >= 8) {
                // F√ºge 3 Blasen direkt hinzu, wenn viel Platz ist
                for (let i = 0; i < 3 && countEmptyCells() > 0; i++) {
                    addRandomBubble();
                }
                renderGrid();
                showNotification('3 neue Blasen hinzugef√ºgt!');
                return;
            } else if (emptyCellCount >= 5) {
                // F√ºge 2 Blasen direkt hinzu, wenn mittelm√§√üig Platz ist
                for (let i = 0; i < 2 && countEmptyCells() > 0; i++) {
                    addRandomBubble();
                }
                renderGrid();
                showNotification('2 neue Blasen hinzugef√ºgt!');
                return;
            }
            
            // Hervorheben der freien Felder f√ºr die manuelle Platzierung
            const emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] === null) {
                        emptyCells.push({ x, y });
                        const cellElement = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                        if (cellElement) {
                            cellElement.classList.add('highlight');
                        }
                    }
                }
            }
            
            // Deselektieren, falls eine Blase ausgew√§hlt ist
            deselectBubble();
            
            showNotification('W√§hle ein freies Feld f√ºr die neue Blase.');
            
            // Erlaube dem Spieler, ein Feld zu w√§hlen
            state.placingMode = true;
            
            // Nach 3 Sekunden Hervorhebung aufheben, falls keine Auswahl erfolgt
            setTimeout(() => {
                if (state.placingMode) {
                    state.placingMode = false;
                    const highlightedCells = document.querySelectorAll('.cell.highlight');
                    highlightedCells.forEach(cell => cell.classList.remove('highlight'));
                }
            }, 3000);
        }
        
        function countEmptyCells() {
            let count = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] === null) {
                        count++;
                    }
                }
            }
            return count;
        }

        function placeNextBubble(x, y) {
            if (state.grid[y][x] === null) {
                // N√§chste Blase platzieren
                const nextBubbleLevel = state.nextBubbles.shift();
                state.grid[y][x] = { level: nextBubbleLevel, special: null };
                
                // Neue Blase f√ºr n√§chste Runde generieren
                const maxLevel = Math.min(Math.max(3, state.highestBubble - 2), state.highestBubble);
                state.nextBubbles.push(getRandomBubbleLevel(1, maxLevel));
                
                // Combo zur√ºcksetzen
                state.combo = 0;
                
                // UI aktualisieren
                updateNextBubbles();
                renderGrid();
                
                // Sound abspielen
                playSound('place');
                
                // Kettenreaktion pr√ºfen
                setTimeout(() => {
                    if (!checkChainReaction(x, y)) {
                        // Nach jedem Zug eine neue Blase hinzuf√ºgen (100% Chance)
                        addRandomBubble();
                        renderGrid();
                        
                        // Mindestanzahl von Blasen sicherstellen
                        ensureMinimumBubbles();
                        
                        // Feld-Check
                        checkFilledGrid();
                    }
                    
                    // Game Over pr√ºfen
                    checkGameOver();
                    
                    // Speichern
                    saveGame();
                }, CHAIN_REACTION_DELAY);
                
                return true;
            }
            
            return false;
        }

        function checkFilledGrid() {
            // Pr√ºfen, ob das Grid vollst√§ndig gef√ºllt ist
            const allCellsFilled = state.grid.every(row => row.every(cell => cell !== null));
            
            if (allCellsFilled && !state.achievements.find(a => a.id === 'filled').unlocked) {
                unlockAchievement('filled');
            }
        }

        function checkGameOver() {
            if (state.gameOver) return true;
            
            // Pr√ºfen, ob es leere Zellen gibt
            const emptyCells = countEmptyCells();
            const hasEmptyCell = emptyCells > 0;
            
            // Wenn noch leere Zellen da sind, ist es kein Game Over
            if (hasEmptyCell) {
                return false;
            }
            
            // Pr√ºfen, ob noch Z√ºge m√∂glich sind
            let movesAvailable = false;
            
            // Alle Zellen durchgehen
            for (let y = 0; y < GRID_SIZE && !movesAvailable; y++) {
                for (let x = 0; x < GRID_SIZE && !movesAvailable; x++) {
                    const bubble = state.grid[y][x];
                    if (!bubble) continue;
                    
                    // Nachbarn pr√ºfen
                    const directions = [
                        { x: 0, y: -1 },  // Oben
                        { x: 1, y: -1 },  // Oben rechts
                        { x: 1, y: 0 },   // Rechts
                        { x: 1, y: 1 },   // Unten rechts
                        { x: 0, y: 1 },   // Unten
                        { x: -1, y: 1 },  // Unten links
                        { x: -1, y: 0 },  // Links
                        { x: -1, y: -1 }  // Oben links
                    ];
                    
                    for (const dir of directions) {
                        const newX = x + dir.x;
                        const newY = y + dir.y;
                        
                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            const neighborBubble = state.grid[newY][newX];
                            
                            if (neighborBubble && canMerge(x, y, newX, newY)) {
                                movesAvailable = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!movesAvailable) {
                // Vor dem Game Over eine hilfreiche Nachricht anzeigen
                showNotification("Keine Z√ºge mehr m√∂glich! Du kannst noch neu mischen...", 3000);
                
                // Kurze Verz√∂gerung vor dem Game Over
                setTimeout(() => {
                    if (state.score >= SHUFFLE_COST) {
                        // Automatisch neu mischen, wenn genug Punkte vorhanden sind
                        shuffleBoard();
                        showNotification("Blasen wurden automatisch neu gemischt!", 3000);
                    } else {
                        state.gameOver = true;
                        gameOverElement.classList.add('active');
                        finalScoreElement.textContent = `Punkte: ${state.score}`;
                        playSound('gameover');
                    }
                }, 3000);
                
                return true;
            }
            
            return false;
        }

        // Tippsystem
        function showHint() {
            if (state.gameOver || state.hintActive) return;
            
            if (state.score < HINT_COST) {
                showNotification(`Du ben√∂tigst ${HINT_COST} Punkte f√ºr einen Tipp!`);
                return;
            }
            
            // Deselektieren, falls eine Blase ausgew√§hlt ist
            deselectBubble();
            
            // Suche nach m√∂glichen Kombinationen
            let foundMerge = false;
            
            // Alle Zellen durchgehen
            for (let y1 = 0; y1 < GRID_SIZE && !foundMerge; y1++) {
                for (let x1 = 0; x1 < GRID_SIZE && !foundMerge; x1++) {
                    const bubble1 = state.grid[y1][x1];
                    if (!bubble1) continue;
                    
                    // Nachbarn pr√ºfen
                    const directions = [
                        { x: 0, y: -1 },  // Oben
                        { x: 1, y: -1 },  // Oben rechts
                        { x: 1, y: 0 },   // Rechts
                        { x: 1, y: 1 },   // Unten rechts
                        { x: 0, y: 1 },   // Unten
                        { x: -1, y: 1 },  // Unten links
                        { x: -1, y: 0 },  // Links
                        { x: -1, y: -1 }  // Oben links
                    ];
                    
                    for (const dir of directions) {
                        const x2 = x1 + dir.x;
                        const y2 = y1 + dir.y;
                        
                        if (x2 >= 0 && x2 < GRID_SIZE && y2 >= 0 && y2 < GRID_SIZE) {
                            const bubble2 = state.grid[y2][x2];
                            
                            if (bubble2 && canMerge(x1, y1, x2, y2)) {
                                // Hinweis f√ºr diese Kombination anzeigen
                                addHintMarker(x1, y1);
                                addHintMarker(x2, y2);
                                foundMerge = true;
                                
                                // Punkte abziehen
                                state.score -= HINT_COST;
                                updateStats();
                                showNotification(`Tipp angezeigt! (-${HINT_COST} Punkte)`);
                                
                                // Tipp-Status setzen
                                state.hintActive = true;
                                
                                // Nach 3 Sekunden Hinweis wieder entfernen
                                setTimeout(removeHint, 3000);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Falls keine Kombination gefunden wurde, suche nach leeren Nachbarzellen
            if (!foundMerge) {
                for (let y = 0; y < GRID_SIZE && !foundMerge; y++) {
                    for (let x = 0; x < GRID_SIZE && !foundMerge; x++) {
                        const bubble = state.grid[y][x];
                        if (!bubble) continue;
                        
                        // Nachbarn pr√ºfen
                        const directions = [
                            { x: 0, y: -1 },  // Oben
                            { x: 1, y: -1 },  // Oben rechts
                            { x: 1, y: 0 },   // Rechts
                            { x: 1, y: 1 },   // Unten rechts
                            { x: 0, y: 1 },   // Unten
                            { x: -1, y: 1 },  // Unten links
                            { x: -1, y: 0 },  // Links
                            { x: -1, y: -1 }  // Oben links
                        ];
                        
                        for (const dir of directions) {
                            const newX = x + dir.x;
                            const newY = y + dir.y;
                            
                            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && state.grid[newY][newX] === null) {
                                // Hinweis f√ºr diese Bewegung anzeigen
                                addHintMarker(x, y);
                                addHintMarker(newX, newY);
                                foundMerge = true;
                                
                                // Punkte abziehen
                                state.score -= HINT_COST;
                                updateStats();
                                showNotification(`Tipp angezeigt! (-${HINT_COST} Punkte)`);
                                
                                // Tipp-Status setzen
                                state.hintActive = true;
                                
                                // Nach 3 Sekunden Hinweis wieder entfernen
                                setTimeout(removeHint, 3000);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!foundMerge) {
                showNotification("Keine m√∂glichen Z√ºge gefunden! Versuche, neue Blasen zu platzieren oder das Spielfeld zu mischen.");
            }
            
            saveGame();
        }

        function addHintMarker(x, y) {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (!cell) return;
            
            const hintElement = document.createElement('div');
            hintElement.classList.add('hint-bubble');
            hintElement.dataset.hint = 'true';
            
            cell.appendChild(hintElement);
        }

        function removeHint() {
            const hints = document.querySelectorAll('.hint-bubble');
            hints.forEach(hint => hint.remove());
            state.hintActive = false;
        }

        // UI-Funktionen
        function renderGrid() {
            // Alle vorhandenen Blasen entfernen
            const bubbles = document.querySelectorAll('.bubble');
            bubbles.forEach(bubble => bubble.remove());
            
            // Neue Blasen erstellen
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const bubble = state.grid[y][x];
                    
                    if (bubble) {
                        const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                        
                        const bubbleElement = document.createElement('div');
                        bubbleElement.classList.add('bubble', `level-${bubble.level}`);
                        bubbleElement.dataset.x = x;
                        bubbleElement.dataset.y = y;
                        bubbleElement.dataset.level = bubble.level;
                        bubbleElement.textContent = bubble.level;
                        
                        if (bubble.special) {
                            bubbleElement.classList.add(bubble.special);
                            bubbleElement.textContent = bubble.special === 'patrick' ? 'P' : 'R';
                        }
                        
                        cell.appendChild(bubbleElement);
                    }
                }
            }
        }

        function updateStats() {
            scoreElement.textContent = state.score;
            highestBubbleElement.textContent = state.highestBubble;
            bestComboElement.textContent = state.bestCombo;
        }

        function updateNextBubbles() {
            for (let i = 0; i < 3; i++) {
                const bubbleLevel = state.nextBubbles[i];
                nextBubbleElements[i].className = `next-bubble level-${bubbleLevel}`;
                nextBubbleElements[i].textContent = bubbleLevel;
            }
        }

        function showFloatingText(x, y, text, color) {
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (!cell) return;
            
            const floatingText = document.createElement('div');
            floatingText.style.position = 'absolute';
            floatingText.style.left = '50%';
            floatingText.style.top = '50%';
            floatingText.style.transform = 'translate(-50%, -50%)';
            floatingText.style.color = color || 'white';
            floatingText.style.fontSize = '20px';
            floatingText.style.fontWeight = 'bold';
            floatingText.style.pointerEvents = 'none';
            floatingText.style.zIndex = '50';
            floatingText.style.textShadow = '0 0 3px rgba(0, 0, 0, 0.5)';
            floatingText.textContent = text;
            
            cell.appendChild(floatingText);
            
            // Animation
            let opacity = 1;
            let posY = 0;
            
            const animate = () => {
                opacity -= 0.05;
                posY -= 2;
                
                floatingText.style.opacity = opacity;
                floatingText.style.transform = `translate(-50%, calc(-50% + ${posY}px))`;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    floatingText.remove();
                }
            };
            
            requestAnimationFrame(animate);
        }

        function showComboIndicator(combo) {
            comboIndicatorElement.textContent = `${combo}x Combo!`;
            comboIndicatorElement.classList.add('active');
            
            // Nach 1.5 Sekunden ausblenden
            setTimeout(() => {
                comboIndicatorElement.classList.remove('active');
            }, 1500);
        }

        function showNotification(message, duration = 3000) {
            notificationElement.textContent = message;
            notificationElement.classList.add('active');
            
            setTimeout(() => {
                notificationElement.classList.remove('active');
            }, duration);
        }

        function renderAchievements() {
            achievementsList.innerHTML = '';
            
            state.achievements.forEach(achievement => {
                const achievementElement = document.createElement('div');
                achievementElement.classList.add('achievement');
                
                if (achievement.unlocked) {
                    achievementElement.classList.add('unlocked');
                }
                
                const titleElement = document.createElement('div');
                titleElement.classList.add('achievement-title');
                titleElement.textContent = achievement.unlocked 
                    ? `üèÜ ${achievement.title}` 
                    : `üîí ${achievement.title}`;
                
                const descriptionElement = document.createElement('div');
                descriptionElement.classList.add('achievement-description');
                descriptionElement.textContent = `${achievement.description} (${achievement.reward} Punkte)`;
                
                achievementElement.appendChild(titleElement);
                achievementElement.appendChild(descriptionElement);
                achievementsList.appendChild(achievementElement);
            });
        }

        function unlockAchievement(id) {
            const achievement = state.achievements.find(a => a.id === id);
            
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                state.score += achievement.reward;
                updateStats();
                
                showNotification(`Errungenschaft freigeschaltet: ${achievement.title} (+${achievement.reward} Punkte)`, 5000);
                playSound('achievement');
                
                saveGame();
            }
        }

        function applyTheme() {
            if (state.darkMode) {
                document.body.classList.add('dark-mode');
                themeToggleButton.querySelector('.btn-icon').textContent = 'üåô';
            } else {
                document.body.classList.remove('dark-mode');
                themeToggleButton.querySelector('.btn-icon').textContent = '‚òÄÔ∏è';
            }
        }

        function updateMuteButton() {
            muteToggleButton.querySelector('.btn-icon').textContent = state.muted ? 'üîá' : 'üîä';
        }

        function toggleTheme() {
            state.darkMode = !state.darkMode;
            applyTheme();
            saveGame();
        }

        function toggleMute() {
            state.muted = !state.muted;
            updateMuteButton();
            saveGame();
        }

        function playSound(type) {
            if (state.muted) return;
            
            // Einfache Sound-Implementierung mit AudioContext
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Verschiedene Sounds f√ºr verschiedene Aktionen
                switch (type) {
                    case 'select':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                        
                    case 'move':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'merge':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'groupMerge':
                        // Spektakul√§rerer Sound f√ºr Gruppenmerge
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                        oscillator.frequency.exponentialRampToValueAtTime(1320, audioContext.currentTime + 0.2);
                        oscillator.frequency.exponentialRampToValueAtTime(1760, audioContext.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                        
                    case 'place':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'achievement':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(554, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                        
                    case 'gameover':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 1);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 1);
                        break;
                }
            } catch (error) {
                console.log('Sound konnte nicht abgespielt werden:', error);
            }
        }

        // Touch-Events f√ºr bessere mobile Unterst√ºtzung
        document.addEventListener('touchstart', function(e) {
            if (e.touches.length > 1) {
                e.preventDefault(); // Verhindern von Zoom-Gesten
            }
        }, { passive: false });

        // Spiel starten
        initGame();
        
        // Nach dem Laden Spielanleitung anzeigen, wenn n√∂tig
        if (!state.tutorialSeen) {
            setTimeout(() => {
                helpModal.classList.add('active');
                state.tutorialSeen = true;
                saveGame();
            }, 1000);
        }
    </script>
</body>
</html>
