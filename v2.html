<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Merge</title>
    <style>
        :root {
            --bg-color: #f0f9ff;
            --text-color: #1e293b;
            --grid-color: #e2e8f0;
            --grid-border: #94a3b8;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --bubble-colors: #f87171, #facc15, #4ade80, #60a5fa, #a78bfa, #f472b6, #fb923c, #22d3ee;
            --accent-color: #3b82f6;
            --chain-highlight: #fef08a;
        }

        [data-theme="dark"] {
            --bg-color: #0f172a;
            --text-color: #f1f5f9;
            --grid-color: #1e293b;
            --grid-border: #475569;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --accent-color: #60a5fa;
            --chain-highlight: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 16px;
            transition: background-color 0.3s, color 0.3s;
        }

        header {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
        }

        .level {
            font-size: 16px;
        }

        .controls {
            display: flex;
            gap: 12px;
        }

        button {
            background-color: var(--grid-color);
            color: var(--text-color);
            border: 1px solid var(--grid-border);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            opacity: 0.9;
        }

        button:active {
            transform: scale(0.97);
        }

        .icon {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }

        .game-container {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px var(--shadow-color);
        }

        .game-stats {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            margin-bottom: 16px;
        }

        .next-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            box-shadow: 0 4px 10px var(--shadow-color);
            flex: 1;
            margin-right: 10px;
        }

        .goal-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            background-color: var(--grid-color);
            border: 2px solid var(--grid-border);
            border-radius: 8px;
            box-shadow: 0 4px 10px var(--shadow-color);
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .goal-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background-color: var(--accent-color);
            transition: width 0.5s ease-out;
        }

        .next-label, .goal-label {
            font-weight: bold;
            margin-right: 12px;
        }

        #next-bubble, #goal-bubble {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.2), inset 0 4px 8px rgba(255, 255, 255, 0.2), 0 4px 8px rgba(0, 0, 0, 0.15);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            background-size: cover;
            background-position: center;
            z-index: 1;
            will-change: transform;
        }

        .bubble-inner {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0) 70%);
            font-size: 1.2em;
        }

        .bubble.dragging {
            opacity: 0.8;
            z-index: 100;
            cursor: grabbing;
            transform: scale(1.1);
            box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.2), inset 0 4px 8px rgba(255, 255, 255, 0.2), 0 10px 20px rgba(0, 0, 0, 0.25);
        }

        .bubble.merging {
            z-index: 50;
            animation: merge 0.5s forwards;
        }

        .bubble.chain-merge {
            animation: chain-merge 0.6s forwards;
        }

        @keyframes merge {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
                filter: brightness(1.5);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes chain-merge {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.4);
                filter: brightness(1.8);
                box-shadow: 0 0 30px var(--chain-highlight);
            }
            70% {
                transform: scale(1.2);
                filter: brightness(1.5);
                box-shadow: 0 0 20px var(--chain-highlight);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0px var(--chain-highlight);
            }
        }

        .new-bubble {
            animation: pop 0.3s forwards;
        }

        @keyframes pop {
            0% {
                transform: scale(0);
            }
            70% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        .score-popup {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 18px;
            animation: float-up 1.2s forwards;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        }

        .chain-bonus {
            color: var(--chain-highlight);
            font-size: 22px;
            animation: float-up-bonus 1.5s forwards;
        }

        @keyframes float-up {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.2);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1);
            }
        }

        @keyframes float-up-bonus {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.5);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-150px) scale(1.2);
            }
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            pointer-events: none;
            z-index: 0;
        }

        .grid-cell {
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background-color: var(--bg-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 90%;
            width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal h2 {
            margin-bottom: 16px;
            font-size: 28px;
        }

        .modal p {
            margin-bottom: 24px;
            text-align: center;
            line-height: 1.6;
        }

        .button-group {
            display: flex;
            gap: 12px;
        }

        .primary-button {
            background-color: var(--accent-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
        }

        .secondary-button {
            background-color: var(--grid-color);
            padding: 10px 20px;
            border-radius: 8px;
        }

        .achievement-badge {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background-color: var(--grid-color);
            border-radius: 8px;
            width: 100%;
        }

        .achievement-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 16px;
            flex-shrink: 0;
        }

        .achievement-info {
            flex-grow: 1;
        }

        .achievement-title {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .achievement-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        .stats-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
        }

        .stats-table td {
            padding: 8px;
            text-align: left;
        }

        .stats-table td:last-child {
            text-align: right;
            font-weight: bold;
        }

        .challenge-container {
            border-top: 1px solid var(--grid-border);
            padding-top: 20px;
            width: 100%;
            margin-top: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .challenge-progress {
            width: 100%;
            height: 10px;
            background-color: var(--grid-color);
            border-radius: 5px;
            margin: 12px 0;
            overflow: hidden;
        }

        .challenge-progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.5s;
        }

        .challenge-reward {
            display: inline-block;
            background-color: var(--chain-highlight);
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 8px;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        #tutorials-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 900;
            pointer-events: none;
        }

        .tutorial {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 16px;
            border-radius: 8px;
            max-width: 80%;
            font-size: 16px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            pointer-events: all;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-5px); }
        }

        .tutorial:after {
            content: '';
            position: absolute;
            border: 10px solid transparent;
        }

        .tutorial.bottom:after {
            border-top-color: rgba(59, 130, 246, 0.9);
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tutorial.top:after {
            border-bottom-color: rgba(59, 130, 246, 0.9);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tutorial button {
            background-color: white;
            color: #3b82f6;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            margin-top: 10px;
            font-weight: bold;
        }

        .game-info {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-color);
            opacity: 0.8;
        }

        .chain-counter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: var(--chain-highlight);
            color: black;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            animation: pulse 0.6s infinite alternate;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        @media (max-width: 600px) {
            header {
                padding: 0 8px;
            }
            
            .score {
                font-size: 20px;
            }
            
            .level {
                font-size: 14px;
            }
            
            button {
                padding: 6px 10px;
                font-size: 14px;
            }
            
            .icon {
                width: 16px;
                height: 16px;
            }
            
            #next-bubble, #goal-bubble {
                width: 50px;
                height: 50px;
            }
            
            .modal-content {
                padding: 24px;
            }
            
            .modal h2 {
                font-size: 24px;
            }
            
            .game-info {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }

            .game-stats {
                flex-direction: column;
                gap: 10px;
            }

            .next-container, .goal-container {
                margin-right: 0;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="score-container">
            <div class="score">0</div>
            <div class="level">Level 1</div>
        </div>
        <div class="controls">
            <button id="stats-button" aria-label="Statistiken">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M3 3v18h18"></path>
                    <path d="M8 13v4"></path>
                    <path d="M12 9v8"></path>
                    <path d="M16 6v11"></path>
                </svg>
            </button>
            <button id="theme-toggle" aria-label="Farbmodus umschalten">
                <svg class="icon moon-icon" viewBox="0 0 24 24">
                    <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                </svg>
                <svg class="icon sun-icon" style="display: none;" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="4"></circle>
                    <path d="M12 2v2"></path>
                    <path d="M12 20v2"></path>
                    <path d="m4.93 4.93 1.41 1.41"></path>
                    <path d="m17.66 17.66 1.41 1.41"></path>
                    <path d="M2 12h2"></path>
                    <path d="M20 12h2"></path>
                    <path d="m6.34 17.66-1.41 1.41"></path>
                    <path d="m19.07 4.93-1.41 1.41"></path>
                </svg>
            </button>
            <button id="restart-button" aria-label="Neustarten">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                    <path d="M3 3v5h5"></path>
                </svg>
            </button>
        </div>
    </header>
    
    <div class="game-container" id="game-container">
        <div class="grid-overlay" id="grid-overlay"></div>
        <div class="chain-counter" id="chain-counter">x1</div>
    </div>
    
    <div class="game-stats">
        <div class="next-container">
            <div class="next-label">Nächste:</div>
            <div id="next-bubble"></div>
        </div>
        <div class="goal-container">
            <div class="goal-label">Ziel:</div>
            <div id="goal-bubble"></div>
            <div class="goal-progress" id="goal-progress"></div>
        </div>
    </div>
    
    <div class="game-info">
        <div>Kombiniere gleiche Blasen für Punkte und Kettenreaktionen</div>
        <div>Speichere und teile deinen Highscore</div>
    </div>
    
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2>Spiel vorbei!</h2>
            <p>Dein Punktestand: <span id="final-score">0</span></p>
            <p>Höchste Blase: <span id="highest-bubble">2</span> (<span id="highest-value">4</span>)</p>
            
            <table class="stats-table">
                <tr>
                    <td>Längste Kette:</td>
                    <td id="longest-chain">0</td>
                </tr>
                <tr>
                    <td>Gespielte Zeit:</td>
                    <td id="played-time">0:00</td>
                </tr>
                <tr>
                    <td>Gesamte Züge:</td>
                    <td id="total-moves">0</td>
                </tr>
            </table>
            
            <div class="button-group">
                <button class="primary-button" id="play-again-button">Noch einmal spielen</button>
                <button class="secondary-button" id="share-button">Teilen</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="stats-modal">
        <div class="modal-content">
            <h2>Statistiken & Erfolge</h2>
            
            <table class="stats-table">
                <tr>
                    <td>Highscore:</td>
                    <td id="stats-highscore">0</td>
                </tr>
                <tr>
                    <td>Höchste Blase:</td>
                    <td id="stats-highest-bubble">2 (4)</td>
                </tr>
                <tr>
                    <td>Längste Kette:</td>
                    <td id="stats-longest-chain">0</td>
                </tr>
                <tr>
                    <td>Gespielte Spiele:</td>
                    <td id="stats-games-played">0</td>
                </tr>
            </table>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px;">Erfolge</h3>
            <div id="achievements-container">
                <!-- Achievements will be inserted here -->
            </div>
            
            <div class="challenge-container">
                <h3>Aktuelle Herausforderung</h3>
                <p id="challenge-description">Erzeuge eine Kette mit mindestens 3 Verschmelzungen</p>
                <div class="challenge-progress">
                    <div class="challenge-progress-bar" id="challenge-progress-bar" style="width: 0%;"></div>
                </div>
                <p>Belohnung: <span class="challenge-reward" id="challenge-reward">+500 Punkte</span></p>
            </div>
            
            <div class="button-group" style="margin-top: 20px;">
                <button class="primary-button" id="close-stats-button">Schließen</button>
                <button class="secondary-button" id="reset-stats-button">Zurücksetzen</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="tutorial-modal">
        <div class="modal-content">
            <h2>Bubble Merge</h2>
            <p>1. Ziehe Blasen, um sie zu bewegen<br>
               2. Verbinde gleiche Blasen, um sie zu verschmelzen<br>
               3. Erzeuge Kettenreaktionen für Bonuspunkte<br>
               4. Erreiche das Ziel für die nächste Stufe<br>
               5. Das Spiel endet, wenn das Feld voll ist</p>
            <div class="button-group">
                <button class="primary-button" id="start-game-button">Spielen</button>
            </div>
        </div>
    </div>
    
    <div id="tutorials-container"></div>

    <script>
        // Haupt-Game-State
        const gameState = {
            score: 0,
            level: 1,
            grid: [],
            gridSize: 6,         // Größeres Spielfeld wie gewünscht
            bubbles: [],
            nextBubble: null,
            maxLevel: 1,
            maxValue: 2,         // Actual value (2^level)
            draggedBubble: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            gameOver: false,
            newGameStarted: false,
            tutorialStep: 0,
            moveMade: false,     // Flag für den ersten Zug
            startTime: null,     // Startzeit des Spiels
            playTime: 0,         // Spielzeit in Sekunden
            moves: 0,            // Anzahl der Züge
            chainCount: 0,       // Anzahl der Verschmelzungen in aktueller Kette
            longestChain: 0,     // Längste Kette im Spiel
            currentGoal: 4,      // Aktuelles Ziel (2^3 = 8)
            goalProgress: 0,     // Fortschritt zum aktuellen Ziel (0-100%)
            // Stats für persistente Speicherung
            stats: {
                highscore: 0,
                highestLevel: 1,
                highestValue: 2,
                longestChain: 0,
                gamesPlayed: 0,
                achievements: [],
                currentChallenge: 0,
                challengeProgress: 0
            },
            // Aktuelle Challenge
            challenge: null
        };

        // Achievements und Challenges definieren
        const ACHIEVEMENTS = [
            { id: 'first_merge', icon: '🔄', title: 'Erste Verschmelzung', description: 'Verschmelze zwei Blasen' },
            { id: 'level_16', icon: '🔼', title: 'Erreiche 16', description: 'Erzeuge eine 16er-Blase' },
            { id: 'level_64', icon: '⭐', title: 'Fortschritt', description: 'Erzeuge eine 64er-Blase' },
            { id: 'level_256', icon: '🌟', title: 'Meister', description: 'Erzeuge eine 256er-Blase' },
            { id: 'level_1024', icon: '👑', title: 'Legende', description: 'Erzeuge eine 1024er-Blase' },
            { id: 'chain_3', icon: '⛓️', title: 'Kettenschmied', description: 'Erzeuge eine Kette mit 3 Verschmelzungen' },
            { id: 'chain_5', icon: '🔗', title: 'Kettenmeister', description: 'Erzeuge eine Kette mit 5 Verschmelzungen' },
            { id: 'score_1000', icon: '💯', title: 'Punktejäger', description: 'Erreiche 1.000 Punkte' },
            { id: 'score_5000', icon: '🏆', title: 'Punktekönig', description: 'Erreiche 5.000 Punkte' },
            { id: 'games_10', icon: '🎮', title: 'Regelmäßiger Spieler', description: 'Spiele 10 Partien' }
        ];

        const CHALLENGES = [
            { description: 'Erzeuge eine Kette mit mindestens 3 Verschmelzungen', target: 3, type: 'chain', reward: 500 },
            { description: 'Erreiche eine 32er-Blase', target: 32, type: 'value', reward: 750 },
            { description: 'Sammle 1.500 Punkte in einem Spiel', target: 1500, type: 'score', reward: 1000 },
            { description: 'Erzeuge eine Kette mit mindestens 4 Verschmelzungen', target: 4, type: 'chain', reward: 1500 },
            { description: 'Erreiche eine 64er-Blase', target: 64, type: 'value', reward: 2000 },
            { description: 'Sammle 3.000 Punkte in einem Spiel', target: 3000, type: 'score', reward: 2500 },
            { description: 'Erzeuge eine Kette mit mindestens 5 Verschmelzungen', target: 5, type: 'chain', reward: 3500 },
            { description: 'Erreiche eine 128er-Blase', target: 128, type: 'value', reward: 5000 }
        ];

        // Übersetzungs-Funktion
        function translate(text) {
            // Vereinfachte Version der Übersetzungsfunktion
            return text.de;
        }

        // DOM-Elemente - Hier 'let' statt 'const' für Elemente, die später aktualisiert werden
        const gameContainer = document.getElementById('game-container');
        let gridOverlay = document.getElementById('grid-overlay');
        const nextBubbleContainer = document.getElementById('next-bubble');
        const goalBubbleContainer = document.getElementById('goal-bubble');
        const goalProgress = document.getElementById('goal-progress');
        const chainCounter = document.getElementById('chain-counter');
        const scoreElement = document.querySelector('.score');
        const levelElement = document.querySelector('.level');
        const themeToggle = document.getElementById('theme-toggle');
        const moonIcon = document.querySelector('.moon-icon');
        const sunIcon = document.querySelector('.sun-icon');
        const restartButton = document.getElementById('restart-button');
        const statsButton = document.getElementById('stats-button');
        const gameOverModal = document.getElementById('game-over-modal');
        const statsModal = document.getElementById('stats-modal');
        const finalScoreElement = document.getElementById('final-score');
        const highestBubbleElement = document.getElementById('highest-bubble');
        const highestValueElement = document.getElementById('highest-value');
        const longestChainElement = document.getElementById('longest-chain');
        const playedTimeElement = document.getElementById('played-time');
        const totalMovesElement = document.getElementById('total-moves');
        const playAgainButton = document.getElementById('play-again-button');
        const shareButton = document.getElementById('share-button');
        const tutorialModal = document.getElementById('tutorial-modal');
        const startGameButton = document.getElementById('start-game-button');
        const tutorialsContainer = document.getElementById('tutorials-container');
        const statsHighscoreElement = document.getElementById('stats-highscore');
        const statsHighestBubbleElement = document.getElementById('stats-highest-bubble');
        const statsLongestChainElement = document.getElementById('stats-longest-chain');
        const statsGamesPlayedElement = document.getElementById('stats-games-played');
        const achievementsContainer = document.getElementById('achievements-container');
        const challengeDescription = document.getElementById('challenge-description');
        const challengeProgressBar = document.getElementById('challenge-progress-bar');
        const challengeReward = document.getElementById('challenge-reward');
        const closeStatsButton = document.getElementById('close-stats-button');
        const resetStatsButton = document.getElementById('reset-stats-button');

        // Konstanten
        const BUBBLE_COLORS = [
            '#f87171', // rot
            '#facc15', // gelb
            '#4ade80', // grün
            '#60a5fa', // blau
            '#a78bfa', // lila
            '#f472b6', // pink
            '#fb923c', // orange
            '#22d3ee'  // türkis
        ];

        // Formatierungsfunktion für große Zahlen
        function formatNumber(num) {
            if (num < 1000) return num;
            if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
            if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
            return (num / 1000000000).toFixed(1) + 'G';
        }

        // Zeit-Formatierung
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Hilfsfunktionen
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function calculateBubbleSize() {
            const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);
            return (containerSize / gameState.gridSize) * 0.85;
        }

        function getBubblePosition(row, col) {
            const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);
            const cellSize = containerSize / gameState.gridSize;
            const bubbleSize = calculateBubbleSize();
            const offsetX = (cellSize - bubbleSize) / 2;
            const offsetY = (cellSize - bubbleSize) / 2;
            
            return {
                x: col * cellSize + offsetX,
                y: row * cellSize + offsetY
            };
        }

        function getGridCellFromPosition(x, y) {
            const containerSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight);
            const cellSize = containerSize / gameState.gridSize;
            
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            // Bounds check
            if (row >= 0 && row < gameState.gridSize && col >= 0 && col < gameState.gridSize) {
                return { row, col };
            }
            
            return null;
        }

        function createBubbleElement(level, row, col, isNext = false) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble new-bubble';
            
            const size = isNext ? 60 : calculateBubbleSize();
            bubble.style.width = `${size}px`;
            bubble.style.height = `${size}px`;
            
            // Verbesserte Farbgebung mit Helligkeitsanpassung
            const colorIndex = (level - 1) % BUBBLE_COLORS.length;
            const baseColor = BUBBLE_COLORS[colorIndex];
            
            // Glasartiger Effekt basierend auf Level
            bubble.style.backgroundColor = baseColor;
            
            const inner = document.createElement('div');
            inner.className = 'bubble-inner';
            
            // Wert berechnen (2^level)
            const value = Math.pow(2, level);
            inner.textContent = formatNumber(value);
            
            bubble.appendChild(inner);
            
            if (!isNext) {
                const pos = getBubblePosition(row, col);
                bubble.style.left = `${pos.x}px`;
                bubble.style.top = `${pos.y}px`;
                
                // Datenspeicherung für einfachen Zugriff
                bubble.dataset.row = row;
                bubble.dataset.col = col;
                bubble.dataset.level = level;
                bubble.dataset.value = value;
                
                // Event-Listener für Desktop
                bubble.addEventListener('mousedown', startDragging);
                
                // Event-Listener für Touch-Geräte
                bubble.addEventListener('touchstart', handleTouchStart, { passive: false });
            } else {
                bubble.style.position = 'relative';
                bubble.style.left = '0';
                bubble.style.top = '0';
            }
            
            return bubble;
        }

        function createRandomBubble() {
            // Wahrscheinlichkeiten basierend auf dem aktuellen Spielfortschritt
            // Mit fortschreitendem Spiel leicht höhere Chancen auf wertvollere Blasen
            const maxPossibleLevel = Math.min(gameState.maxLevel, 4);
            const progressFactor = Math.min(gameState.score / 3000, 1); // Progression bis 3000 Punkte
            
            let level;
            const rand = Math.random();
            
            if (rand < 0.7 - (0.2 * progressFactor)) {
                // Basis-Chance für Level 1 (sinkt von 70% auf 50% bei hoher Punktzahl)
                level = 1;
            } else if (rand < 0.9 - (0.1 * progressFactor)) {
                // Chance für Level 2 (bleibt etwa bei 20%)
                level = Math.min(2, maxPossibleLevel);
            } else if (rand < 0.98) {
                // Chance für Level 3 (steigt leicht an)
                level = Math.min(3, maxPossibleLevel);
            } else {
                // Kleine Chance für höhere Level (bis zum bisher erreichten)
                level = getRandomInt(1, maxPossibleLevel);
            }
            
            return level;
        }

        function addNewBubble() {
            // Finde eine leere Zelle
            const emptyCells = [];
            for (let row = 0; row < gameState.gridSize; row++) {
                for (let col = 0; col < gameState.gridSize; col++) {
                    if (!gameState.grid[row][col]) {
                        emptyCells.push({ row, col });
                    }
                }
            }
            
            // Wenn keine leeren Zellen mehr, Spiel vorbei
            if (emptyCells.length === 0) {
                gameOver();
                return false;
            }
            
            // Zufällige leere Zelle auswählen
            const cellIndex = getRandomInt(0, emptyCells.length - 1);
            const { row, col } = emptyCells[cellIndex];
            
            // Neue Blase mit dem vorbereiteten Level hinzufügen
            const level = gameState.nextBubble;
            const bubble = createBubbleElement(level, row, col);
            gameContainer.appendChild(bubble);
            gameState.grid[row][col] = level;
            gameState.bubbles.push(bubble);
            
            // Neue nächste Blase vorbereiten
            prepareNextBubble();
            
            // Prüfe, ob es mögliche Züge gibt
            if (emptyCells.length === 1) {
                setTimeout(checkForPossibleMoves, 300);
            }
            
            // Chain-Counter zurücksetzen, wenn Zug abgeschlossen
            resetChainCounter();
            
            return true;
        }

        function prepareNextBubble() {
            gameState.nextBubble = createRandomBubble();
            nextBubbleContainer.innerHTML = '';
            const bubble = createBubbleElement(gameState.nextBubble, 0, 0, true);
            nextBubbleContainer.appendChild(bubble);
        }

        function updateGoalDisplay() {
            // Ziel-Blase anzeigen (die nächste zu erreichende Blase)
            const goalLevel = Math.log2(gameState.currentGoal);
            goalBubbleContainer.innerHTML = '';
            const bubble = createBubbleElement(goalLevel, 0, 0, true);
            goalBubbleContainer.appendChild(bubble);
            
            // Fortschrittsbalken aktualisieren
            goalProgress.style.width = `${gameState.goalProgress}%`;
        }

        function startDragging(e) {
            if (gameState.gameOver) return;
            
            const bubble = e.currentTarget;
            const rect = bubble.getBoundingClientRect();
            
            gameState.draggedBubble = bubble;
            gameState.dragOffsetX = e.clientX - rect.left;
            gameState.dragOffsetY = e.clientY - rect.top;
            
            bubble.classList.add('dragging');
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDragging);
            
            e.preventDefault();
        }

        function handleTouchStart(e) {
            if (gameState.gameOver) return;
            
            const bubble = e.currentTarget;
            const touch = e.touches[0];
            const rect = bubble.getBoundingClientRect();
            
            gameState.draggedBubble = bubble;
            gameState.dragOffsetX = touch.clientX - rect.left;
            gameState.dragOffsetY = touch.clientY - rect.top;
            
            bubble.classList.add('dragging');
            
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            
            e.preventDefault();
        }

        function handleTouchMove(e) {
            if (!gameState.draggedBubble) return;
            
            const touch = e.touches[0];
            onDrag({
                clientX: touch.clientX,
                clientY: touch.clientY,
                preventDefault: () => e.preventDefault()
            });
        }

        function handleTouchEnd() {
            stopDragging();
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }

        function onDrag(e) {
            if (!gameState.draggedBubble) return;
            
            const containerRect = gameContainer.getBoundingClientRect();
            const x = e.clientX - containerRect.left - gameState.dragOffsetX;
            const y = e.clientY - containerRect.top - gameState.dragOffsetY;
            
            gameState.draggedBubble.style.left = `${x}px`;
            gameState.draggedBubble.style.top = `${y}px`;
            
            e.preventDefault();
        }

        function stopDragging() {
            if (!gameState.draggedBubble) return;
            
            const bubble = gameState.draggedBubble;
            const oldRow = parseInt(bubble.dataset.row);
            const oldCol = parseInt(bubble.dataset.col);
            const level = parseInt(bubble.dataset.level);
            
            // Position im Container
            const containerRect = gameContainer.getBoundingClientRect();
            const bubbleRect = bubble.getBoundingClientRect();
            const bubbleCenterX = bubbleRect.left + bubbleRect.width / 2 - containerRect.left;
            const bubbleCenterY = bubbleRect.top + bubbleRect.height / 2 - containerRect.top;
            
            // Zielzelle finden
            const targetCell = getGridCellFromPosition(bubbleCenterX, bubbleCenterY);
            
            // Blase zurück zur Ausgangsposition animieren
            bubble.classList.remove('dragging');
            
            let moveMade = false;
            
            if (targetCell) {
                const { row, col } = targetCell;
                
                // Gleiche Zelle - kein Zug
                if (row === oldRow && col === oldCol) {
                    const pos = getBubblePosition(oldRow, oldCol);
                    bubble.style.left = `${pos.x}px`;
                    bubble.style.top = `${pos.y}px`;
                    gameState.draggedBubble = null;
                    return;
                }
                
                // Prüfen, ob Zielzelle leer ist
                if (!gameState.grid[row][col]) {
                    // Einfach bewegen
                    gameState.grid[oldRow][oldCol] = null;
                    gameState.grid[row][col] = level;
                    
                    bubble.dataset.row = row;
                    bubble.dataset.col = col;
                    
                    const pos = getBubblePosition(row, col);
                    bubble.style.left = `${pos.x}px`;
                    bubble.style.top = `${pos.y}px`;
                    
                    moveMade = true;
                    
                    // Tutorial-Fortschritt
                    if (gameState.tutorialStep === 1) {
                        showTutorial(2);
                    }
                } else if (gameState.grid[row][col] === level) {
                    // Gleiche Blasen verschmelzen
                    gameState.grid[oldRow][oldCol] = null;
                    gameState.grid[row][col] = level + 1;
                    
                    // Zielblase finden
                    const targetBubble = gameState.bubbles.find(
                        b => parseInt(b.dataset.row) === row && parseInt(b.dataset.col) === col
                    );
                    
                    // Effekt und Animation
                    mergeBubbles(bubble, targetBubble, level + 1, row, col);
                    
                    moveMade = true;
                    
                    // Starte Kettenreaktion-Zähler
                    startChainReaction();
                    
                    // Prüfe Achievement "Erste Verschmelzung"
                    unlockAchievement('first_merge');
                    
                    // Tutorial-Fortschritt
                    if (gameState.tutorialStep === 2) {
                        showTutorial(3);
                    }
                } else {
                    // Ungleiches Level, zurück zur Ausgangsposition
                    const pos = getBubblePosition(oldRow, oldCol);
                    bubble.style.left = `${pos.x}px`;
                    bubble.style.top = `${pos.y}px`;
                    gameContainer.classList.add('shake');
                    setTimeout(() => gameContainer.classList.remove('shake'), 500);
                }
            } else {
                // Außerhalb des Spielfelds, zurück zur Ausgangsposition
                const pos = getBubblePosition(oldRow, oldCol);
                bubble.style.left = `${pos.x}px`;
                bubble.style.top = `${pos.y}px`;
            }
            
            gameState.draggedBubble = null;
            
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDragging);
            
            // Neue Blase nach erfolgreichem Zug hinzufügen
            if (moveMade) {
                gameState.moveMade = true;
                gameState.moves++;
                
                // Verzögerung, um Kettenreaktionen abzuwarten
                setTimeout(() => {
                    if (!gameState.gameOver) {
                        addNewBubble();
                    }
                }, 400);
            }
        }

        function startChainReaction() {
            // Erhöhe Zähler und zeige ihn
            gameState.chainCount++;
            updateChainCounter();
        }

        function updateChainCounter() {
            // Zeige den Chain-Counter nur bei mehr als 1 Verschmelzung
            if (gameState.chainCount > 1) {
                chainCounter.textContent = `x${gameState.chainCount}`;
                chainCounter.style.opacity = '1';
                
                // Herausforderungen prüfen
                checkChallengeProgress('chain', gameState.chainCount);
                
                // Achievement prüfen
                if (gameState.chainCount >= 3) unlockAchievement('chain_3');
                if (gameState.chainCount >= 5) unlockAchievement('chain_5');
                
                // Update längste Kette
                if (gameState.chainCount > gameState.longestChain) {
                    gameState.longestChain = gameState.chainCount;
                }
            }
        }

        function resetChainCounter() {
            gameState.chainCount = 0;
            chainCounter.style.opacity = '0';
        }

        function mergeBubbles(bubble1, bubble2, newLevel, row, col, isChain = false) {
            // Aktualisiere höchstes Level
            if (newLevel > gameState.maxLevel) {
                gameState.maxLevel = newLevel;
                const newValue = Math.pow(2, newLevel);
                gameState.maxValue = newValue;
                
                // Prüfe, ob wir das Ziel erreicht haben
                if (newValue >= gameState.currentGoal) {
                    // Neues Ziel setzen (nächste Potenz von 2)
                    gameState.currentGoal = gameState.currentGoal * 2;
                    gameState.goalProgress = 0;
                    
                    // Bonuspunkte für Zielerreichung
                    const bonus = newValue * 2;
                    updateScore(bonus, true);
                    createScorePopup(`ZIEL! +${formatNumber(bonus)}`, row, col, true);
                } else {
                    // Fortschritt zum Ziel aktualisieren (logarithmisch)
                    const progress = (Math.log2(newValue) / Math.log2(gameState.currentGoal)) * 100;
                    gameState.goalProgress = Math.min(progress, 99); // Nie ganz 100% erreichen, bis zum tatsächlichen Ziel
                }
                
                updateGoalDisplay();
                
                // Prüfe Achievements für bestimmte Werte
                const value = Math.pow(2, newLevel);
                if (value >= 16) unlockAchievement('level_16');
                if (value >= 64) unlockAchievement('level_64');
                if (value >= 256) unlockAchievement('level_256');
                if (value >= 1024) unlockAchievement('level_1024');
                
                // Prüfe Challenge-Fortschritt für Werte
                checkChallengeProgress('value', value);
            }
            
            // Animation für die zweite Blase
            bubble2.classList.add(isChain ? 'chain-merge' : 'merging');
            
            // Entferne die erste Blase
            gameState.bubbles = gameState.bubbles.filter(b => b !== bubble1);
            bubble1.remove();
            
            // Aktualisiere die zweite Blase
            setTimeout(() => {
                bubble2.dataset.level = newLevel;
                const value = Math.pow(2, newLevel);
                bubble2.dataset.value = value;
                bubble2.querySelector('.bubble-inner').textContent = formatNumber(value);
                
                const colorIndex = (newLevel - 1) % BUBBLE_COLORS.length;
                bubble2.style.backgroundColor = BUBBLE_COLORS[colorIndex];
                
                bubble2.classList.remove(isChain ? 'chain-merge' : 'merging');
                
                // Punkte hinzufügen mit Chain-Bonus
                const chainMultiplier = Math.max(1, isChain ? Math.min(gameState.chainCount, 10) : 1);
                const points = Math.pow(2, newLevel) * 5 * chainMultiplier;
                updateScore(points);
                
                // Punkte-Popup
                const pos = getBubblePosition(row, col);
                if (chainMultiplier > 1) {
                    createScorePopup(`+${formatNumber(points)} (x${chainMultiplier})`, pos.x, pos.y, true);
                } else {
                    createScorePopup(`+${formatNumber(points)}`, pos.x, pos.y);
                }
                
                // Prüfe mögliche Folgeverschmelzungen
                setTimeout(() => {
                    const hasChainMerge = checkForChainMerges(row, col, newLevel);
                    
                    // Wenn keine Kettenfusion stattgefunden hat, setze Chain-Counter zurück
                    if (!hasChainMerge && !isChain) {
                        // Reset wird verzögert, um zu sehen, ob noch Kettenreaktionen folgen
                        // Der tatsächliche Reset erfolgt in addNewBubble()
                    }
                }, 250);
            }, 400);
        }

        function checkForChainMerges(row, col, level) {
            // Nachbarzeichen prüfen
            const neighbors = [
                { row: row - 1, col: col },  // oben
                { row: row + 1, col: col },  // unten
                { row: row, col: col - 1 },  // links
                { row: row, col: col + 1 }   // rechts
            ];
            
            // Filtere gültige Nachbarn
            const validNeighbors = neighbors.filter(n => 
                n.row >= 0 && n.row < gameState.gridSize && 
                n.col >= 0 && n.col < gameState.gridSize &&
                gameState.grid[n.row][n.col] === level
            );
            
            if (validNeighbors.length > 0) {
                // Wähle den ersten passenden Nachbarn
                const target = validNeighbors[0];
                
                // Finde Blasen
                const sourceBubble = gameState.bubbles.find(
                    b => parseInt(b.dataset.row) === row && parseInt(b.dataset.col) === col
                );
                
                const targetBubble = gameState.bubbles.find(
                    b => parseInt(b.dataset.row) === target.row && parseInt(b.dataset.col) === target.col
                );
                
                // Kettenreaktion mit Verzögerung
                setTimeout(() => {
                    if (sourceBubble && targetBubble) {
                        gameState.grid[row][col] = null;
                        gameState.grid[target.row][target.col] = level + 1;
                        
                        // Erhöhe Kettenreaktion-Zähler
                        startChainReaction();
                        
                        mergeBubbles(sourceBubble, targetBubble, level + 1, target.row, target.col, true);
                    }
                }, 350);
                
                return true;
            }
            
            return false;
        }

        function updateScore(points, isBonus = false) {
            gameState.score += points;
            scoreElement.textContent = formatNumber(gameState.score);
            
            // Levelberechnung mit logarithmischer Progression
            const newLevel = Math.floor(Math.log2(gameState.score + 1) / 2) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                levelElement.textContent = translate({ de: `Level ${gameState.level}` });
            }
            
            // Prüfe Achievements für Punkte
            if (gameState.score >= 1000) unlockAchievement('score_1000');
            if (gameState.score >= 5000) unlockAchievement('score_5000');
            
            // Prüfe Challenge-Fortschritt für Punkte
            checkChallengeProgress('score', gameState.score);
        }

        function createScorePopup(text, x, y, isBonus = false) {
            const popup = document.createElement('div');
            popup.className = isBonus ? 'score-popup chain-bonus' : 'score-popup';
            popup.textContent = text;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            
            gameContainer.appendChild(popup);
            
            // Entferne nach Animation
            setTimeout(() => popup.remove(), isBonus ? 1500 : 1200);
        }

        function checkForPossibleMoves() {
            let hasMoves = false;
            
            // Prüfe auf leere Zellen
            for (let row = 0; row < gameState.gridSize; row++) {
                for (let col = 0; col < gameState.gridSize; col++) {
                    if (!gameState.grid[row][col]) {
                        hasMoves = true;
                        break;
                    }
                }
                if (hasMoves) break;
            }
            
            // Prüfe auf mögliche Verschmelzungen
            if (!hasMoves) {
                for (let row = 0; row < gameState.gridSize; row++) {
                    for (let col = 0; col < gameState.gridSize; col++) {
                        const level = gameState.grid[row][col];
                        
                        // Nachbarn prüfen
                        const neighbors = [
                            { row: row - 1, col: col },  // oben
                            { row: row + 1, col: col },  // unten
                            { row: row, col: col - 1 },  // links
                            { row: row, col: col + 1 }   // rechts
                        ];
                        
                        for (const n of neighbors) {
                            if (n.row >= 0 && n.row < gameState.gridSize && 
                                n.col >= 0 && n.col < gameState.gridSize &&
                                gameState.grid[n.row][n.col] === level) {
                                hasMoves = true;
                                break;
                            }
                        }
                        
                        if (hasMoves) break;
                    }
                    if (hasMoves) break;
                }
            }
            
            if (!hasMoves) {
                gameOver();
            }
            
            return hasMoves;
        }

        function gameOver() {
            if (gameState.gameOver) return;
            
            gameState.gameOver = true;
            
            // Spielzeit berechnen
            if (gameState.startTime) {
                const endTime = new Date();
                gameState.playTime = Math.floor((endTime - gameState.startTime) / 1000);
            }
            
            // Statistik-Updates
            updateStats();
            
            // UI aktualisieren
            finalScoreElement.textContent = formatNumber(gameState.score);
            highestBubbleElement.textContent = gameState.maxLevel;
            highestValueElement.textContent = formatNumber(gameState.maxValue);
            longestChainElement.textContent = gameState.longestChain;
            playedTimeElement.textContent = formatTime(gameState.playTime);
            totalMovesElement.textContent = gameState.moves;
            
            setTimeout(() => {
                gameOverModal.classList.add('active');
            }, 500);
        }

        function updateStats() {
            // Highscore
            if (gameState.score > gameState.stats.highscore) {
                gameState.stats.highscore = gameState.score;
            }
            
            // Höchste Blase
            if (gameState.maxLevel > gameState.stats.highestLevel) {
                gameState.stats.highestLevel = gameState.maxLevel;
                gameState.stats.highestValue = gameState.maxValue;
            }
            
            // Längste Kette
            if (gameState.longestChain > gameState.stats.longestChain) {
                gameState.stats.longestChain = gameState.longestChain;
            }
            
            // Spiele gezählt
            gameState.stats.gamesPlayed++;
            
            // Achievement für Anzahl der Spiele
            if (gameState.stats.gamesPlayed >= 10) {
                unlockAchievement('games_10');
            }
            
            // In LocalStorage speichern
            saveStatsToStorage();
        }

        function createGridOverlay() {
            gridOverlay.innerHTML = '';
            gridOverlay.style.gridTemplateColumns = `repeat(${gameState.gridSize}, 1fr)`;
            gridOverlay.style.gridTemplateRows = `repeat(${gameState.gridSize}, 1fr)`;
            
            for (let i = 0; i < gameState.gridSize * gameState.gridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridOverlay.appendChild(cell);
            }
        }

        function initNewGame() {
            // Zurücksetzen des Spielstatus
            gameState.score = 0;
            gameState.level = 1;
            gameState.maxLevel = 1;
            gameState.maxValue = 2;
            gameState.grid = Array(gameState.gridSize).fill().map(() => Array(gameState.gridSize).fill(null));
            gameState.bubbles = [];
            gameState.draggedBubble = null;
            gameState.gameOver = false;
            gameState.moveMade = false;
            gameState.startTime = new Date();
            gameState.playTime = 0;
            gameState.moves = 0;
            gameState.chainCount = 0;
            gameState.longestChain = 0;
            gameState.currentGoal = 8; // Start mit 8 (2^3)
            gameState.goalProgress = 0;
            
            // UI zurücksetzen
            gameContainer.innerHTML = '<div class="grid-overlay" id="grid-overlay"></div><div class="chain-counter" id="chain-counter">x1</div>';
            gridOverlay = document.getElementById('grid-overlay');
            createGridOverlay();
            
            scoreElement.textContent = '0';
            levelElement.textContent = translate({ de: 'Level 1' });
            
            // Nächste Blase und Ziel vorbereiten
            prepareNextBubble();
            updateGoalDisplay();
            
            // Weniger Anfangsblasen für mehr Spielraum
            const initialBubbles = Math.floor(gameState.gridSize * gameState.gridSize * 0.25);
            for (let i = 0; i < initialBubbles; i++) {
                addNewBubble();
            }
            
            // Erster Spielstart
            if (!gameState.newGameStarted) {
                gameState.newGameStarted = true;
                loadStatsFromStorage();
                setCurrentChallenge();
                setTimeout(() => showTutorial(1), 500);
            }
        }

        function showTutorial(step) {
            // Tutorials nur beim ersten Spielstart anzeigen
            if (gameState.tutorialStep > step) return;
            
            gameState.tutorialStep = step;
            tutorialsContainer.innerHTML = '';
            
            let tutorial;
            
            switch (step) {
                case 1:
                    // Erste Anleitung: Bewegen
                    tutorial = document.createElement('div');
                    tutorial.className = 'tutorial bottom';
                    tutorial.style.bottom = '70%';
                    tutorial.style.left = '50%';
                    tutorial.style.transform = 'translateX(-50%)';
                    tutorial.innerHTML = translate({ 
                        de: 'Ziehe eine Blase, um sie zu bewegen.<br><button>Verstanden</button>' 
                    });
                    tutorialsContainer.appendChild(tutorial);
                    
                    tutorial.querySelector('button').addEventListener('click', () => {
                        tutorial.remove();
                    });
                    break;
                
                case 2:
                    // Zweite Anleitung: Verschmelzen
                    tutorial = document.createElement('div');
                    tutorial.className = 'tutorial top';
                    tutorial.style.top = '70%';
                    tutorial.style.left = '50%';
                    tutorial.style.transform = 'translateX(-50%)';
                    tutorial.innerHTML = translate({ 
                        de: 'Verbinde zwei gleiche Blasen, um eine größere zu erzeugen!<br><button>Verstanden</button>' 
                    });
                    tutorialsContainer.appendChild(tutorial);
                    
                    tutorial.querySelector('button').addEventListener('click', () => {
                        tutorial.remove();
                    });
                    break;
                
                case 3:
                    // Dritte Anleitung: Ketten
                    tutorial = document.createElement('div');
                    tutorial.className = 'tutorial bottom';
                    tutorial.style.top = '20%';
                    tutorial.style.left = '50%';
                    tutorial.style.transform = 'translateX(-50%)';
                    tutorial.innerHTML = translate({ 
                        de: 'Super! Versuche Kettenreaktionen zu erzeugen für extra Bonuspunkte.<br>Jede Verschmelzung in einer Kette gibt mehr Punkte!<br><button>Verstanden</button>' 
                    });
                    tutorialsContainer.appendChild(tutorial);
                    
                    tutorial.querySelector('button').addEventListener('click', () => {
                        tutorial.remove();
                    });
                    break;
            }
        }
        
        // Neue Funktionen für Achievements und Challenges
        function unlockAchievement(id) {
            // Prüfe, ob Achievement bereits freigeschaltet
            if (gameState.stats.achievements.includes(id)) return;
            
            // Achievement freischalten
            gameState.stats.achievements.push(id);
            
            // In LocalStorage speichern
            saveStatsToStorage();
        }
        
        function setCurrentChallenge() {
            // Nächste Challenge setzen
            const challengeIndex = gameState.stats.currentChallenge % CHALLENGES.length;
            gameState.challenge = CHALLENGES[challengeIndex];
            gameState.stats.challengeProgress = 0;
            
            // UI aktualisieren
            updateChallengeUI();
        }
        
        function checkChallengeProgress(type, value) {
            if (!gameState.challenge || gameState.challenge.type !== type) return;
            
            // Fortschritt aktualisieren
            const currentValue = Math.max(value, gameState.stats.challengeProgress);
            const progress = (currentValue / gameState.challenge.target) * 100;
            gameState.stats.challengeProgress = currentValue;
            
            // Prüfe auf Challenge-Abschluss
            if (currentValue >= gameState.challenge.target) {
                // Belohnung gewähren
                updateScore(gameState.challenge.reward, true);
                createScorePopup(`Herausforderung geschafft! +${formatNumber(gameState.challenge.reward)}`, 
                    gameContainer.offsetWidth / 2, gameContainer.offsetHeight / 2, true);
                
                // Nächste Challenge
                gameState.stats.currentChallenge++;
                setCurrentChallenge();
            } else {
                // Fortschritt aktualisieren
                updateChallengeUI();
            }
            
            // Speichern
            saveStatsToStorage();
        }
        
        function updateChallengeUI() {
            if (!gameState.challenge) return;
            
            // Beschreibung
            challengeDescription.textContent = gameState.challenge.description;
            
            // Fortschrittsbalken
            const progress = Math.min(
                (gameState.stats.challengeProgress / gameState.challenge.target) * 100, 
                100
            );
            challengeProgressBar.style.width = `${progress}%`;
            
            // Belohnung
            challengeReward.textContent = `+${formatNumber(gameState.challenge.reward)} Punkte`;
        }
        
        function updateAchievementsUI() {
            achievementsContainer.innerHTML = '';
            
            // Alle Achievements anzeigen
            ACHIEVEMENTS.forEach(achievement => {
                const isUnlocked = gameState.stats.achievements.includes(achievement.id);
                
                const badge = document.createElement('div');
                badge.className = 'achievement-badge';
                badge.style.opacity = isUnlocked ? '1' : '0.5';
                
                badge.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-info">
                        <div class="achievement-title">${achievement.title}</div>
                        <div class="achievement-desc">${achievement.description}</div>
                    </div>
                `;
                
                achievementsContainer.appendChild(badge);
            });
        }
        
        function updateStatsUI() {
            statsHighscoreElement.textContent = formatNumber(gameState.stats.highscore);
            statsHighestBubbleElement.textContent = `${gameState.stats.highestLevel} (${formatNumber(gameState.stats.highestValue)})`;
            statsLongestChainElement.textContent = gameState.stats.longestChain;
            statsGamesPlayedElement.textContent = gameState.stats.gamesPlayed;
            
            updateAchievementsUI();
            updateChallengeUI();
        }
        
        // Local Storage Funktionen
        function saveStatsToStorage() {
            try {
                localStorage.setItem('bubbleMergeStats', JSON.stringify(gameState.stats));
            } catch (e) {
                console.error('Failed to save stats to localStorage', e);
            }
        }
        
        function loadStatsFromStorage() {
            try {
                const storedStats = localStorage.getItem('bubbleMergeStats');
                if (storedStats) {
                    gameState.stats = JSON.parse(storedStats);
                }
            } catch (e) {
                console.error('Failed to load stats from localStorage', e);
            }
        }
        
        function resetStats() {
            gameState.stats = {
                highscore: 0,
                highestLevel: 1,
                highestValue: 2,
                longestChain: 0,
                gamesPlayed: 0,
                achievements: [],
                currentChallenge: 0,
                challengeProgress: 0
            };
            
            saveStatsToStorage();
            updateStatsUI();
            setCurrentChallenge();
        }

        // Event-Listener
        themeToggle.addEventListener('click', () => {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            
            if (isDark) {
                document.body.removeAttribute('data-theme');
                moonIcon.style.display = 'block';
                sunIcon.style.display = 'none';
            } else {
                document.body.setAttribute('data-theme', 'dark');
                moonIcon.style.display = 'none';
                sunIcon.style.display = 'block';
            }
        });

        restartButton.addEventListener('click', () => {
            initNewGame();
        });
        
        statsButton.addEventListener('click', () => {
            updateStatsUI();
            statsModal.classList.add('active');
        });
        
        closeStatsButton.addEventListener('click', () => {
            statsModal.classList.remove('active');
        });
        
        resetStatsButton.addEventListener('click', () => {
            if (confirm(translate({ de: 'Möchtest du wirklich alle Statistiken zurücksetzen? Dies kann nicht rückgängig gemacht werden.' }))) {
                resetStats();
            }
        });

        playAgainButton.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            initNewGame();
        });
        
        shareButton.addEventListener('click', () => {
            const text = translate({ 
                de: `Ich habe ${formatNumber(gameState.score)} Punkte in Bubble Merge erreicht, mit einer Blase vom Level ${gameState.maxLevel} (${formatNumber(gameState.maxValue)}) und einer Kette von ${gameState.longestChain} Verschmelzungen!` 
            });
            
            // Versuche Web Share API wenn verfügbar
            if (navigator.share) {
                navigator.share({
                    title: 'Bubble Merge',
                    text: text
                }).catch(err => {
                    // Fallback: In Zwischenablage kopieren
                    navigator.clipboard.writeText(text)
                        .then(() => alert(translate({ de: 'Ergebnis in die Zwischenablage kopiert!' })))
                        .catch(() => alert(translate({ de: 'Konnte nicht geteilt werden. Bitte manuell kopieren.' })));
                });
            } else {
                // Fallback: In Zwischenablage kopieren
                navigator.clipboard.writeText(text)
                    .then(() => alert(translate({ de: 'Ergebnis in die Zwischenablage kopiert!' })))
                    .catch(() => alert(translate({ de: 'Konnte nicht geteilt werden. Bitte manuell kopieren.' })));
            }
        });

        startGameButton.addEventListener('click', () => {
            tutorialModal.classList.remove('active');
            initNewGame();
        });

        // Window Resize Handler
        window.addEventListener('resize', () => {
            createGridOverlay();
            
            if (gameState.bubbles.length > 0) {
                // Positionen aller Blasen neu berechnen
                gameState.bubbles.forEach(bubble => {
                    const row = parseInt(bubble.dataset.row);
                    const col = parseInt(bubble.dataset.col);
                    const pos = getBubblePosition(row, col);
                    
                    const size = calculateBubbleSize();
                    bubble.style.width = `${size}px`;
                    bubble.style.height = `${size}px`;
                    bubble.style.left = `${pos.x}px`;
                    bubble.style.top = `${pos.y}px`;
                });
            }
        });

        // Spielzeit-Tracking
        setInterval(() => {
            if (gameState.startTime && !gameState.gameOver) {
                const now = new Date();
                gameState.playTime = Math.floor((now - gameState.startTime) / 1000);
            }
        }, 1000);

        // Bevorzugtes Farbschema
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.setAttribute('data-theme', 'dark');
            moonIcon.style.display = 'none';
            sunIcon.style.display = 'block';
        }

        // Spiel starten
        setTimeout(() => {
            tutorialModal.classList.add('active');
        }, 500);
    </script>
</body>
</html>